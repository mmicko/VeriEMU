// Generated by astgen // -*- mode: C++; c-file-style: "cc-mode" -*-
#line 1 "../V3Const.cpp"
// -*- mode: C++; c-file-style: "cc-mode" -*-
//*************************************************************************
// DESCRIPTION: Verilator: Constant folding
//
// Code available from: http://www.veripool.org/verilator
//
//*************************************************************************
//
// Copyright 2003-2018 by Wilson Snyder.  This program is free software; you can
// redistribute it and/or modify it under the terms of either the GNU
// Lesser General Public License Version 3 or the Perl Artistic License
// Version 2.0.
//
// Verilator is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
//*************************************************************************
// CONST TRANSFORMATIONS:
//   Call on one node for PARAM values, or netlist for overall constant folding:
//	Bottom up traversal:
//	    Attempt to convert operands to constants
//	    If operands are constant, replace this node with constant.
//*************************************************************************

#include "config_build.h"
#include "verilatedos.h"
#include <cstdio>
#include <cstdarg>
#include <unistd.h>
#include <map>
#include <algorithm>

#include "V3Global.h"
#include "V3String.h"
#include "V3Const.h"
#include "V3Ast.h"
#include "V3Width.h"
#include "V3Simulate.h"

//######################################################################
// Utilities

class ConstVarMarkVisitor : public AstNVisitor {
    // NODE STATE
    // AstVar::user4p		-> bool, Var marked, 0=not set yet
private:
    // VISITORS
    virtual void visit(AstVarRef* nodep) {
	if (nodep->varp()) nodep->varp()->user4(1);
    }
    virtual void visit(AstNode* nodep) {
	nodep->iterateChildren(*this);
    }
public:
    // CONSTUCTORS
    explicit ConstVarMarkVisitor(AstNode* nodep) {
	AstNode::user4ClearTree();  // Check marked InUse before we're called
	nodep->accept(*this);
    }
    virtual ~ConstVarMarkVisitor() {}
};

class ConstVarFindVisitor : public AstNVisitor {
    // NODE STATE
    // AstVar::user4p		-> bool, input from ConstVarMarkVisitor
    // MEMBERS
    bool m_found;
private:
    // VISITORS
    virtual void visit(AstVarRef* nodep) {
	if (nodep->varp() && nodep->varp()->user4()) m_found = true;
    }
    virtual void visit(AstNode* nodep) {
	nodep->iterateChildren(*this);
    }
public:
    // CONSTUCTORS
    explicit ConstVarFindVisitor(AstNode* nodep) {
	m_found = false;
	nodep->iterateAndNext(*this);
    }
    virtual ~ConstVarFindVisitor() {}
    // METHODS
    bool found() const { return m_found; }
};

//######################################################################
// Const state, as a visitor of each AstNode

class ConstVisitor : public AstNVisitor {
private:
    // NODE STATE
    // ** only when m_warn/m_doExpensive is set.  If state is needed other times,
    // ** must track down everywhere V3Const is called and make sure no overlaps.
    // AstVar::user4p		-> Used by ConstVarMarkVisitor/ConstVarFindVisitor
    // AstJumpLabel::user4	-> bool.  Set when AstJumpGo uses this label

    // STATE
    bool	m_params;	// If true, propogate parameterized and true numbers only
    bool	m_required;	// If true, must become a constant
    bool	m_wremove;	// Inside scope, no assignw removal
    bool	m_warn;		// Output warnings
    bool	m_doExpensive;	// Enable computationally expensive optimizations
    bool	m_doNConst;	// Enable non-constant-child simplifications
    bool	m_doShort;	// Remove expressions that short circuit
    bool	m_doV;		// Verilog, not C++ conversion
    bool	m_doGenerate;	// Postpone width checking inside generate
    bool        m_hasJumpGo;    // JumpGo under this while
    AstNodeModule*	m_modp;	// Current module
    AstArraySel*	m_selp;	// Current select
    AstNode*	m_scopep;	// Current scope
    AstAttrOf*	m_attrp;	// Current attribute

    // METHODS
    static int debug() {
	static int level = -1;
	if (VL_UNLIKELY(level < 0)) level = v3Global.opt.debugSrcLevel(__FILE__);
	return level;
    }

    bool operandConst (AstNode* nodep) {
	return (nodep->castConst());
    }
    bool operandAsvConst (AstNode* nodep) {
	// BIASV(CONST, BIASV(CONST,...)) -> BIASV( BIASV_CONSTED(a,b), ...)
	AstNodeBiComAsv* bnodep = nodep->castNodeBiComAsv();
	if (!bnodep) return false;
	if (!bnodep->lhsp()->castConst()) return false;
	AstNodeBiComAsv* rnodep = bnodep->rhsp()->castNodeBiComAsv();
	if (!rnodep) return false;
	if (rnodep->type() != bnodep->type()) return false;
	if (rnodep->width() != bnodep->width()) return false;
	if (rnodep->lhsp()->width() != bnodep->lhsp()->width()) return false;
	if (!rnodep->lhsp()->castConst()) return false;
	return true;
    }
    bool operandAsvSame (AstNode* nodep) {
	// BIASV(SAMEa, BIASV(SAMEb,...)) -> BIASV( BIASV(SAMEa,SAMEb), ...)
	AstNodeBiComAsv* bnodep = nodep->castNodeBiComAsv();
	if (!bnodep) return false;
	AstNodeBiComAsv* rnodep = bnodep->rhsp()->castNodeBiComAsv();
	if (!rnodep) return false;
	if (rnodep->type() != bnodep->type()) return false;
	if (rnodep->width() != bnodep->width()) return false;
	return operandsSame(bnodep->lhsp(), rnodep->lhsp());
    }
    bool operandAsvLUp (AstNode* nodep) {
	// BIASV(BIASV(CONSTll,lr),r) -> BIASV(CONSTll,BIASV(lr,r))
	//
	// Example of how this is useful:
	// BIASV(BIASV(CONSTa,b...),BIASV(CONSTc,d...))	 // hits operandAsvUp
	// BIASV(CONSTa,BIASV(b...,BIASV(CONSTc,d...)))	 // hits operandAsvUp
	// BIASV(CONSTa,BIASV(CONSTc,BIASV(c...,d...)))  // hits operandAsvConst
	// BIASV(BIASV(CONSTa,CONSTc),BIASV(c...,d...))) // hits normal constant propagation
	// BIASV(CONST_a_c,BIASV(c...,d...)))
	//
	// Idea for the future: All BiComAsvs could be lists, sorted by if they're constant
	AstNodeBiComAsv* bnodep = nodep->castNodeBiComAsv();
	if (!bnodep) return false;
	AstNodeBiComAsv* lnodep = bnodep->lhsp()->castNodeBiComAsv();
	if (!lnodep) return false;
	if (lnodep->type() != bnodep->type()) return false;
	if (lnodep->width() != bnodep->width()) return false;
	return lnodep->lhsp()->castConst();
    }
    bool operandAsvRUp (AstNode* nodep) {
	// BIASV(l,BIASV(CONSTrl,rr)) -> BIASV(CONSTrl,BIASV(l,rr))
	AstNodeBiComAsv* bnodep = nodep->castNodeBiComAsv();
	if (!bnodep) return false;
	AstNodeBiComAsv* rnodep = bnodep->rhsp()->castNodeBiComAsv();
	if (!rnodep) return false;
	if (rnodep->type() != bnodep->type()) return false;
	if (rnodep->width() != bnodep->width()) return false;
	return rnodep->lhsp()->castConst();
    }
    static bool operandSubAdd(AstNode* nodep) {
	// SUB( ADD(CONSTx,y), CONSTz) -> ADD(SUB(CONSTx,CONSTz), y)
	AstNodeBiop* np = nodep->castNodeBiop();
	AstNodeBiop* lp = np->lhsp()->castNodeBiop();
	return (lp
		&& lp->lhsp()->castConst()
		&& np->rhsp()->castConst()
		&& lp->width()==np->width());
    }

    static bool operandAndOrSame(AstNode* nodep) {
	// OR( AND(VAL,x), AND(VAL,y)) -> AND(VAL,OR(x,y))
	// OR( AND(x,VAL), AND(y,VAL)) -> AND(OR(x,y),VAL)
	AstNodeBiop* np = nodep->castNodeBiop();
	AstNodeBiop* lp = np->lhsp()->castNodeBiop();
	AstNodeBiop* rp = np->rhsp()->castNodeBiop();
	return (lp && rp
		&& lp->width()==rp->width()
		&& lp->type()==rp->type()
		&& (operandsSame(lp->lhsp(),rp->lhsp())
		    || operandsSame(lp->rhsp(),rp->rhsp())));
    }
    static bool matchOrAndNot(AstNodeBiop* nodep) {
	// AstOr{$a, AstAnd{AstNot{$b}, $c}} if $a.width1, $a==$b => AstOr{$a,$c}
	// Someday we'll sort the biops completely and this can be simplified
	// This often results from our simplified clock generation:
	// if (rst) ... else if (enable)... -> OR(rst,AND(!rst,enable))
	AstNode* ap;
	AstNodeBiop* andp;
	if      (nodep->lhsp()->castAnd()) { andp=nodep->lhsp()->castAnd(); ap=nodep->rhsp(); }
	else if (nodep->rhsp()->castAnd()) { andp=nodep->rhsp()->castAnd(); ap=nodep->lhsp(); }
	else return false;
	AstNodeUniop* notp;
	AstNode* cp;
	if      (andp->lhsp()->castNot()) { notp=andp->lhsp()->castNot(); cp=andp->rhsp(); }
	else if (andp->rhsp()->castNot()) { notp=andp->rhsp()->castNot(); cp=andp->lhsp(); }
	else return false;
	AstNode* bp = notp->lhsp();
	if (!operandsSame(ap, bp)) return false;
	// Do it
	cp->unlinkFrBack();
	andp->unlinkFrBack()->deleteTree(); VL_DANGLING(andp); VL_DANGLING(notp);
	// Replace whichever branch is now dangling
	if (nodep->rhsp()) nodep->lhsp(cp);
	else nodep->rhsp(cp);
	return true;
    }
    static bool operandShiftSame(AstNode* nodep) {
	AstNodeBiop* np = nodep->castNodeBiop();
	{
	    AstShiftL* lp = np->lhsp()->castShiftL();
	    AstShiftL* rp = np->rhsp()->castShiftL();
	    if (lp && rp) {
		return (lp->width() == rp->width()
			&& lp->lhsp()->width() == rp->lhsp()->width()
			&& operandsSame(lp->rhsp(), rp->rhsp()));
	    }
	}
	{
	    AstShiftR* lp = np->lhsp()->castShiftR();
	    AstShiftR* rp = np->rhsp()->castShiftR();
	    if (lp && rp) {
		return (lp->width() == rp->width()
			&& lp->lhsp()->width() == rp->lhsp()->width()
			&& operandsSame(lp->rhsp(), rp->rhsp()));
	    }
	}
	return false;
    }
    bool operandHugeShiftL(AstNodeBiop* nodep) {
	return (nodep->rhsp()->castConst()
		&& !nodep->rhsp()->castConst()->num().isFourState()
		&& nodep->rhsp()->castConst()->toUInt() >= (uint32_t)(nodep->width())
		&& isTPure(nodep->lhsp()));
    }
    bool operandHugeShiftR(AstNodeBiop* nodep) {
	return (nodep->rhsp()->castConst()
		&& !nodep->rhsp()->castConst()->num().isFourState()
		&& nodep->rhsp()->castConst()->toUInt() >= (uint32_t)(nodep->lhsp()->width())
		&& isTPure(nodep->lhsp()));
    }
    bool operandIsTwo(AstNode* nodep) {
	return (nodep->castConst()
		&& !nodep->castConst()->num().isFourState()
		&& nodep->width() <= VL_QUADSIZE
		&& nodep->castConst()->toUQuad()==2);
    }
    bool operandIsTwostate(AstNode* nodep) {
	return (nodep->castConst()
		&& !nodep->castConst()->num().isFourState());
    }
    bool operandIsPowTwo(AstNode* nodep) {
	if (!operandIsTwostate(nodep)) return false;
	return (1==nodep->castConst()->num().countOnes());
    }
    bool operandShiftOp(AstNodeBiop* nodep) {
	if (!nodep->rhsp()->castConst()) return false;
	AstNodeBiop* lhsp = nodep->lhsp()->castNodeBiop();
	if (!lhsp || !(lhsp->castAnd()||lhsp->castOr()||lhsp->castXor())) return false;
	if (nodep->width()!=lhsp->width()) return false;
	if (nodep->width()!=lhsp->lhsp()->width()) return false;
	if (nodep->width()!=lhsp->rhsp()->width()) return false;
	return true;
    }
    bool operandShiftShift(AstNodeBiop* nodep) {
	// We could add a AND though.
	AstNodeBiop* lhsp = nodep->lhsp()->castNodeBiop();
	if (!lhsp || !(lhsp->castShiftL()||lhsp->castShiftR())) return false;
	// We can only get rid of a<<b>>c or a<<b<<c, with constant b & c
	// because bits may be masked in that process, or (b+c) may exceed the word width.
	if (!(nodep->rhsp()->castConst() && lhsp->rhsp()->castConst())) return false;
	if (nodep->rhsp()->castConst()->num().isFourState()
	    || lhsp->rhsp()->castConst()->num().isFourState()) return false;
	if (nodep->width()!=lhsp->width()) return false;
	if (nodep->width()!=lhsp->lhsp()->width()) return false;
	return true;
    }
    bool operandWordOOB(AstWordSel* nodep) {
	// V3Expand may make a arraysel that exceeds the bounds of the array
	// It was an expression, then got constified.  In reality, the WordSel
	// must be wrapped in a Cond, that will be false.
	return (nodep->rhsp()->castConst()
		&& nodep->fromp()->castNodeVarRef()
		&& !nodep->fromp()->castNodeVarRef()->lvalue()
		&& ((int)(nodep->rhsp()->castConst()->toUInt())
		    >= nodep->fromp()->castNodeVarRef()->varp()->widthWords()));
    }
    bool operandSelFull(AstSel* nodep) {
	return (nodep->lsbp()->castConst()
		&& nodep->widthp()->castConst()
		&& nodep->lsbConst()==0
		&& (int)nodep->widthConst()==nodep->fromp()->width());
    }
    bool operandSelExtend(AstSel* nodep) {
	// A pattern created by []'s after offsets have been removed
	// SEL(EXTEND(any,width,...),(width-1),0) -> ...
	// Since select's return unsigned, this is always an extend
	AstExtend* extendp = nodep->fromp()->castExtend();
	if (!(m_doV
	      && extendp
	      && nodep->lsbp()->castConst()
	      && nodep->widthp()->castConst()
	      && nodep->lsbConst()==0
	      && (int)nodep->widthConst()==extendp->lhsp()->width()
		)) return false;
	replaceWChild(nodep, extendp->lhsp()); VL_DANGLING(nodep);
	return true;
    }
    bool operandSelBiLower(AstSel* nodep) {
	// SEL(ADD(a,b),(width-1),0) -> ADD(SEL(a),SEL(b))
	// Add or any operation which doesn't care if we discard top bits
	AstNodeBiop* bip = nodep->fromp()->castNodeBiop();
	if (!(m_doV
	      && bip
	      && nodep->lsbp()->castConst()
	      && nodep->widthp()->castConst()
	      && nodep->lsbConst()==0
		)) return false;
	if (debug()>=9) nodep->dumpTree(cout,"SEL(BI)-in:");
	AstNode* bilhsp = bip->lhsp()->unlinkFrBack();
	AstNode* birhsp = bip->rhsp()->unlinkFrBack();
	bip->lhsp(new AstSel(nodep->fileline(), bilhsp, 0, nodep->widthConst()));
	bip->rhsp(new AstSel(nodep->fileline(), birhsp, 0, nodep->widthConst()));
	if (debug()>=9) bip->dumpTree(cout,"SEL(BI)-ou:");
	replaceWChild(nodep, bip); VL_DANGLING(nodep);
	return true;
    }
    bool operandSelShiftLower(AstSel* nodep) {
	// AND({a}, SHIFTR({b}, {c})) is often shorthand in C for Verilog {b}[{c} :+ {a}]
	// becomes thought other optimizations
	// SEL(SHIFTR({a},{b}),{lsb},{width}) -> SEL({a},{lsb+b},{width})
	AstShiftR* shiftp = nodep->fromp()->castShiftR();
	if (!(m_doV
	      && shiftp
	      && shiftp->rhsp()->castConst()
	      && nodep->lsbp()->castConst()
	      && nodep->widthp()->castConst()
		)) return false;
	AstNode* ap = shiftp->lhsp();
	AstConst* bp = shiftp->rhsp()->castConst();
	AstConst* lp = nodep->lsbp()->castConst();
	if (bp->isWide() || bp->num().isFourState() || bp->num().isNegative()
	    || lp->isWide() || lp->num().isFourState() || lp->num().isNegative()) return false;
	int newLsb = lp->toSInt() + bp->toSInt();
	if (newLsb + nodep->widthConst() > ap->width()) return false;
	//
	UINFO(9, "SEL(SHIFTR(a,b),l,w) -> SEL(a,l+b,w)\n");
	if (debug()>=9) nodep->dumpTree(cout,"SEL(SH)-in:");
	AstSel* newp = new AstSel(nodep->fileline(), ap->unlinkFrBack(), newLsb, nodep->widthConst());
	newp->dtypeFrom(nodep);
	if (debug()>=9) newp->dumpTree(cout,"SEL(SH)-ou:");
	nodep->replaceWith(newp); VL_DANGLING(nodep);
	return true;
    }

    bool operandBiExtendConstShrink(AstNodeBiop* nodep) {
	// Loop unrolling favors standalone compares
	// EQ(const{width32}, EXTEND(xx{width3})) -> EQ(const{3}, xx{3})
	// The constant must have zero bits (+ 1 if signed) or compare
	// would be incorrect. See also operandBiExtendConst
	AstExtend* extendp = nodep->rhsp()->castExtend();
	if (!extendp) return false;
	AstNode* smallerp = extendp->lhsp();
	int subsize = smallerp->width();
	AstConst* constp = nodep->lhsp()->castConst();
	if (!constp) return false;
	if (!constp->num().isBitsZero(constp->width()-1, subsize)) return false;
	//
	if (debug()>=9) nodep->dumpTree(cout,"BI(EXTEND)-in:");
	smallerp->unlinkFrBack();
	extendp->unlinkFrBack()->deleteTree();  // aka nodep->lhsp.
	nodep->rhsp(smallerp);

	constp->unlinkFrBack();
	V3Number num (constp->fileline(), subsize);
	num.opAssign(constp->num());
	nodep->lhsp(new AstConst(constp->fileline(), num));
	constp->deleteTree(); VL_DANGLING(constp);
	if (debug()>=9) nodep->dumpTree(cout,"BI(EXTEND)-ou:");
	return true;
    }
    bool operandBiExtendConstOver(AstNodeBiop* nodep) {
	// EQ(const{width32}, EXTEND(xx{width3})) -> constant
	// When the constant has non-zero bits above the extend it's a constant.
	// Avoids compiler warning
	AstExtend* extendp = nodep->rhsp()->castExtend();
	if (!extendp) return false;
	AstNode* smallerp = extendp->lhsp();
	int subsize = smallerp->width();
	AstConst* constp = nodep->lhsp()->castConst();
	if (!constp) return false;
	if (constp->num().isBitsZero(constp->width()-1, subsize)) return false;
	return true;
    }

    AstNode* afterComment(AstNode* nodep) {
	// Ignore comments, such as to determine if a AstIf is empty.
	// nodep may be null, if so return null.
	while (nodep && nodep->castComment()) { nodep = nodep->nextp(); }
	return nodep;
    }

    bool isTPure(AstNode* nodep) {
	// Pure checks - if this node and all nodes under it are free of
	// side effects can do this optimization
	// Eventually we'll recurse through tree when unknown, memoizing results so far,
	// but for now can disable en-mass until V3Purify takes effect.
	return m_doShort || nodep->castVarRef() || nodep->castConst();
    }

    // Extraction checks
    bool warnSelect(AstSel* nodep) {
	if (m_doGenerate) {
	    // Never checked yet
	    V3Width::widthParamsEdit(nodep);
	    nodep->iterateChildren(*this);	// May need "constifying"
	}
	// Find range of dtype we are selecting from
	// Similar code in V3Unknown::AstSel
	bool doit = true;
	if (m_warn
	    && nodep->lsbp()->castConst()
	    && nodep->widthp()->castConst()
	    && doit) {
	    int maxDeclBit = nodep->declRange().hiMaxSelect()*nodep->declElWidth() + (nodep->declElWidth()-1);
	    if (nodep->lsbp()->castConst()->num().isFourState()
		|| nodep->widthp()->castConst()->num().isFourState()) {
		nodep->v3error("Selection index is constantly unknown or tristated: "
			       "lsb="<<nodep->lsbp()->name()<<" width="<<nodep->widthp()->name());
		// Replacing nodep will make a mess above, so we replace the offender
		replaceZero(nodep->lsbp());
	    }
	    else if (nodep->declRange().ranged()
		     && (nodep->msbConst() > maxDeclBit
			 || nodep->lsbConst() > maxDeclBit)) {
		// See also warning in V3Width
		// Must adjust by element width as declRange() is in number of elements
		nodep->v3warn(SELRANGE, "Selection index out of range: "
			      <<(nodep->msbConst()/nodep->declElWidth())
			      <<":"<<(nodep->lsbConst()/nodep->declElWidth())
			      <<" outside "<<nodep->declRange().hiMaxSelect()<<":0"
			      <<(nodep->declRange().lo()>=0 ? ""
				 :(" (adjusted +"+cvtToStr(-nodep->declRange().lo())
				   +" to account for negative lsb)")));
		UINFO(1,"    Related Raw index is "<<nodep->msbConst()<<":"<<nodep->lsbConst()<<endl);
		// Don't replace with zero, we'll do it later
	    }
	}
	return false;  // Not a transform, so NOP
    }

    static bool operandsSame(AstNode* node1p, AstNode* node2p) {
	// For now we just detect constants & simple vars, though it could be more generic
	if (node1p->castConst() && node2p->castConst()) {
	    return node1p->sameGateTree(node2p);
	}
	else if (node1p->castVarRef() && node2p->castVarRef()) {
	    // Avoid comparing widthMin's, which results in lost optimization attempts
	    // If cleanup sameGateTree to be smarter, this can be restored.
	    //return node1p->sameGateTree(node2p);
	    return node1p->same(node2p);
	} else {
	    return false;
	}
    }
    bool ifSameAssign(AstNodeIf* nodep) {
	AstNodeAssign* ifp = nodep->ifsp()->castNodeAssign();
	AstNodeAssign* elsep = nodep->elsesp()->castNodeAssign();
	if (!ifp   || ifp->nextp()) return false;  // Must be SINGLE statement
	if (!elsep || elsep->nextp()) return false;
	if (ifp->type() != elsep->type()) return false;  // Can't mix an assigndly and an assign
	if (!ifp->lhsp()->sameGateTree(elsep->lhsp())) return false;
	if (!ifp->rhsp()->gateTree()) return false;
	if (!elsep->rhsp()->gateTree()) return false;
	return true;
    }
    bool operandIfIf(AstNodeIf* nodep) {
	if (nodep->elsesp()) return false;
	AstNodeIf* lowerIfp = nodep->ifsp()->castNodeIf();
	if (!lowerIfp || lowerIfp->nextp()) return false;
	if (nodep->type() != lowerIfp->type()) return false;
	if (afterComment(lowerIfp->elsesp())) return false;
	return true;
    }
    bool ifConcatMergeableBiop(AstNode* nodep) {
	return (nodep->castAnd()
		|| nodep->castOr()
		|| nodep->castXor()
		|| nodep->castXnor());
    }
    bool ifAdjacentSel(AstSel* lhsp, AstSel* rhsp) {
	if (!v3Global.opt.oAssemble()) return false; // opt disabled
	if (!lhsp || !rhsp) return false;
	AstNode* lfromp = lhsp->fromp();
	AstNode* rfromp = rhsp->fromp();
	if (!lfromp || !rfromp || !lfromp->sameGateTree(rfromp)) return false;
	AstConst* lstart = lhsp->lsbp()->castConst();
	AstConst* rstart = rhsp->lsbp()->castConst();
	AstConst* lwidth = lhsp->widthp()->castConst();
	AstConst* rwidth = rhsp->widthp()->castConst();
	if (!lstart || !rstart || !lwidth || !rwidth) return false;  // too complicated
	int rend = (rstart->toSInt() + rwidth->toSInt());
	if (rend == lstart->toSInt()) return true;
	return false;
    }
    bool ifMergeAdjacent(AstNode* lhsp, AstNode* rhsp) {
	// called by concatmergeable to determine if {lhsp, rhsp} make sense
	if (!v3Global.opt.oAssemble()) return false; // opt disabled
	// two same varref
	if (operandsSame(lhsp, rhsp)) return true;
	AstSel* lselp = lhsp->castSel();
	AstSel* rselp = rhsp->castSel();
	// a[i:0] a
	if (lselp && !rselp && rhsp->sameGateTree(lselp->fromp()))
	    rselp = new AstSel(rhsp->fileline(), rhsp->cloneTree(false), 0, rhsp->width());
	// a[i:j] {a[j-1:k], b}
	if (lselp && !rselp && rhsp->castConcat())
	    return ifMergeAdjacent(lhsp, rhsp->castConcat()->lhsp());
	// a a[msb:j]
	if (rselp && !lselp && lhsp->sameGateTree(rselp->fromp()))
	    lselp = new AstSel(lhsp->fileline(), lhsp->cloneTree(false), 0, lhsp->width());
	// {b, a[j:k]} a[k-1:i]
	if (rselp && !lselp && lhsp->castConcat())
	    return ifMergeAdjacent(lhsp->castConcat()->rhsp(), rhsp);
	if (!lselp || !rselp) return false;

	// a[a:b] a[b-1:c] are adjacent
	AstNode* lfromp = lselp->fromp();
	AstNode* rfromp = rselp->fromp();
	if (!lfromp || !rfromp || !lfromp->sameGateTree(rfromp)) return false;
	AstConst* lstart = lselp->lsbp()->castConst();
	AstConst* rstart = rselp->lsbp()->castConst();
	AstConst* lwidth = lselp->widthp()->castConst();
	AstConst* rwidth = rselp->widthp()->castConst();
	if (!lstart || !rstart || !lwidth || !rwidth) return false;  // too complicated
	int rend = (rstart->toSInt() + rwidth->toSInt());
	// a[i:j] a[j-1:k]
	if (rend == lstart->toSInt()) return true;
	// a[i:0] a[msb:j]
	if (rend == rfromp->width() && lstart->toSInt() == 0) return true;
	return false;
    }
    bool concatMergeable(AstNode* lhsp, AstNode* rhsp) {
        // determine if {a OP b, c OP d} => {a, c} OP {b, d} is advantagous
	if (!v3Global.opt.oAssemble()) return false; // opt disabled
	if (lhsp->type() != rhsp->type()) return false;
	if (!ifConcatMergeableBiop(lhsp)) return false;

	AstNodeBiop* lp = lhsp->castNodeBiop();
	AstNodeBiop* rp = rhsp->castNodeBiop();
	if (!lp || !rp) return false;
	// {a[]&b[], a[]&b[]}
	bool lad = ifMergeAdjacent(lp->lhsp(), rp->lhsp());
	bool rad = ifMergeAdjacent(lp->rhsp(), rp->rhsp());
	if (lad && rad) return true;
	// {a[] & b[]&c[], a[] & b[]&c[]}
	else if (lad && concatMergeable(lp->rhsp(), rp->rhsp())) return true;
	// {a[]&b[] & c[], a[]&b[] & c[]}
	else if (rad && concatMergeable(lp->lhsp(), rp->lhsp())) return true;
	else {
	    // {(a[]&b[])&(c[]&d[]), (a[]&b[])&(c[]&d[])}
	    if (concatMergeable(lp->lhsp(), rp->lhsp())
		&& concatMergeable(lp->rhsp(), rp->rhsp()))
		return true;
	}
	return false;
    }

    //----------------------------------------
    // Constant Replacement functions.
    // These all take a node, delete its tree, and replaces it with a constant

    void replaceNum (AstNode* oldp, const V3Number& num) {
	// Replace oldp node with a constant set to specified value
	UASSERT (oldp, "Null old\n");
	if (oldp->castConst() && !oldp->castConst()->num().isFourState()) {
	    oldp->v3fatalSrc("Already constant??");
	}
	AstNode* newp = new AstConst(oldp->fileline(), num);
	newp->dtypeFrom(oldp);
	if (debug()>5) oldp->dumpTree(cout,"  const_old: ");
	if (debug()>5) newp->dumpTree(cout,"       _new: ");
	oldp->replaceWith(newp);
	oldp->deleteTree(); VL_DANGLING(oldp);
    }
    void replaceNum (AstNode* nodep, uint32_t val) {
	V3Number num (nodep->fileline(), nodep->width(), val);
	replaceNum(nodep, num); VL_DANGLING(nodep);
    }
    void replaceNumSigned(AstNodeBiop* nodep, uint32_t val) {
	// We allow both sides to be constant, as one may have come from parameter propagation, etc.
	if (m_warn && !(nodep->lhsp()->castConst() && nodep->rhsp()->castConst())) {
	    nodep->v3warn(UNSIGNED,"Comparison is constant due to unsigned arithmetic");
	}
	replaceNum(nodep, val); VL_DANGLING(nodep);
    }
    void replaceNumLimited(AstNodeBiop* nodep, uint32_t val) {
	// Avoids gcc warning about same
	if (m_warn) nodep->v3warn(CMPCONST,"Comparison is constant due to limited range");
	replaceNum(nodep, val); VL_DANGLING(nodep);
    }
    void replaceZero(AstNode* nodep) {
	replaceNum(nodep, 0); VL_DANGLING(nodep);
    }
    void replaceZeroChkPure(AstNode* nodep, AstNode* checkp) {
	// For example, "0 * n" -> 0 if n has no side effects
	// Else strength reduce it to 0 & n.
	// If ever change the operation note AstAnd rule specially ignores this created pattern
	if (isTPure(checkp)) {
	    replaceNum(nodep, 0); VL_DANGLING(nodep);
	} else {
	    AstNode* newp = new AstAnd(nodep->fileline(),
				       new AstConst(nodep->fileline(), 0),
				       checkp->unlinkFrBack());
	    newp->dtypeFrom(nodep);
	    nodep->replaceWith(newp);
	    nodep->deleteTree(); VL_DANGLING(nodep);
	}
    }
    void replaceAllOnes (AstNode* nodep) {
	V3Number ones (nodep->fileline(), nodep->width(), 0);
	ones.setMask(nodep->width());
	replaceNum(nodep, ones); VL_DANGLING(nodep);
    }
    void replaceConst(AstNodeUniop* nodep) {
	V3Number num (nodep->fileline(), nodep->width());
	nodep->numberOperate(num, nodep->lhsp()->castConst()->num());
	UINFO(4,"UNICONST -> "<<num<<endl);
	replaceNum(nodep, num); VL_DANGLING(nodep);
    }
    void replaceConst(AstNodeBiop* nodep) {
	V3Number num (nodep->fileline(), nodep->width());
	nodep->numberOperate(num, nodep->lhsp()->castConst()->num(), nodep->rhsp()->castConst()->num());
	UINFO(4,"BICONST -> "<<num<<endl);
	replaceNum(nodep, num); VL_DANGLING(nodep);
    }
    void replaceConst(AstNodeTriop* nodep) {
	V3Number num (nodep->fileline(), nodep->width());
	nodep->numberOperate(num, nodep->lhsp()->castConst()->num(),
			     nodep->rhsp()->castConst()->num(),
			     nodep->thsp()->castConst()->num());
	UINFO(4,"TRICONST -> "<<num<<endl);
	replaceNum(nodep, num); VL_DANGLING(nodep);
    }

    void replaceConstString (AstNode* oldp, const string& num) {
	// Replace oldp node with a constant set to specified value
	UASSERT (oldp, "Null old\n");
	AstNode* newp = new AstConst(oldp->fileline(), AstConst::String(), num);
	if (debug()>5) oldp->dumpTree(cout,"  const_old: ");
	if (debug()>5) newp->dumpTree(cout,"       _new: ");
	oldp->replaceWith(newp);
	oldp->deleteTree(); VL_DANGLING(oldp);
    }
    //----------------------------------------
    // Replacement functions.
    // These all take a node and replace it with something else

    void replaceWChild(AstNode* nodep, AstNode* childp) {
	// NODE(..., CHILD(...)) -> CHILD(...)
	childp->unlinkFrBackWithNext();
	// If replacing a SEL for example, the data type comes from the parent (is less wide).
	// This may adversly affect the operation of the node being replaced.
	childp->dtypeFrom(nodep);
	nodep->replaceWith(childp);
	nodep->deleteTree(); VL_DANGLING(nodep);
    }

    //! Replace a ternary node with its RHS after iterating
    //! Used with short-circuting, where the RHS has not yet been iterated.
    void replaceWIteratedRhs(AstNodeTriop* nodep) {
	if (AstNode *rhsp = nodep->rhsp()) rhsp->iterateAndNext(*this);
	replaceWChild(nodep, nodep->rhsp());	// May have changed
    }

    //! Replace a ternary node with its THS after iterating
    //! Used with short-circuting, where the THS has not yet been iterated.
    void replaceWIteratedThs(AstNodeTriop* nodep) {
	if (AstNode *thsp = nodep->thsp()) thsp->iterateAndNext(*this);
	replaceWChild(nodep, nodep->thsp());	// May have changed
    }
    void replaceWLhs(AstNodeUniop* nodep) {
	// Keep LHS, remove RHS
	replaceWChild(nodep, nodep->lhsp());
    }
    void replaceWLhs(AstNodeBiop* nodep) {
	// Keep LHS, remove RHS
	replaceWChild(nodep, nodep->lhsp());
    }
    void replaceWRhs(AstNodeBiop* nodep) {
	// Keep RHS, remove LHS
	replaceWChild(nodep, nodep->rhsp());
    }
    void replaceAsv (AstNodeBiop* nodep) {
	// BIASV(CONSTa, BIASV(CONSTb, c)) -> BIASV( BIASV_CONSTED(a,b), c)
	// BIASV(SAMEa,  BIASV(SAMEb, c))  -> BIASV( BIASV(SAMEa,SAMEb), c)
	//nodep->dumpTree(cout, "  repAsvConst_old: ");
	AstNode* ap = nodep->lhsp();
	AstNodeBiop* rp = nodep->rhsp()->castNodeBiop();
	AstNode* bp = rp->lhsp();
	AstNode* cp = rp->rhsp();
	ap->unlinkFrBack();
	bp->unlinkFrBack();
	cp->unlinkFrBack();
	rp->unlinkFrBack();
	nodep->lhsp(rp);
	nodep->rhsp(cp);
	rp->lhsp(ap);
	rp->rhsp(bp);
	if (rp->lhsp()->castConst() && rp->rhsp()->castConst()) replaceConst(rp);
	//nodep->dumpTree(cout, "  repAsvConst_new: ");
    }
    void replaceAsvLUp (AstNodeBiop* nodep) {
	// BIASV(BIASV(CONSTll,lr),r) -> BIASV(CONSTll,BIASV(lr,r))
	AstNodeBiop* lp = nodep->lhsp()->unlinkFrBack()->castNodeBiop();
	AstNode* llp = lp->lhsp()->unlinkFrBack();
	AstNode* lrp = lp->rhsp()->unlinkFrBack();
	AstNode* rp  = nodep->rhsp()->unlinkFrBack();
	nodep->lhsp(llp);
	nodep->rhsp(lp);
	lp->lhsp(lrp);
	lp->rhsp(rp);
	//nodep->dumpTree(cout, "  repAsvLUp_new: ");
    }
    void replaceAsvRUp (AstNodeBiop* nodep) {
	// BIASV(l,BIASV(CONSTrl,rr)) -> BIASV(CONSTrl,BIASV(l,rr))
	AstNode* lp  = nodep->lhsp()->unlinkFrBack();
	AstNodeBiop* rp = nodep->rhsp()->unlinkFrBack()->castNodeBiop();
	AstNode* rlp = rp->lhsp()->unlinkFrBack();
	AstNode* rrp = rp->rhsp()->unlinkFrBack();
	nodep->lhsp(rlp);
	nodep->rhsp(rp);
	rp->lhsp(lp);
	rp->rhsp(rrp);
	//nodep->dumpTree(cout, "  repAsvRUp_new: ");
    }
    void replaceAndOr (AstNodeBiop* nodep) {
	//  OR  (AND (CONSTll,lr), AND(CONSTrl==ll,rr))    -> AND (CONSTll, OR(lr,rr))
	//  OR  (AND (CONSTll,lr), AND(CONSTrl,    rr=lr)) -> AND (OR(ll,rl), rr)
	// nodep ^lp  ^llp   ^lrp  ^rp  ^rlp       ^rrp
	// (Or/And may also be reversed)
	AstNodeBiop* lp = nodep->lhsp()->unlinkFrBack()->castNodeBiop();
	AstNode* llp = lp->lhsp()->unlinkFrBack();
	AstNode* lrp = lp->rhsp()->unlinkFrBack();
	AstNodeBiop* rp = nodep->rhsp()->unlinkFrBack()->castNodeBiop();
	AstNode* rlp = rp->lhsp()->unlinkFrBack();
	AstNode* rrp = rp->rhsp()->unlinkFrBack();
	nodep->replaceWith(lp);
	if (operandsSame(llp,rlp)) {
	    lp->lhsp(llp);
	    lp->rhsp(nodep);
	    nodep->lhsp(lrp);
	    nodep->rhsp(rrp);
	    rp->deleteTree();
	    rlp->deleteTree();
	} else if (operandsSame(lrp, rrp)) {
	    lp->lhsp(nodep);
	    lp->rhsp(rrp);
	    nodep->lhsp(llp);
	    nodep->rhsp(rlp);
	    rp->deleteTree();
	    lrp->deleteTree();
	} else {
	    nodep->v3fatalSrc("replaceAndOr on something operandAndOrSame shouldn't have matched");
	}
	//nodep->dumpTree(cout, "  repAndOr_new: ");
    }
    void replaceShiftSame (AstNodeBiop* nodep) {
	// Or(Shift(ll,CONSTlr),Shift(rl,CONSTrr==lr)) -> Shift(Or(ll,rl),CONSTlr)
	// (Or/And may also be reversed)
	AstNodeBiop* lp = nodep->lhsp()->unlinkFrBack()->castNodeBiop();
	AstNode* llp = lp->lhsp()->unlinkFrBack();
	AstNode* lrp = lp->rhsp()->unlinkFrBack();
	AstNodeBiop* rp = nodep->rhsp()->unlinkFrBack()->castNodeBiop();
	AstNode* rlp = rp->lhsp()->unlinkFrBack();
	AstNode* rrp = rp->rhsp()->unlinkFrBack();
	nodep->replaceWith(lp);
	lp->lhsp(nodep);
	lp->rhsp(lrp);
	nodep->lhsp(llp);
	nodep->rhsp(rlp);
	rp->deleteTree();
	rrp->deleteTree();
	//nodep->dumpTree(cout, "  repShiftSame_new: ");
    }
    void replaceConcatSel(AstConcat* nodep) {
	// {a[1], a[0]} -> a[1:0]
	AstSel* lselp = nodep->lhsp()->unlinkFrBack()->castSel();
	AstSel* rselp = nodep->rhsp()->unlinkFrBack()->castSel();
	int lstart = lselp->lsbConst();
	int lwidth = lselp->widthConst();
	int rstart = rselp->lsbConst();
	int rwidth = rselp->widthConst();

	if ((rstart + rwidth) != lstart) nodep->v3fatalSrc("tried to merge two selects which are not adjacent");
	AstSel* newselp = new AstSel(lselp->fromp()->fileline(), rselp->fromp()->cloneTree(false), rstart, lwidth+rwidth);
	UINFO(5, "merged two adjacent sel "<<lselp <<" and "<<rselp<< " to one "<<newselp<<endl);

	nodep->replaceWith(newselp);
	lselp->deleteTree(); VL_DANGLING(lselp);
	rselp->deleteTree(); VL_DANGLING(rselp);
	nodep->deleteTree(); VL_DANGLING(nodep);
    }
    void replaceConcatMerge(AstConcat* nodep) {
	AstNodeBiop* lp = nodep->lhsp()->castNodeBiop();
	AstNodeBiop* rp = nodep->rhsp()->castNodeBiop();
	AstNode* llp = lp->lhsp()->cloneTree(false);
	AstNode* lrp = lp->rhsp()->cloneTree(false);
	AstNode* rlp = rp->lhsp()->cloneTree(false);
	AstNode* rrp = rp->rhsp()->cloneTree(false);
	if (concatMergeable(lp, rp)) {
	    AstConcat* newlp = new AstConcat(rlp->fileline(), llp, rlp);
	    AstConcat* newrp = new AstConcat(rrp->fileline(), lrp, rrp);
	    // use the lhs to replace the parent concat
	    lp->lhsp()->replaceWith(newlp);
	    lp->rhsp()->replaceWith(newrp);
	    lp->dtypeChgWidthSigned(newlp->width(), newlp->width(), AstNumeric::fromBool(true));
	    UINFO(5, "merged "<< nodep <<endl);
	    rp->unlinkFrBack()->deleteTree(); VL_DANGLING(rp);
	    nodep->replaceWith(lp->unlinkFrBack()); nodep->deleteTree(); VL_DANGLING(nodep);
	    lp->lhsp()->accept(*this);
	    lp->rhsp()->accept(*this);
	} else nodep->v3fatalSrc("tried to merge two Concat which are not adjacent");
    }
    void replaceExtend (AstNode* nodep, AstNode* arg0p) {
	// -> EXTEND(nodep)
	// like a AstExtend{$rhsp}, but we need to set the width correctly from base node
	arg0p->unlinkFrBack();
	AstNode* newp = (nodep->castExtendS()
			 ? static_cast<AstNode*>(new AstExtendS(nodep->fileline(), arg0p))
			 : static_cast<AstNode*>(new AstExtend (nodep->fileline(), arg0p)));
	newp->dtypeFrom(nodep);
	nodep->replaceWith(newp); nodep->deleteTree(); VL_DANGLING(nodep);
    }
    void replacePowShift (AstNodeBiop* nodep) {  // Pow or PowS
	UINFO(5,"POW(2,b)->SHIFTL(1,b) "<<nodep<<endl);
	AstNode* rhsp = nodep->rhsp()->unlinkFrBack();
	AstShiftL* newp = new AstShiftL(nodep->fileline(),
					new AstConst(nodep->fileline(), 1),
					rhsp);
	newp->dtypeFrom(nodep);
	newp->lhsp()->dtypeFrom(nodep);
	nodep->replaceWith(newp); nodep->deleteTree(); VL_DANGLING(nodep);
    }
    void replaceMulShift (AstMul* nodep) {  // Mul, but not MulS as not simple shift
	UINFO(5,"MUL(2^n,b)->SHIFTL(b,n) "<<nodep<<endl);
	int amount = nodep->lhsp()->castConst()->num().mostSetBitP1()-1;  // 2^n->n+1
	AstNode* opp = nodep->rhsp()->unlinkFrBack();
	AstShiftL* newp = new AstShiftL(nodep->fileline(),
					opp, new AstConst(nodep->fileline(), amount));
	newp->dtypeFrom(nodep);
	nodep->replaceWith(newp); nodep->deleteTree(); VL_DANGLING(nodep);
    }
    void replaceDivShift (AstDiv* nodep) {  // Mul, but not MulS as not simple shift
	UINFO(5,"DIV(b,2^n)->SHIFTR(b,n) "<<nodep<<endl);
	int amount = nodep->rhsp()->castConst()->num().mostSetBitP1()-1;  // 2^n->n+1
	AstNode* opp = nodep->lhsp()->unlinkFrBack();
	AstShiftR* newp = new AstShiftR(nodep->fileline(),
					opp, new AstConst(nodep->fileline(), amount));
	newp->dtypeFrom(nodep);
	nodep->replaceWith(newp); nodep->deleteTree(); VL_DANGLING(nodep);
    }
    void replaceShiftOp (AstNodeBiop* nodep) {
	UINFO(5,"SHIFT(AND(a,b),CONST)->AND(SHIFT(a,CONST),SHIFT(b,CONST)) "<<nodep<<endl);
	AstNRelinker handle;
	nodep->unlinkFrBack(&handle);
	AstNodeBiop* lhsp = nodep->lhsp()->castNodeBiop(); lhsp->unlinkFrBack();
	AstNode* shiftp = nodep->rhsp()->unlinkFrBack();
	AstNode* ap = lhsp->lhsp()->unlinkFrBack();
	AstNode* bp = lhsp->rhsp()->unlinkFrBack();
	AstNodeBiop* shift1p = nodep;
	AstNodeBiop* shift2p = nodep->cloneTree(true);
	shift1p->lhsp(ap); shift1p->rhsp(shiftp->cloneTree(true));
	shift2p->lhsp(bp); shift2p->rhsp(shiftp);
	AstNodeBiop* newp = lhsp;
	newp->lhsp(shift1p); newp->rhsp(shift2p);
	handle.relink(newp);
	newp->accept(*this);	// Further reduce, either node may have more reductions.
    }
    void replaceShiftShift (AstNodeBiop* nodep) {
	UINFO(4,"SHIFT(SHIFT(a,s1),s2)->SHIFT(a,ADD(s1,s2)) "<<nodep<<endl);
	if (debug()>=9) nodep->dumpTree(cout, "  repShiftShift_old: ");
	AstNodeBiop* lhsp = nodep->lhsp()->castNodeBiop(); lhsp->unlinkFrBack();
	AstNode* ap = lhsp->lhsp()->unlinkFrBack();
	AstNode* shift1p = lhsp->rhsp()->unlinkFrBack();
	AstNode* shift2p = nodep->rhsp()->unlinkFrBack();
	// Shift1p and shift2p may have different sizes, both are self-determined so sum with infinite width
	if (nodep->type()==lhsp->type()) {
	    int shift1 = shift1p->castConst()->toUInt();
	    int shift2 = shift2p->castConst()->toUInt();
	    int newshift = shift1+shift2;
	    shift1p->deleteTree(); VL_DANGLING(shift1p);
	    shift2p->deleteTree(); VL_DANGLING(shift2p);
	    nodep->lhsp(ap);
	    nodep->rhsp(new AstConst(nodep->fileline(), newshift));
	    nodep->accept(*this);	// Further reduce, either node may have more reductions.
	} else {
	    // We know shift amounts are constant, but might be a mixed left/right shift
	    int shift1 = shift1p->castConst()->toUInt(); if (lhsp->castShiftR())  shift1=-shift1;
	    int shift2 = shift2p->castConst()->toUInt(); if (nodep->castShiftR()) shift2=-shift2;
	    int newshift = shift1+shift2;
	    shift1p->deleteTree(); VL_DANGLING(shift1p);
	    shift2p->deleteTree(); VL_DANGLING(shift2p);
	    AstNode* newp;
	    V3Number mask1 (nodep->fileline(), nodep->width());
	    V3Number ones (nodep->fileline(), nodep->width());
	    ones.setMask(nodep->width());
	    if (shift1<0) {
		mask1.opShiftR(ones,V3Number(nodep->fileline(),VL_WORDSIZE,-shift1));
	    } else {
		mask1.opShiftL(ones,V3Number(nodep->fileline(),VL_WORDSIZE,shift1));
	    }
	    V3Number mask (nodep->fileline(), nodep->width());
	    if (shift2<0) {
		mask.opShiftR(mask1,V3Number(nodep->fileline(),VL_WORDSIZE,-shift2));
	    } else {
		mask.opShiftL(mask1,V3Number(nodep->fileline(),VL_WORDSIZE,shift2));
	    }
	    if (newshift<0) {
		newp = new AstShiftR(nodep->fileline(), ap,
				     new AstConst(nodep->fileline(), -newshift));
	    } else {
		newp = new AstShiftL(nodep->fileline(), ap,
				     new AstConst(nodep->fileline(), newshift));
	    }
	    newp->dtypeFrom(nodep);
	    newp = new AstAnd (nodep->fileline(),
			       newp,
			       new AstConst (nodep->fileline(), mask));
	    newp->dtypeFrom(nodep);
	    nodep->replaceWith(newp); nodep->deleteTree(); VL_DANGLING(nodep);
	    //newp->dumpTree(cout, "  repShiftShift_new: ");
	    newp->accept(*this);	// Further reduce, either node may have more reductions.
	}
	lhsp->deleteTree(); VL_DANGLING(lhsp);
    }

    bool replaceAssignMultiSel(AstNodeAssign* nodep) {
	// Multiple assignments to sequential bits can be concated
	// ASSIGN(SEL(a),aq), ASSIGN(SEL(a+1),bq) -> ASSIGN(SEL(a:b),CONCAT(aq,bq)
	// ie. assign var[2]=a, assign var[3]=b -> assign var[3:2]={b,a}
	if (!m_modp) return false;   // Skip if we're not const'ing an entire module (IE doing only one assign, etc)
	AstSel* sel1p = nodep->lhsp()->castSel(); if (!sel1p) return false;
	AstNodeAssign* nextp = nodep->nextp()->castNodeAssign(); if (!nextp) return false;
	if (nodep->type() != nextp->type()) return false;
	AstSel* sel2p = nextp->lhsp()->castSel(); if (!sel2p) return false;
	AstVarRef* varref1p = sel1p->fromp()->castVarRef(); if (!varref1p) return false;
	AstVarRef* varref2p = sel2p->fromp()->castVarRef(); if (!varref2p) return false;
	if (!varref1p->sameGateTree(varref2p)) return false;
	AstConst* con1p = sel1p->lsbp()->castConst(); if (!con1p) return false;
	AstConst* con2p = sel2p->lsbp()->castConst(); if (!con2p) return false;
	// We need to make sure there's no self-references involved in either
	// assignment.  For speed, we only look 3 deep, then give up.
	if (!varNotReferenced(nodep->rhsp(), varref1p->varp())) return false;
	if (!varNotReferenced(nextp->rhsp(), varref2p->varp())) return false;
	// Swap?
	if ((  con1p->toSInt() != con2p->toSInt() + sel2p->width())
	    &&(con2p->toSInt() != con1p->toSInt() + sel1p->width())) return false;
	bool lsbFirstAssign = (con1p->toUInt() < con2p->toUInt());
	// If the user already has nice 32-bit divisions, keep them to aid later subdivision
	//if (VL_BITBIT_I(con1p->toUInt()) == 0) return false;
	UINFO(4,"replaceAssignMultiSel "<<nodep<<endl);
	UINFO(4,"                   && "<<nextp<<endl);
	//nodep->dumpTree(cout, "comb1: ");
	//nextp->dumpTree(cout, "comb2: ");
	AstNode* rhs1p = nodep->rhsp()->unlinkFrBack();
	AstNode* rhs2p = nextp->rhsp()->unlinkFrBack();
	AstNode* newp;
	if (lsbFirstAssign) {
	    newp = nodep->cloneType (new AstSel(sel1p->fileline(), varref1p->unlinkFrBack(),
						sel1p->lsbConst(), sel1p->width() + sel2p->width()),
				     new AstConcat(rhs1p->fileline(), rhs2p, rhs1p));
	} else {
	    newp = nodep->cloneType (new AstSel(sel1p->fileline(), varref1p->unlinkFrBack(),
						sel2p->lsbConst(), sel1p->width() + sel2p->width()),
				     new AstConcat(rhs1p->fileline(), rhs1p, rhs2p));
	}
	//pnewp->dumpTree(cout, "conew: ");
	nodep->replaceWith(newp); nodep->deleteTree();
	nextp->unlinkFrBack()->deleteTree();
	return true;
    }

    bool varNotReferenced(AstNode* nodep, AstVar* varp, int level=0) {
	// Return true if varp never referenced under node.
	// Return false if referenced, or tree too deep to be worth it, or side effects
	if (!nodep) return true;
	if (level>2) return false;
	if (nodep->isPure()) return false;  // For example a $fgetc can't be reordered
	if (nodep->castNodeVarRef() && nodep->castNodeVarRef()->varp()==varp) return false;
	return (varNotReferenced  (nodep->nextp(),varp,level+1)
		&& varNotReferenced(nodep->op1p(),varp,level+1)
		&& varNotReferenced(nodep->op2p(),varp,level+1)
		&& varNotReferenced(nodep->op3p(),varp,level+1)
		&& varNotReferenced(nodep->op4p(),varp,level+1));
    }

    bool replaceNodeAssign(AstNodeAssign* nodep) {
	if (nodep->lhsp()->castVarRef()
	    && nodep->rhsp()->castVarRef()
	    && nodep->lhsp()->castVarRef()->sameNoLvalue(nodep->rhsp()->castVarRef())
	    && !nodep->castAssignDly()) {
	    // X = X.  Quite pointless, though X <= X may override another earlier assignment
	    if (nodep->castAssignW()) {
		nodep->v3error("Wire inputs its own output, creating circular logic (wire x=x)");
		return false;  // Don't delete the assign, or V3Gate will freak out
	    } else {
		nodep->unlinkFrBack()->deleteTree(); VL_DANGLING(nodep);
		return true;
	    }
	}
	else if (m_doV && nodep->lhsp()->castConcat()) {
	    bool need_temp = false;
	    if (m_warn && !nodep->castAssignDly()) {  // Is same var on LHS and RHS?
		// Note only do this (need user4) when m_warn, which is
		// done as unique visitor
		AstUser4InUse	m_inuser4;
		ConstVarMarkVisitor mark(nodep->lhsp());
		ConstVarFindVisitor find(nodep->rhsp());
		if (find.found()) need_temp = true;
	    }
	    if (need_temp) {
		// The first time we constify, there may be the same variable on the LHS
		// and RHS.  In that case, we must use temporaries, or {a,b}={b,a} will break.
		UINFO(4,"  ASSITEMP "<<nodep<<endl);
		// ASSIGN(CONCAT(lc1,lc2),rhs) -> ASSIGN(temp1,SEL(rhs,{size})),
		//				  ASSIGN(temp2,SEL(newrhs,{size}))
		//                                ASSIGN(lc1,temp1),
		//				  ASSIGN(lc2,temp2)
	    } else {
		UINFO(4,"  ASSI "<<nodep<<endl);
		// ASSIGN(CONCAT(lc1,lc2),rhs) -> ASSIGN(lc1,SEL(rhs,{size})),
		//				  ASSIGN(lc2,SEL(newrhs,{size}))
	    }
	    if (debug()>=9) nodep->dumpTree(cout,"  Ass_old: ");
	    // Unlink the stuff
	    AstNode* lc1p = nodep->lhsp()->castConcat()->lhsp()->unlinkFrBack();
	    AstNode* lc2p = nodep->lhsp()->castConcat()->rhsp()->unlinkFrBack();
	    AstNode* conp = nodep->lhsp()->castConcat()->unlinkFrBack();
	    AstNode* rhsp = nodep->rhsp()->unlinkFrBack();
	    AstNode*   rhs2p   = rhsp->cloneTree(false);
	    // Calc widths
	    int lsb2 = 0;
	    int msb2 = lsb2+lc2p->width()-1;
	    int lsb1 = msb2+1;
	    int msb1 = lsb1+lc1p->width()-1;
	    if (msb1!=(conp->width()-1)) nodep->v3fatalSrc("Width calc mismatch");
	    // Form ranges
	    AstSel*  sel1p = new AstSel(conp->fileline(), rhsp,  lsb1, msb1-lsb1+1);
	    AstSel*  sel2p = new AstSel(conp->fileline(), rhs2p, lsb2, msb2-lsb2+1);
	    // Make new assigns of same flavor as old one
	    //*** Not cloneTree; just one node.
	    AstNode* newp = NULL;
	    if (!need_temp) {
		AstNodeAssign* asn1ap=nodep->cloneType(lc1p, sel1p)->castNodeAssign();
		AstNodeAssign* asn2ap=nodep->cloneType(lc2p, sel2p)->castNodeAssign();
		asn1ap->dtypeFrom(sel1p);
		asn2ap->dtypeFrom(sel2p);
		newp = AstNode::addNext(newp, asn1ap);
		newp = AstNode::addNext(newp, asn2ap);
	    } else {
		if (!m_modp) nodep->v3fatalSrc("Not under module");
		// We could create just one temp variable, but we'll get better optimization
		// if we make one per term.
		string name1 = ((string)"__Vconcswap"+cvtToStr(m_modp->varNumGetInc()));
		string name2 = ((string)"__Vconcswap"+cvtToStr(m_modp->varNumGetInc()));
		AstVar* temp1p = new AstVar(sel1p->fileline(), AstVarType::BLOCKTEMP, name1,
					    VFlagLogicPacked(), msb1-lsb1+1);
		AstVar* temp2p = new AstVar(sel2p->fileline(), AstVarType::BLOCKTEMP, name2,
					    VFlagLogicPacked(), msb2-lsb2+1);
		m_modp->addStmtp(temp1p);
		m_modp->addStmtp(temp2p);
		AstNodeAssign* asn1ap=nodep->cloneType
		    (new AstVarRef(sel1p->fileline(), temp1p, true),
		     sel1p)->castNodeAssign();
		AstNodeAssign* asn2ap=nodep->cloneType
		    (new AstVarRef(sel2p->fileline(), temp2p, true),
		     sel2p)->castNodeAssign();
		AstNodeAssign* asn1bp=nodep->cloneType
		    (lc1p, new AstVarRef(sel1p->fileline(), temp1p, false))
		    ->castNodeAssign();
		AstNodeAssign* asn2bp=nodep->cloneType
		    (lc2p, new AstVarRef(sel2p->fileline(), temp2p, false))
		    ->castNodeAssign();
		asn1ap->dtypeFrom(temp1p);
		asn1bp->dtypeFrom(temp1p);
		asn2ap->dtypeFrom(temp2p);
		asn2bp->dtypeFrom(temp2p);
		// This order matters
		newp = AstNode::addNext(newp, asn1ap);
		newp = AstNode::addNext(newp, asn2ap);
		newp = AstNode::addNext(newp, asn1bp);
		newp = AstNode::addNext(newp, asn2bp);
	    }
	    if (debug()>=9 && newp) newp->dumpTreeAndNext(cout,"     _new: ");
	    nodep->addNextHere(newp);
	    // Cleanup
	    nodep->unlinkFrBack()->deleteTree(); VL_DANGLING(nodep);
	    conp->deleteTree(); VL_DANGLING(conp);
	    // Further reduce, either node may have more reductions.
	    return true;
	}
	else if (m_doV && nodep->rhsp()->castStreamR()) {
	    // The right-streaming operator on rhs of assignment does not
	    // change the order of bits. Eliminate stream but keep its lhsp
	    // Unlink the stuff
	    AstNode* srcp    = nodep->rhsp()->castStreamR()->lhsp()->unlinkFrBack();
	    AstNode* sizep   = nodep->rhsp()->castStreamR()->rhsp()->unlinkFrBack();
	    AstNode* streamp = nodep->rhsp()->castStreamR()->unlinkFrBack();
	    nodep->rhsp(srcp);
	    // Cleanup
	    sizep->deleteTree(); VL_DANGLING(sizep);
	    streamp->deleteTree(); VL_DANGLING(streamp);
	    // Further reduce, any of the nodes may have more reductions.
	    return true;
	}
	else if (m_doV && nodep->lhsp()->castStreamL()) {
	    // Push the stream operator to the rhs of the assignment statement
	    int dWidth = nodep->lhsp()->castStreamL()->lhsp()->width();
	    int sWidth = nodep->rhsp()->width();
	    // Unlink the stuff
	    AstNode* dstp    = nodep->lhsp()->castStreamL()->lhsp()->unlinkFrBack();
	    AstNode* streamp = nodep->lhsp()->castStreamL()->unlinkFrBack();
	    AstNode* srcp    = nodep->rhsp()->unlinkFrBack();
	    // Connect the rhs to the stream operator and update its width
	    streamp->castStreamL()->lhsp(srcp);
	    streamp->dtypeSetLogicSized((srcp->width()),
					(srcp->widthMin()),
					AstNumeric::UNSIGNED);
	    // Shrink the RHS if necessary
	    if (sWidth > dWidth) {
		streamp = new AstSel(streamp->fileline(), streamp, sWidth-dWidth, dWidth);
	    }
	    // Link the nodes back in
	    nodep->lhsp(dstp);
	    nodep->rhsp(streamp);
	    return true;
	}
	else if (m_doV && nodep->lhsp()->castStreamR()) {
	    // The right stream operator on lhs of assignment statement does
	    // not reorder bits. However, if the rhs is wider than the lhs,
	    // then we select bits from the left-most, not the right-most.
	    int dWidth = nodep->lhsp()->castStreamR()->lhsp()->width();
	    int sWidth = nodep->rhsp()->width();
	    // Unlink the stuff
	    AstNode* dstp    = nodep->lhsp()->castStreamR()->lhsp()->unlinkFrBack();
	    AstNode* sizep   = nodep->lhsp()->castStreamR()->rhsp()->unlinkFrBack();
	    AstNode* streamp = nodep->lhsp()->castStreamR()->unlinkFrBack();
	    AstNode* srcp    = nodep->rhsp()->unlinkFrBack();
	    if (sWidth > dWidth) {
		srcp = new AstSel(streamp->fileline(), srcp,  sWidth-dWidth, dWidth);
	    }
	    nodep->lhsp(dstp);
	    nodep->rhsp(srcp);
	    // Cleanup
	    sizep->deleteTree(); VL_DANGLING(sizep);
	    streamp->deleteTree(); VL_DANGLING(streamp);
	    // Further reduce, any of the nodes may have more reductions.
	    return true;
	}
	else if (replaceAssignMultiSel(nodep)) {
	    return true;
	}
	return false;
    }

    // Boolean replacements
    bool operandBoolShift(AstNode* nodep) {
	// boolean test of AND(const,SHIFTR(x,const)) -> test of AND(SHIFTL(x,const), x)
	if (!nodep->castAnd()) return false;
	if (!nodep->castAnd()->lhsp()->castConst()) return false;
	if (!nodep->castAnd()->rhsp()->castShiftR()) return false;
	AstShiftR* shiftp = nodep->castAnd()->rhsp()->castShiftR();
	if (!shiftp->rhsp()->castConst()) return false;
	if ((uint32_t)(nodep->width()) <= shiftp->rhsp()->castConst()->toUInt()) return false;
	return true;
    }
    void replaceBoolShift(AstNode* nodep) {
	if (debug()>=9) nodep->dumpTree(cout,"  bshft_old: ");
	AstConst* andConstp = nodep->castAnd()->lhsp()->castConst();
	AstNode* fromp = nodep->castAnd()->rhsp()->castShiftR()->lhsp()->unlinkFrBack();
	AstConst* shiftConstp = nodep->castAnd()->rhsp()->castShiftR()->rhsp()->castConst();
	V3Number val (andConstp->fileline(), andConstp->width());
	val.opShiftL(andConstp->num(), shiftConstp->num());
	AstAnd* newp = new AstAnd(nodep->fileline(),
				  new AstConst(nodep->fileline(), val),
				  fromp);
	newp->dtypeSetLogicSized(nodep->width(), nodep->width(), AstNumeric::UNSIGNED);  // widthMin no longer applicable if different C-expanded width
	nodep->replaceWith(newp);
	nodep->deleteTree(); VL_DANGLING(nodep);
	if (debug()>=9) newp->dumpTree(cout,"       _new: ");
    }

    void replaceWithSimulation(AstNode* nodep) {
	SimulateVisitor simvis;
	// Run it - may be unoptimizable due to large for loop, etc
	simvis.mainParamEmulate(nodep);
	if (!simvis.optimizable()) {
	    AstNode* errorp = simvis.whyNotNodep(); if (!errorp) errorp = nodep;
	    nodep->v3error("Expecting expression to be constant, but can't determine constant for "
			   <<nodep->prettyTypeName()<<endl
			   <<errorp->warnMore()<<"... Location of non-constant "
			   <<errorp->prettyTypeName()<<": "<<simvis.whyNotMessage());
	    replaceZero(nodep); VL_DANGLING(nodep);
	} else {
	    // Fetch the result
	    V3Number* outnump = simvis.fetchNumberNull(nodep);
	    if (!outnump) nodep->v3fatalSrc("No number returned from simulation");
	    // Replace it
	    replaceNum(nodep,*outnump); VL_DANGLING(nodep);
	}
    }

    //----------------------------------------

    // VISITORS
    virtual void visit(AstNetlist* nodep) {
	// Iterate modules backwards, in bottom-up order.  That's faster
	nodep->iterateChildrenBackwards(*this);
    }
    virtual void visit(AstNodeModule* nodep) {
	m_modp = nodep;
	nodep->iterateChildren(*this);
	m_modp = NULL;
    }
    virtual void visit(AstCFunc* nodep) {
	// No ASSIGNW removals under funcs, we've long eliminated INITIALs
	// (We should perhaps rename the assignw's to just assigns)
	m_wremove = false;
	nodep->iterateChildren(*this);
	m_wremove = true;
    }
    virtual void visit(AstScope* nodep) {
	// No ASSIGNW removals under scope, we've long eliminated INITIALs
	m_scopep = nodep;
	m_wremove = false;
	nodep->iterateChildren(*this);
	m_wremove = true;
	m_scopep = NULL;
    }

    void swapSides(AstNodeBiCom* nodep) {
	// COMMUNATIVE({a},CONST) -> COMMUNATIVE(CONST,{a})
	// This simplifies later optimizations
	AstNode* lhsp = nodep->lhsp()->unlinkFrBackWithNext();
	AstNode* rhsp = nodep->rhsp()->unlinkFrBackWithNext();
	nodep->lhsp(rhsp);
	nodep->rhsp(lhsp);
	nodep->accept(*this);  // Again?
    }

    int operandConcatMove(AstConcat* nodep) {
	//    CONCAT under concat  (See moveConcat)
	// Return value: true indicates to do it; 2 means move to LHS
	AstConcat* abConcp = nodep->lhsp()->castConcat();
	AstConcat* bcConcp = nodep->rhsp()->castConcat();
	if (!abConcp && !bcConcp) return 0;
	if (bcConcp) {
	    AstNode* ap = nodep->lhsp();
	    AstNode* bp = bcConcp->lhsp();
	    // If a+b == 32,64,96 etc, then we want to have a+b together on LHS
	    if (VL_BITBIT_I(ap->width()+bp->width())==0) return 2;  // Transform 2: to abConc
	}
	else { //abConcp
	    // Unless lhs is already 32 bits due to above, reorder it
	    if (VL_BITBIT_I(nodep->lhsp()->width())!=0) return 1;  // Transform 1: to bcConc
	}
	return 0;  // ok
    }
    void moveConcat(AstConcat* nodep) {
	//    1: CONCAT(CONCAT({a},{b}),{c})  -> CONCAT({a},CONCAT({b}, {c}))
	// or 2: CONCAT({a}, CONCAT({b},{c})) -> CONCAT(CONCAT({a},{b}),{c})
	// Because the lhs of a concat needs a shift but the rhs doesn't,
	// putting additional CONCATs on the RHS leads to fewer assembler operations.
	// However, we'll end up with lots of wide moves if we make huge trees
	// like that, so on 32 bit boundaries, we'll do the opposite form.
	UINFO(4,"Move concat: "<<nodep<<endl);
	if (operandConcatMove(nodep)>1) {
	    AstNode* ap = nodep->lhsp()->unlinkFrBack();
	    AstConcat* bcConcp = nodep->rhsp()->castConcat(); bcConcp->unlinkFrBack();
	    AstNode* bp = bcConcp->lhsp()->unlinkFrBack();
	    AstNode* cp = bcConcp->rhsp()->unlinkFrBack();
	    AstConcat* abConcp = new AstConcat(bcConcp->fileline(),
					       ap, bp);
	    nodep->lhsp(abConcp);
	    nodep->rhsp(cp);
	    // If bp was a concat, then we have this exact same form again!
	    // Recurse rather then calling node->iterate to prevent 2^n recursion!
	    if (operandConcatMove(abConcp)) moveConcat(abConcp);
	    bcConcp->deleteTree(); VL_DANGLING(bcConcp);
	} else {
	    AstConcat* abConcp = nodep->lhsp()->castConcat(); abConcp->unlinkFrBack();
	    AstNode* ap = abConcp->lhsp()->unlinkFrBack();
	    AstNode* bp = abConcp->rhsp()->unlinkFrBack();
	    AstNode* cp = nodep->rhsp()->unlinkFrBack();
	    AstConcat* bcConcp = new AstConcat(abConcp->fileline(),
					       bp, cp);
	    nodep->lhsp(ap);
	    nodep->rhsp(bcConcp);
	    if (operandConcatMove(bcConcp)) moveConcat(bcConcp);
	    abConcp->deleteTree(); VL_DANGLING(abConcp);
	}
    }

    // Special cases
    virtual void visit(AstConst* nodep) {}	// Already constant

    virtual void visit(AstCell* nodep) {
	if (m_params) {
	    nodep->paramsp()->iterateAndNext(*this);
	} else {
	    nodep->iterateChildren(*this);
	}
    }
    virtual void visit(AstPin* nodep) {
	nodep->iterateChildren(*this);
    }

    void replaceSelSel(AstSel* nodep) {
	// SEL(SEL({x},a,b),c,d) => SEL({x},a+c,d)
	AstSel* belowp = nodep->fromp()->castSel();
	AstNode* fromp = belowp->fromp()->unlinkFrBack();
	AstNode* widthp = nodep->widthp()->unlinkFrBack();
	AstNode* lsb1p = nodep->lsbp()->unlinkFrBack();
	AstNode* lsb2p = belowp->lsbp()->unlinkFrBack();
	// Eliminate lower range
	UINFO(4,"Elim Lower range: "<<nodep<<endl);
	AstNode* newlsbp;
	if (lsb1p->castConst() && lsb2p->castConst()) {
	    newlsbp = new AstConst(lsb1p->fileline(),
				   lsb1p->castConst()->toUInt() + lsb2p->castConst()->toUInt());
	    lsb1p->deleteTree(); VL_DANGLING(lsb1p);
	    lsb2p->deleteTree(); VL_DANGLING(lsb2p);
	} else {
	    // Width is important, we need the width of the fromp's
	    // expression, not the potentially smaller lsb1p's width
	    newlsbp = new AstAdd(lsb1p->fileline(),
				 lsb2p, new AstExtend(lsb1p->fileline(), lsb1p));
	    newlsbp->dtypeFrom(lsb2p); // Unsigned
	    newlsbp->castAdd()->rhsp()->dtypeFrom(lsb2p);
	}
	AstSel* newp = new AstSel(nodep->fileline(),
				  fromp,
				  newlsbp,
				  widthp);
	nodep->replaceWith(newp);
	nodep->deleteTree(); VL_DANGLING(nodep);
    }

    void replaceSelConcat(AstSel* nodep) {
	// SEL(CONCAT(a,b),c,d) => SEL(a or b, . .)
	AstConcat* conp = nodep->fromp()->castConcat();
	AstNode* conLhsp = conp->lhsp();
	AstNode* conRhsp = conp->rhsp();
	if ((int)nodep->lsbConst() >= conRhsp->width()) {
	    conLhsp->unlinkFrBack();
	    AstSel* newp = new AstSel(nodep->fileline(),
				      conLhsp,
				      nodep->lsbConst() - conRhsp->width(),
				      nodep->widthConst());
	    nodep->replaceWith(newp);
	}
	else if ((int)nodep->msbConst() < conRhsp->width()) {
	    conRhsp->unlinkFrBack();
	    AstSel* newp = new AstSel(nodep->fileline(),
				      conRhsp,
				      nodep->lsbConst(),
				      nodep->widthConst());
	    nodep->replaceWith(newp);
	}
	else {
	    // Yuk, split between the two
	    conRhsp->unlinkFrBack();
	    conLhsp->unlinkFrBack();
	    AstConcat* newp = new AstConcat
		(nodep->fileline(),
		 new AstSel(nodep->fileline(),
			    conLhsp,
			    0,
			    nodep->msbConst() - conRhsp->width() + 1),
		 new AstSel(nodep->fileline(),
			    conRhsp,
			    nodep->lsbConst(),
			    conRhsp->width()-nodep->lsbConst()));
	    nodep->replaceWith(newp);
	}
	nodep->deleteTree(); VL_DANGLING(nodep);
    }
    bool operandSelReplicate(AstSel* nodep) {
	// SEL(REPLICATE(from,rep),lsb,width) => SEL(from,0,width) as long as SEL's width <= b's width
	AstReplicate* repp = nodep->fromp()->castReplicate();
	AstNode* fromp = repp->lhsp();
	AstConst* lsbp = nodep->lsbp()->castConst(); if (!lsbp) return false;
	AstNode* widthp = nodep->widthp(); if (!widthp->castConst()) return false;
	if (!fromp->width()) nodep->v3fatalSrc("Not widthed");
	if ((lsbp->toUInt() / fromp->width())
	    != ((lsbp->toUInt()+nodep->width()-1) / fromp->width())) return false;
	//
	fromp->unlinkFrBack();
	widthp->unlinkFrBack();
	AstSel* newp = new AstSel(nodep->fileline(),
				  fromp,
				  new AstConst(lsbp->fileline(), lsbp->toUInt() % fromp->width()),
				  widthp);
	newp->dtypeFrom(nodep);
	nodep->replaceWith(newp); nodep->deleteTree(); VL_DANGLING(nodep);
	return true;
    }
    bool operandRepRep(AstReplicate* nodep) {
	// REPLICATE(REPLICATE2(from2,cnt2),cnt1) => REPLICATE(from2,(cnt1+cnt2))
	AstReplicate* rep2p = nodep->lhsp()->castReplicate();
	AstNode* from2p = rep2p->lhsp();
	AstConst* cnt1p = nodep->rhsp()->castConst(); if (!cnt1p) return false;
	AstConst* cnt2p = rep2p->rhsp()->castConst(); if (!cnt2p) return false;
	//
	from2p->unlinkFrBack();
	cnt1p->unlinkFrBack();
	cnt2p->unlinkFrBack();
	AstReplicate* newp = new AstReplicate(nodep->fileline(),
					      from2p, cnt1p->toUInt()*cnt2p->toUInt());
	newp->dtypeFrom(nodep);
	nodep->replaceWith(newp); nodep->deleteTree(); VL_DANGLING(nodep);
	return true;
    }
    bool operandConcatSame(AstConcat* nodep) {
	// CONCAT(fromp,fromp) -> REPLICATE(fromp,1+1)
	// CONCAT(REP(fromp,cnt1),fromp) -> REPLICATE(fromp,cnt1+1)
	// CONCAT(fromp,REP(fromp,cnt1)) -> REPLICATE(fromp,1+cnt1)
	// CONCAT(REP(fromp,cnt1),REP(fromp,cnt2)) -> REPLICATE(fromp,cnt1+cnt2)
	AstNode* from1p = nodep->lhsp(); uint32_t cnt1 = 1;
	AstNode* from2p = nodep->rhsp(); uint32_t cnt2 = 1;
	if (from1p->castReplicate()) {
	    AstConst* cnt1p = from1p->castReplicate()->rhsp()->castConst(); if (!cnt1p) return false;
	    from1p = from1p->castReplicate()->lhsp();
	    cnt1 = cnt1p->toUInt();
	}
	if (from2p->castReplicate()) {
	    AstConst* cnt2p = from2p->castReplicate()->rhsp()->castConst(); if (!cnt2p) return false;
	    from2p = from2p->castReplicate()->lhsp();
	    cnt2 = cnt2p->toUInt();
	}
	if (!operandsSame(from1p,from2p)) return false;
	//
	from1p->unlinkFrBack();
	AstReplicate* newp = new AstReplicate(nodep->fileline(), from1p, cnt1+cnt2);
	newp->dtypeFrom(nodep);
	nodep->replaceWith(newp); nodep->deleteTree(); VL_DANGLING(nodep);
	return true;
    }
    void replaceSelIntoBiop(AstSel* nodep) {
	// SEL(BUFIF1(a,b),1,bit) => BUFIF1(SEL(a,1,bit),SEL(b,1,bit))
	AstNodeBiop* fromp = nodep->fromp()->unlinkFrBack()->castNodeBiop();
	if (!fromp) nodep->v3fatalSrc("Called on non biop");
	AstNode* lsbp = nodep->lsbp()->unlinkFrBack();
	AstNode* widthp = nodep->widthp()->unlinkFrBack();
	//
	AstNode* bilhsp = fromp->lhsp()->unlinkFrBack();
	AstNode* birhsp = fromp->rhsp()->unlinkFrBack();
	//
	fromp->lhsp(new AstSel(nodep->fileline(),
			       bilhsp, lsbp->cloneTree(true), widthp->cloneTree(true)));
	fromp->rhsp(new AstSel(nodep->fileline(),
			       birhsp, lsbp, widthp));
	fromp->dtypeFrom(nodep);
	nodep->replaceWith(fromp); nodep->deleteTree(); VL_DANGLING(nodep);
    }
    void replaceSelIntoUniop(AstSel* nodep) {
	// SEL(NOT(a),1,bit) => NOT(SEL(a,bit))
	AstNodeUniop* fromp = nodep->fromp()->unlinkFrBack()->castNodeUniop();
	if (!fromp) nodep->v3fatalSrc("Called on non biop");
	AstNode* lsbp = nodep->lsbp()->unlinkFrBack();
	AstNode* widthp = nodep->widthp()->unlinkFrBack();
	//
	AstNode* bilhsp = fromp->lhsp()->unlinkFrBack();
	//
	fromp->lhsp(new AstSel(nodep->fileline(),
			       bilhsp, lsbp, widthp));
	fromp->dtypeFrom(nodep);
	nodep->replaceWith(fromp); nodep->deleteTree(); VL_DANGLING(nodep);
    }

    virtual void visit(AstAttrOf* nodep) {
	AstAttrOf* oldAttr = m_attrp;
	m_attrp = nodep;
	nodep->iterateChildren(*this);
	m_attrp = oldAttr;
    }

    virtual void visit(AstArraySel* nodep) {
	nodep->bitp()->iterateAndNext(*this);
	if (nodep->bitp()->castConst()
	    && nodep->fromp()->castVarRef()
	    // Need to make sure it's an array object so don't mis-allow a constant (bug509.)
	    && nodep->fromp()->castVarRef()->varp()
	    && nodep->fromp()->castVarRef()->varp()->valuep()->castInitArray()) {
	    m_selp = nodep;  // Ask visit(AstVarRef) to replace varref with const
	}
	nodep->fromp()->iterateAndNext(*this);
	if (nodep->fromp()->castConst()) {  // It did.
	    if (!m_selp) {
		nodep->v3error("Illegal assignment of constant to unpacked array");
	    } else {
		AstNode* fromp = nodep->fromp()->unlinkFrBack();
		nodep->replaceWith(fromp);
		if (fromp->dtypep()->skipRefp()->castNodeArrayDType()) {
		    // Strip off array to find what array references
		    fromp->dtypeFrom(fromp->dtypep()->skipRefp()->castNodeArrayDType()->subDTypep());
		}
	    }
	}
	m_selp = NULL;
    }
    virtual void visit(AstNodeVarRef* nodep) {
	nodep->iterateChildren(*this);
	if (!nodep->varp()) nodep->v3fatalSrc("Not linked");
	bool did=false;
	if (m_doV && nodep->varp()->valuep() && !m_attrp) {
	    //if (debug()) valuep->dumpTree(cout,"  visitvaref: ");
	    nodep->varp()->valuep()->iterateAndNext(*this);  // May change nodep->varp()->valuep()
	    AstNode* valuep = nodep->varp()->valuep();
	    if (!nodep->lvalue()
		&& ((!m_params // Can reduce constant wires into equations
		     && m_doNConst
		     && v3Global.opt.oConst()
		     && !(nodep->varp()->isFuncLocal() // Default value, not a "known" constant for this usage
			  && nodep->varp()->isInput())
		     && !nodep->varp()->noSubst()
		     && !nodep->varp()->isSigPublic())
		    || nodep->varp()->isParam())) {
		if (operandConst(valuep)) {
		    const V3Number& num = valuep->castConst()->num();
		    //UINFO(2,"constVisit "<<(void*)valuep<<" "<<num<<endl);
		    replaceNum(nodep, num); VL_DANGLING(nodep);
		    did=true;
		}
		else if (m_selp && valuep->castInitArray()) {
		    AstInitArray* initarp = valuep->castInitArray();
		    uint32_t bit = m_selp->bitConst();
		    int pos = 0;
		    AstNode* itemp = initarp->initsp();
		    for (; itemp; ++pos, itemp=itemp->nextp()) {
			uint32_t index = initarp->posIndex(pos);
			if (index == bit) break;
			if (index > bit) {
			    if (initarp->defaultp()) {
				itemp = initarp->defaultp();
			    } else {
				initarp->v3fatalSrc("Not enough values in array initalizement");
			    }
			}
		    }
		    if (itemp->castConst()) {
			const V3Number& num = itemp->castConst()->num();
			//UINFO(2,"constVisit "<<(void*)valuep<<" "<<num<<endl);
			replaceNum(nodep, num); VL_DANGLING(nodep);
			did=true;
		    }
		}
		else if (m_params && valuep->castInitArray() && nodep->backp()->castPin()) {
		    // Allow parameters to pass arrays
		    // Earlier recursion of InitArray made sure each array value is constant
		    // This exception is fairly fragile, i.e. doesn't support arrays of arrays or other stuff
		    AstNode* newp = valuep->cloneTree(false);
		    nodep->replaceWith(newp); nodep->deleteTree(); VL_DANGLING(nodep);
		    did = true;
		}
	    }
	}
	if (!did && m_required) {
	    nodep->v3error("Expecting expression to be constant, but variable isn't const: "<<nodep->varp()->prettyName());
	}
    }
    virtual void visit(AstEnumItemRef* nodep) {
	nodep->iterateChildren(*this);
	if (!nodep->itemp()) nodep->v3fatalSrc("Not linked");
	bool did=false;
	if (nodep->itemp()->valuep()) {
	    //if (debug()) nodep->varp()->valuep()->dumpTree(cout,"  visitvaref: ");
	    nodep->itemp()->valuep()->iterateAndNext(*this);
	    if (AstConst* valuep = nodep->itemp()->valuep()->castConst()) {
		const V3Number& num = valuep->num();
		replaceNum(nodep, num); VL_DANGLING(nodep);
		did=true;
	    }
	}
	if (!did && m_required) {
	    nodep->v3error("Expecting expression to be constant, but variable isn't const: "<<nodep->itemp()->prettyName());
	}
    }

    // virtual void visit(AstCvtPackString* nodep) {
    // Not constant propagated (for today) because AstMath::isOpaque is set
    // Someday if lower is constant, convert to quoted "string".

    bool onlySenItemInSenTree(AstNodeSenItem* nodep) {
	// Only one if it's not in a list
	return (!nodep->nextp() && nodep->backp()->nextp() != nodep);
    }
    virtual void visit(AstSenItem* nodep) {
	nodep->iterateChildren(*this);
	if (m_doNConst
	    && (nodep->sensp()->castConst()
		|| nodep->sensp()->castEnumItemRef()
		|| (nodep->varrefp() && nodep->varrefp()->varp()->isParam()))) {
	    // Constants in sensitivity lists may be removed (we'll simplify later)
	    if (nodep->isClocked()) {  // A constant can never get a pos/negexge
		if (onlySenItemInSenTree(nodep)) {
		    nodep->replaceWith(new AstSenItem(nodep->fileline(), AstSenItem::Never()));
		    nodep->deleteTree(); VL_DANGLING(nodep);
		} else {
		    nodep->unlinkFrBack()->deleteTree(); VL_DANGLING(nodep);
		}
	    } else {  // Otherwise it may compute a result that needs to settle out
		nodep->replaceWith(new AstSenItem(nodep->fileline(), AstSenItem::Combo()));
		nodep->deleteTree(); VL_DANGLING(nodep);
	    }
	} else if (m_doNConst && nodep->sensp()->castNot()) {
	    // V3Gate may propagate NOTs into clocks... Just deal with it
	    AstNode* sensp = nodep->sensp();
	    AstNode* lastSensp = sensp;
	    bool invert = false;
	    while (lastSensp->castNot()) {
		lastSensp = lastSensp->castNot()->lhsp();
		invert = !invert;
	    }
	    UINFO(8,"senItem(NOT...) "<<nodep<<" "<<invert<<endl);
	    if (invert) nodep->edgeType( nodep->edgeType().invert() );
	    AstNodeVarRef* senvarp = lastSensp->unlinkFrBack()->castNodeVarRef();
	    if (!senvarp) sensp->v3fatalSrc("Non-varref sensitivity variable");
	    sensp->replaceWith(senvarp);
	    sensp->deleteTree(); VL_DANGLING(sensp);
	} else if (!m_doNConst  // Deal with later when doNConst missing
		   && (nodep->sensp()->castEnumItemRef()
		       || nodep->sensp()->castConst())) {
	} else if (nodep->isIllegal()) {  // Deal with later
	} else {
	    if (nodep->hasVar() && !nodep->varrefp()) nodep->v3fatalSrc("Null sensitivity variable");
	}
    }
    virtual void visit(AstSenGate* nodep) {
	nodep->iterateChildren(*this);
	if (AstConst* constp = nodep->rhsp()->castConst()) {
	    if (constp->isZero()) {
		UINFO(4,"SENGATE(...,0)->NEVER"<<endl);
		if (onlySenItemInSenTree(nodep)) {
		    nodep->replaceWith(new AstSenItem(nodep->fileline(), AstSenItem::Never()));
		    nodep->deleteTree(); VL_DANGLING(nodep);
		} else {
		    nodep->unlinkFrBack()->deleteTree(); VL_DANGLING(nodep);
		}
	    } else {
		UINFO(4,"SENGATE(SENITEM,0)->ALWAYS SENITEM"<<endl);
		AstNode* senitemp = nodep->sensesp()->unlinkFrBack();
		nodep->replaceWith(senitemp);
		nodep->deleteTree(); VL_DANGLING(nodep);
	    }
	}
    }

    struct SenItemCmp {
	inline bool operator () (AstNodeSenItem* lhsp, AstNodeSenItem* rhsp) const {
	    if (lhsp->type() < rhsp->type()) return true;
	    if (lhsp->type() > rhsp->type()) return false;
	    const AstSenItem* litemp = lhsp->castSenItem();
	    const AstSenItem* ritemp = rhsp->castSenItem();
	    if (litemp && ritemp) {
		// Looks visually better if we keep sorted by name
		if (!litemp->varrefp() &&  ritemp->varrefp()) return true;
		if ( litemp->varrefp() && !ritemp->varrefp()) return false;
		if (litemp->varrefp() && ritemp->varrefp()) {
		    if (litemp->varrefp()->name() < ritemp->varrefp()->name()) return true;
		    if (litemp->varrefp()->name() > ritemp->varrefp()->name()) return false;
		    // But might be same name with different scopes
		    if (litemp->varrefp()->varScopep() < ritemp->varrefp()->varScopep()) return true;
		    if (litemp->varrefp()->varScopep() > ritemp->varrefp()->varScopep()) return false;
		    // Or rarely, different data types
		    if (litemp->varrefp()->dtypep() < ritemp->varrefp()->dtypep()) return true;
		    if (litemp->varrefp()->dtypep() > ritemp->varrefp()->dtypep()) return false;
		}
		// Sort by edge, AFTER variable, as we want multiple edges for same var adjacent
		// note the SenTree optimizer requires this order (more general first, less general last)
		if (litemp->edgeType() < ritemp->edgeType()) return true;
		if (litemp->edgeType() > ritemp->edgeType()) return false;
	    }
	    return false;
	}
    };

    virtual void visit(AstSenTree* nodep) {
	nodep->iterateChildren(*this);
	if (m_doExpensive) {
	    //cout<<endl; nodep->dumpTree(cout,"ssin: ");
	    // Optimize ideas for the future:
	    //   SENTREE(... SENGATE(x,a), SENGATE(SENITEM(x),b) ...)  => SENGATE(x,OR(a,b))

	    //   SENTREE(... SENITEM(x),   SENGATE(SENITEM(x),*) ...)  => SENITEM(x)
	    // Do we need the SENITEM's to be identical?  No because we're
	    // ORing between them; we just need to insure that the result is at
	    // least as frequently activating.  So we simply
	    // SENGATE(SENITEM(x)) -> SENITEM(x), then let it collapse with the
	    // other SENITEM(x).
	    {
		AstUser4InUse	m_inuse4;
		// Mark x in SENITEM(x)
		for (AstNodeSenItem* senp = nodep->sensesp()->castNodeSenItem();
		     senp; senp=senp->nextp()->castNodeSenItem()) {
		    if (AstSenItem* itemp = senp->castSenItem()) {
			if (itemp->varrefp() && itemp->varrefp()->varScopep()) {
			    itemp->varrefp()->varScopep()->user4(1);
			}
		    }
		}
		// Find x in SENTREE(SENITEM(x))
		for (AstNodeSenItem* nextp, * senp = nodep->sensesp()->castNodeSenItem();
		     senp; senp=nextp) {
		    nextp=senp->nextp()->castNodeSenItem();
		    if (AstSenGate* gatep = senp->castSenGate()) {
			if (AstSenItem* itemp = gatep->sensesp()->castSenItem()) {
			    if (itemp->varrefp() && itemp->varrefp()->varScopep()) {
				if (itemp->varrefp()->varScopep()->user4()) {
				    // Found, push this item up to the top
				    itemp->unlinkFrBack();
				    nodep->addSensesp(itemp);
				    gatep->unlinkFrBack()->deleteTree(); VL_DANGLING(gatep); VL_DANGLING(senp);
				}
			    }
			}
		    }
		}
	    }

	    // Sort the sensitivity names so "posedge a or b" and "posedge b or a" end up together.
	    // Also, remove duplicate assignments, and fold POS&NEGs into ANYEDGEs
	    // Make things a little faster; check first if we need a sort
	    for (AstNodeSenItem* nextp, * senp = nodep->sensesp()->castNodeSenItem();
		 senp; senp=nextp) {
		nextp=senp->nextp()->castNodeSenItem();
		// cppcheck-suppress unassignedVariable  // cppcheck bug
		SenItemCmp cmp;
		if (nextp && !cmp(senp, nextp)) {
		    // Something's out of order, sort it
		    senp = NULL;
		    vector<AstNodeSenItem*> vec;
		    for (AstNodeSenItem* senp = nodep->sensesp()->castNodeSenItem(); senp; senp=senp->nextp()->castNodeSenItem()) {
			vec.push_back(senp);
		    }
		    stable_sort(vec.begin(), vec.end(), SenItemCmp());
		    for (vector<AstNodeSenItem*>::iterator it=vec.begin(); it!=vec.end(); ++it) {
			(*it)->unlinkFrBack();
		    }
		    for (vector<AstNodeSenItem*>::iterator it=vec.begin(); it!=vec.end(); ++it) {
			nodep->addSensesp(*it);
		    }
		    break;
		}
	    }

	    // Pass2, remove dup edges
	    for (AstNodeSenItem* nextp, * senp = nodep->sensesp()->castNodeSenItem();
		 senp; senp=nextp) {
		nextp=senp->nextp()->castNodeSenItem();
		AstNodeSenItem* cmpp = nextp;
		AstSenItem* litemp = senp->castSenItem();
		AstSenItem* ritemp = cmpp->castSenItem();
		if (litemp && ritemp) {
		    if ((litemp->varrefp() && ritemp->varrefp() && litemp->varrefp()->sameGateTree(ritemp->varrefp()))
			|| (!litemp->varrefp() && !ritemp->varrefp())) {
			// We've sorted in the order ANY, BOTH, POS, NEG, so we don't need to try opposite orders
			if ((   litemp->edgeType()==AstEdgeType::ET_ANYEDGE)   // ANY  or {BOTH|POS|NEG} -> ANY
			    || (litemp->edgeType()==AstEdgeType::ET_BOTHEDGE)  // BOTH or {POS|NEG} -> BOTH
			    || (litemp->edgeType()==AstEdgeType::ET_POSEDGE    // POS  or NEG -> BOTH
				&& ritemp->edgeType()==AstEdgeType::ET_NEGEDGE)
			    || (litemp->edgeType()==ritemp->edgeType())	// Identical edges
			    ) {
			    // Fix edge of old node
			    if (litemp->edgeType()==AstEdgeType::ET_POSEDGE
				&& ritemp->edgeType()==AstEdgeType::ET_NEGEDGE)
				litemp->edgeType(AstEdgeType::ET_BOTHEDGE);
			    // Remove redundant node
			    ritemp->unlinkFrBack()->deleteTree(); VL_DANGLING(ritemp); VL_DANGLING(cmpp);
			    // Try to collapse again
			    nextp=litemp;
			}
		    }
		}
	    }
	    //nodep->dumpTree(cout,"ssou: ");
	}
    }

    //-----
    // Zero elimination
    virtual void visit(AstNodeAssign* nodep) {
	nodep->iterateChildren(*this);
	if (m_doNConst && replaceNodeAssign(nodep)) return;
    }
    virtual void visit(AstAssignAlias* nodep) {
	// Don't perform any optimizations, keep the alias around
    }
    virtual void visit(AstAssignVarScope* nodep) {
	// Don't perform any optimizations, the node won't be linked yet
    }
    virtual void visit(AstAssignW* nodep) {
	nodep->iterateChildren(*this);
	if (m_doNConst && replaceNodeAssign(nodep)) return;
	AstNodeVarRef* varrefp = nodep->lhsp()->castVarRef();  // Not VarXRef, as different refs may set different values to each hierarchy
	if (m_wremove && !m_params && m_doNConst
	    && m_modp && operandConst(nodep->rhsp())
	    && !nodep->rhsp()->castConst()->num().isFourState()
	    && varrefp		// Don't do messes with BITREFs/ARRAYREFs
	    && !varrefp->varp()->valuep()  // Not already constified
	    && !varrefp->varScopep()) {	// Not scoped (or each scope may have different initial value)
	    // ASSIGNW (VARREF, const) -> INITIAL ( ASSIGN (VARREF, const) )
	    UINFO(4,"constAssignW "<<nodep<<endl);
	    // Make a initial assignment
	    AstNode* exprp = nodep->rhsp()->unlinkFrBack();
	    varrefp->unlinkFrBack();
	    AstInitial* newinitp
		= new AstInitial(nodep->fileline(),
				 new AstAssign(nodep->fileline(),
					       varrefp, exprp));
	    m_modp->addStmtp(newinitp);
	    nodep->unlinkFrBack()->deleteTree(); VL_DANGLING(nodep);
	    // Set the initial value right in the variable so we can constant propagate
	    AstNode* initvaluep = exprp->cloneTree(false);
	    varrefp->varp()->valuep(initvaluep);
	}
    }

    virtual void visit(AstNodeIf* nodep) {
	nodep->iterateChildren(*this);
	if (m_doNConst) {
	    if (AstConst* constp = nodep->condp()->castConst()) {
		AstNode* keepp = NULL;
		if (constp->isZero()) {
		    UINFO(4,"IF(0,{any},{x}) => {x}: "<<nodep<<endl);
		    keepp = nodep->elsesp();
		} else {
		    UINFO(4,"IF(!0,{x},{any}) => {x}: "<<nodep<<endl);
		    keepp = nodep->ifsp();
		}
		if (keepp) {
		    keepp->unlinkFrBackWithNext();
		    nodep->replaceWith(keepp);
		} else {
		    nodep->unlinkFrBack();
		}
		nodep->deleteTree(); VL_DANGLING(nodep);
	    }
	    else if (!afterComment(nodep->ifsp()) && !afterComment(nodep->elsesp())) {
		// Empty block, remove it
		// Note if we support more C++ then there might be side effects in the condition itself
		nodep->unlinkFrBack()->deleteTree(); VL_DANGLING(nodep);
	    }
	    else if (!afterComment(nodep->ifsp())) {
		UINFO(4,"IF({x}) NULL {...} => IF(NOT{x}}: "<<nodep<<endl);
		AstNode* condp = nodep->condp();
		AstNode* elsesp = nodep->elsesp();
		condp->unlinkFrBackWithNext();
		elsesp->unlinkFrBackWithNext();
		if (nodep->ifsp()) { nodep->ifsp()->unlinkFrBackWithNext()->deleteTree(); }  // Must have been comment
		nodep->condp(new AstLogNot(condp->fileline(), condp));  // LogNot, as C++ optimization also possible
		nodep->addIfsp(elsesp);
	    }
	    else if (((nodep->condp()->castNot() && nodep->condp()->width()==1)
		      || (nodep->condp()->castLogNot()))
		     && nodep->ifsp() && nodep->elsesp()) {
		UINFO(4,"IF(NOT {x})  => IF(x) swapped if/else"<<nodep<<endl);
		AstNode* condp = nodep->condp()->castNot()->lhsp()->unlinkFrBackWithNext();
		AstNode* ifsp = nodep->ifsp()->unlinkFrBackWithNext();
		AstNode* elsesp = nodep->elsesp()->unlinkFrBackWithNext();
		AstIf* ifp = new AstIf(nodep->fileline(), condp, elsesp, ifsp);
		ifp->branchPred(nodep->branchPred().invert());
		nodep->replaceWith(ifp);
		nodep->deleteTree(); VL_DANGLING(nodep);
	    }
	    else if (ifSameAssign(nodep)) {
		UINFO(4,"IF({a}) ASSIGN({b},{c}) else ASSIGN({b},{d}) => ASSIGN({b}, {a}?{c}:{d})"<<endl);
		AstNodeAssign* ifp   = nodep->ifsp()->castNodeAssign();
		AstNodeAssign* elsep = nodep->elsesp()->castNodeAssign();
		ifp->unlinkFrBack();
		AstNode* condp = nodep->condp()->unlinkFrBack();
		AstNode* truep = ifp->rhsp()->unlinkFrBack();
		AstNode* falsep = elsep->rhsp()->unlinkFrBack();
		ifp->rhsp(new AstCond(truep->fileline(),
				      condp, truep, falsep));
		nodep->replaceWith(ifp);
		nodep->deleteTree(); VL_DANGLING(nodep);
	    }
	    else if (0	// Disabled, as vpm assertions are faster without due to short-circuiting
		     && operandIfIf(nodep)) {
		UINFO(9,"IF({a}) IF({b}) => IF({a} && {b})"<<endl);
		AstNodeIf* lowerIfp = nodep->ifsp()->castNodeIf();
		AstNode* condp = nodep->condp()->unlinkFrBack();
		AstNode* lowerIfsp = lowerIfp->ifsp()->unlinkFrBackWithNext();
		AstNode* lowerCondp = lowerIfp->condp()->unlinkFrBackWithNext();
		nodep->condp(new AstLogAnd(lowerIfp->fileline(),
					   condp, lowerCondp));
		lowerIfp->replaceWith(lowerIfsp);
		lowerIfp->deleteTree(); VL_DANGLING(lowerIfp);
	    }
	    else if (operandBoolShift(nodep->condp())) {
		replaceBoolShift(nodep->condp());
	    }
	}
    }

    virtual void visit(AstDisplay* nodep) {
        // DISPLAY(SFORMAT(text1)),DISPLAY(SFORMAT(text2)) -> DISPLAY(SFORMAT(text1+text2))
        nodep->iterateChildren(*this);
        if (stmtDisplayDisplay(nodep)) return;
    }
    bool stmtDisplayDisplay(AstDisplay* nodep) {
        // DISPLAY(SFORMAT(text1)),DISPLAY(SFORMAT(text2)) -> DISPLAY(SFORMAT(text1+text2))
        if (!m_modp) return false;  // Don't optimize under single statement
        if (!nodep->backp()) return false;
        AstDisplay* prevp = nodep->backp()->castDisplay();
        if (!prevp) return false;
        if (!((prevp->displayType() == nodep->displayType())
              || (prevp->displayType() == AstDisplayType::DT_WRITE
                  && nodep->displayType() == AstDisplayType::DT_DISPLAY)
              || (prevp->displayType() == AstDisplayType::DT_DISPLAY
                  && nodep->displayType() == AstDisplayType::DT_WRITE)))
            return false;
        if ((prevp->filep() && !nodep->filep())
            || (!prevp->filep() && nodep->filep())
            || !prevp->filep()->sameTree(nodep->filep())) return false;
        if (!prevp->fmtp() || prevp->fmtp()->nextp()
            || !nodep->fmtp() || nodep->fmtp()->nextp()) return false;
        // We don't merge scopeNames as might be different scopes (late in process)
        // We don't merge arguments as might need to later print warnings with right line numbers
        AstSFormatF* pformatp = prevp->fmtp();
        if (!pformatp || pformatp->exprsp() || pformatp->scopeNamep()) return false;
        AstSFormatF* nformatp = nodep->fmtp();
        if (!nformatp || nformatp->exprsp() || nformatp->scopeNamep()) return false;
        //
        UINFO(9,"DISPLAY(SF({a})) DISPLAY(SF({b})) -> DISPLAY(SF({a}+{b}))"<<endl);
        // Convert DT_DISPLAY to DT_WRITE as may allow later optimizations
        if (prevp->displayType() == AstDisplayType::DT_DISPLAY) {
            prevp->displayType(AstDisplayType::DT_WRITE);
            pformatp->text(pformatp->text()+"\n");
        }
        // We can't replace prev() as the edit tracking iterators will get confused.
        // So instead we edit the prev note itself.
        if (prevp->addNewline()) pformatp->text(pformatp->text()+"\n");
        pformatp->text(pformatp->text()+nformatp->text());
        if (!prevp->addNewline() && nodep->addNewline()) {
            pformatp->text(pformatp->text()+"\n");
        }
        nodep->unlinkFrBack()->deleteTree(); VL_DANGLING(nodep);
        return true;
    }
    virtual void visit(AstSFormatF* nodep) {
	// Substitute constants into displays.  The main point of this is to
	// simplify assertion methodologies which call functions with display's.
	// This eliminates a pile of wide temps, and makes the C a whole lot more readable.
	nodep->iterateChildren(*this);
	bool anyconst = false;
	for (AstNode* argp = nodep->exprsp(); argp; argp=argp->nextp()) {
	    if (argp->castConst()) { anyconst=true; break; }
	}
	if (m_doNConst && anyconst) {
	    //UINFO(9,"  Display in  "<<nodep->text()<<endl);
	    string newFormat = "";
	    string fmt = "";
	    bool inPct = false;
	    AstNode* argp = nodep->exprsp();
	    string text = nodep->text();
	    for (string::const_iterator it = text.begin(); it!=text.end(); ++it) {
		char ch = *it;
		if (!inPct && ch=='%') {
		    inPct = true;
		    fmt = ch;
		} else if (inPct && (isdigit(ch) || ch=='.')) {
		    fmt += ch;
		} else if (inPct) {
		    inPct = false;
		    fmt += ch;
		    switch (tolower(ch)) {
		    case '%': break;  // %% - just output a %
		    case 'm': break;  // %m - auto insert "name"
		    case 'l': break;  // %l - auto insert "library"
		    default:  // Most operators, just move to next argument
			if (argp) {
			    AstNode* nextp=argp->nextp();
			    if (argp && argp->castConst()) { // Convert it
				string out = argp->castConst()->num().displayed(nodep->fileline(), fmt);
				UINFO(9,"     DispConst: "<<fmt<<" -> "<<out<<"  for "<<argp<<endl);
				// fmt = out w/ replace % with %% as it must be literal.
				fmt = VString::quotePercent(out);
				argp->unlinkFrBack()->deleteTree(); VL_DANGLING(argp);
			    }
			    argp=nextp;
			}
			break;
		    } // switch
		    newFormat += fmt;
		} else {
		    newFormat += ch;
		}
	    }
	    if (newFormat != nodep->text()) {
		nodep->text(newFormat);
		UINFO(9,"  Display out "<<nodep<<endl);
	    }
	}
	if (!nodep->exprsp()
	    && nodep->name().find("%") == string::npos
	    && !nodep->hidden()) {
	    // Just a simple constant string - the formatting is pointless
	    replaceConstString(nodep, nodep->name()); VL_DANGLING(nodep);
	}
    }

    virtual void visit(AstFuncRef* nodep) {
	nodep->iterateChildren(*this);
	if (m_params) {  // Only parameters force us to do constant function call propagation
	    replaceWithSimulation(nodep);
	}
    }
    virtual void visit(AstArg* nodep) {
	// replaceWithSimulation on the Arg's parent FuncRef replaces these
	nodep->iterateChildren(*this);
    }
    virtual void visit(AstWhile* nodep) {
        bool oldHasJumpGo = m_hasJumpGo;
        m_hasJumpGo = false;
        {
            nodep->iterateChildren(*this);
        }
        bool thisWhileHasJumpGo = m_hasJumpGo;
        m_hasJumpGo = thisWhileHasJumpGo || oldHasJumpGo;
	if (m_doNConst) {
	    if (nodep->condp()->isZero()) {
		UINFO(4,"WHILE(0) => nop "<<nodep<<endl);
		if (nodep->precondsp()) nodep->replaceWith(nodep->precondsp());
		else nodep->unlinkFrBack();
		nodep->deleteTree(); VL_DANGLING(nodep);
	    }
            else if (nodep->condp()->isNeqZero()) {
                if (!thisWhileHasJumpGo) {
                    nodep->v3warn(INFINITELOOP, "Infinite loop (condition always true)");
                    nodep->fileline()->modifyWarnOff(V3ErrorCode::INFINITELOOP, true);  // Complain just once
                }
            }
	    else if (operandBoolShift(nodep->condp())) {
		replaceBoolShift(nodep->condp());
	    }
	}
    }
    virtual void visit(AstInitArray* nodep) {
	// Constant if all children are constant
	nodep->iterateChildren(*this);
    }

    // These are converted by V3Param.  Don't constify as we don't want the from() VARREF to disappear, if any
    // If output of a presel didn't get consted, chances are V3Param didn't visit properly
    virtual void visit(AstNodePreSel* nodep) {}

    // Ignored, can eliminate early
    virtual void visit(AstSysIgnore* nodep) {
	nodep->iterateChildren(*this);
	if (m_doNConst) {
	    nodep->unlinkFrBack()->deleteTree(); VL_DANGLING(nodep);
	}
    }

    // Simplify
    virtual void visit(AstBasicDType* nodep) {
	nodep->iterateChildren(*this);
	nodep->cvtRangeConst();
    }

    //-----
    // Jump elimination

    virtual void visit(AstJumpGo* nodep) {
	nodep->iterateChildren(*this);
        m_hasJumpGo = true;
	if (m_doExpensive) { nodep->labelp()->user4(true); }
    }

    virtual void visit(AstJumpLabel* nodep) {
	// Because JumpLabels disable many optimizations,
	// remove JumpLabels that are not pointed to by any AstJumpGos
	// Note this assumes all AstJumpGos are underneath the given label; V3Broken asserts this
	nodep->iterateChildren(*this);
	// AstJumpGo's below here that point to this node will set user4
	if (m_doExpensive && !nodep->user4()) {
	    UINFO(4,"JUMPLABEL => unused "<<nodep<<endl);
	    AstNode* underp = NULL;
	    if (nodep->stmtsp()) underp = nodep->stmtsp()->unlinkFrBackWithNext();
	    if (underp) nodep->replaceWith(underp);
	    else nodep->unlinkFrBack();
	    nodep->deleteTree(); VL_DANGLING(nodep);
	}
    }

    //-----
    // Below lines are magic expressions processed by astgen
    //  TREE_SKIP_VISIT("AstNODETYPE")    # Rename normal visit to visitGen and don't iterate
    //-----

//    TREE_SKIP_VISIT("ArraySel");
#line 2125 "V3Const__gen.cpp"
#line 2122 "../V3Const.cpp"

    //-----
    //  "AstNODETYPE {             # bracket not paren
    //                $accessor_name, ...
    //                             # ,, gets replaced with a , rather than &&
    //	             }" 	   # bracket not paren
    //    ,"what to call"
    //
    // Where "what_to_call" is:
    //		"function to call"
    //		"AstREPLACEMENT_TYPE{ $accessor }"
    //		"!   		# Print line number when matches, so can see operations
    //		"NEVER"		# Print error message
    //		"DONE"		# Process of matching did the transform already

    // In the future maybe support more complicated match & replace:
    //   ("AstOr  {%a, AstAnd{AstNot{%b}, %c}} if %a.width1 if %a==%b",	"AstOr{%a,%c}; %b.delete");
    // Lhs/rhs would be implied; for non math operations you'd need $lhsp etc.

    // Lint Checks
    //    v--- *1* These ops are always first, as we warn before replacing
    //    v--- *V* This op is a verilog op, only in m_doV mode
    //    v--- *C* This op works on all constant children, allowed in m_doConst mode
    //    v--- *S* This op specifies a type should use short-circuting of its lhs op

//    TREEOP1("AstSel{warnSelect(nodep)}",	"NEVER");
#line 2153 "V3Const__gen.cpp"
    // TREEOP functions, each return true if they matched & transformed
    // Generated by astgen
    bool match_Add_0(AstAdd* nodep) {
	// TREEOP ("AstAdd   {$lhsp.isZero, $rhsp}",	"replaceWRhs(nodep)")
	if (m_doNConst && nodep->lhsp()->isZero()) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstAdd $lhsp.isZero, $rhsp , replaceWRhs(nodep) )\n");
	    replaceWRhs(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Add_1(AstAdd* nodep) {
	// TREEOP ("AstAdd   {$lhsp, $rhsp.isZero}",	"replaceWLhs(nodep)")
	if (m_doNConst && nodep->rhsp()->isZero()) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstAdd $lhsp, $rhsp.isZero , replaceWLhs(nodep) )\n");
	    replaceWLhs(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_And_0(AstAnd* nodep) {
	// TREEOP ("AstAnd   {$lhsp.isZero, $rhsp, isTPure($rhsp)}",	"replaceZero(nodep)")
	if (m_doNConst && nodep->lhsp()->isZero() && isTPure(nodep->rhsp())) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstAnd $lhsp.isZero, $rhsp, isTPure($rhsp) , replaceZero(nodep) )\n");
	    replaceZero(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_And_1(AstAnd* nodep) {
	// TREEOP ("AstAnd   {$lhsp, $rhsp.isZero}",	"replaceZeroChkPure(nodep,$lhsp)")
	if (m_doNConst && nodep->rhsp()->isZero()) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstAnd $lhsp, $rhsp.isZero , replaceZeroChkPure(nodep,$lhsp) )\n");
	    replaceZeroChkPure(nodep,nodep->lhsp());
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_And_2(AstAnd* nodep) {
	// TREEOP ("AstAnd   {$lhsp.isAllOnes, $rhsp}",	"replaceWRhs(nodep)")
	if (m_doNConst && nodep->lhsp()->isAllOnes()) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstAnd $lhsp.isAllOnes, $rhsp , replaceWRhs(nodep) )\n");
	    replaceWRhs(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_And_3(AstAnd* nodep) {
	// TREEOP ("AstAnd   {$lhsp, $rhsp.isAllOnes}",	"replaceWLhs(nodep)")
	if (m_doNConst && nodep->rhsp()->isAllOnes()) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstAnd $lhsp, $rhsp.isAllOnes , replaceWLhs(nodep) )\n");
	    replaceWLhs(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_And_4(AstAnd* nodep) {
	// TREEOP ("AstAnd    {operandsSame($lhsp,,$rhsp)}",	"replaceWLhs(nodep)")
	if (m_doNConst && operandsSame(nodep->lhsp(),nodep->rhsp())) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstAnd operandsSame($lhsp,,$rhsp) , replaceWLhs(nodep) )\n");
	    replaceWLhs(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_And_5(AstAnd* nodep) {
	// TREEOP ("AstAnd {$lhsp.castOr, $rhsp.castOr, operandAndOrSame(nodep)}",	"replaceAndOr(nodep)")
	if (m_doNConst && nodep->lhsp()->castOr() && nodep->rhsp()->castOr() && operandAndOrSame(nodep)) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstAnd $lhsp.castOr, $rhsp.castOr, operandAndOrSame(nodep) , replaceAndOr(nodep) )\n");
	    replaceAndOr(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_And_6(AstAnd* nodep) {
	// TREEOP ("AstAnd {operandShiftSame(nodep)}",		"replaceShiftSame(nodep)")
	if (m_doNConst && operandShiftSame(nodep)) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstAnd operandShiftSame(nodep) , replaceShiftSame(nodep) )\n");
	    replaceShiftSame(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_ChangeXor_0(AstChangeXor* nodep) {
	// TREEOP ("AstChangeXor{operandsSame($lhsp,,$rhsp)}",	"replaceZero(nodep)")
	if (m_doNConst && operandsSame(nodep->lhsp(),nodep->rhsp())) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstChangeXor operandsSame($lhsp,,$rhsp) , replaceZero(nodep) )\n");
	    replaceZero(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Concat_0(AstConcat* nodep) {
	// TREEOPV("AstConcat{operandConcatMove(nodep)}",	"moveConcat(nodep)")
	if (m_doV && operandConcatMove(nodep)) {
	    UINFO(7,(void*)(nodep)<<" TREEOPV( AstConcat operandConcatMove(nodep) , moveConcat(nodep) )\n");
	    moveConcat(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Concat_1(AstConcat* nodep) {
	// TREEOPV("AstConcat{$lhsp.isZero, $rhsp}",		"replaceExtend(nodep, nodep->rhsp())")
	if (m_doV && nodep->lhsp()->isZero()) {
	    UINFO(7,(void*)(nodep)<<" TREEOPV( AstConcat $lhsp.isZero, $rhsp , replaceExtend(nodep, nodep->rhsp()) )\n");
	    replaceExtend(nodep, nodep->rhsp());
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Concat_2(AstConcat* nodep) {
	// TREEOPV("AstConcat{$lhsp.castSel, $rhsp.castSel, ifAdjacentSel($lhsp->castSel(),,$rhsp->castSel())}",  "replaceConcatSel(nodep)")
	if (m_doV && nodep->lhsp()->castSel() && nodep->rhsp()->castSel() && ifAdjacentSel(nodep->lhsp()->castSel(),nodep->rhsp()->castSel())) {
	    UINFO(7,(void*)(nodep)<<" TREEOPV( AstConcat $lhsp.castSel, $rhsp.castSel, ifAdjacentSel($lhsp->castSel(),,$rhsp->castSel()) , replaceConcatSel(nodep) )\n");
	    replaceConcatSel(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Concat_3(AstConcat* nodep) {
	// TREEOPV("AstConcat{ifConcatMergeableBiop($lhsp), concatMergeable($lhsp,,$rhsp)}", "replaceConcatMerge(nodep)")
	if (m_doV && ifConcatMergeableBiop(nodep->lhsp()) && concatMergeable(nodep->lhsp(),nodep->rhsp())) {
	    UINFO(7,(void*)(nodep)<<" TREEOPV( AstConcat ifConcatMergeableBiop($lhsp), concatMergeable($lhsp,,$rhsp) , replaceConcatMerge(nodep) )\n");
	    replaceConcatMerge(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Concat_4(AstConcat* nodep) {
	// TREEOPV("AstConcat{operandConcatSame(nodep)}", "DONE")
	if (m_doV && operandConcatSame(nodep)) {
	    UINFO(7,(void*)(nodep)<<" TREEOPV( AstConcat operandConcatSame(nodep) , DONE )\n");
	    
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Cond_0(AstCond* nodep) {
	// TREEOPS("AstCond {$lhsp.isZero}",		"replaceWIteratedThs(nodep)")
	if (m_doNConst && nodep->lhsp()->isZero()) {
	    UINFO(7,(void*)(nodep)<<" TREEOPS( AstCond $lhsp.isZero , replaceWIteratedThs(nodep) )\n");
	    replaceWIteratedThs(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Cond_1(AstCond* nodep) {
	// TREEOPS("AstCond {$lhsp.isNeqZero}",	"replaceWIteratedRhs(nodep)")
	if (m_doNConst && nodep->lhsp()->isNeqZero()) {
	    UINFO(7,(void*)(nodep)<<" TREEOPS( AstCond $lhsp.isNeqZero , replaceWIteratedRhs(nodep) )\n");
	    replaceWIteratedRhs(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Cond_2(AstCond* nodep) {
	// TREEOP ("AstCond{$condp.castNot,       $expr1p, $expr2p}", "AstCond{$condp->op1p(), $expr2p, $expr1p}")
	if (m_doNConst && nodep->condp()->castNot()) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstCond $condp.castNot, $expr1p, $expr2p , AstCond $condp->op1p(), $expr2p, $expr1p )\n");
	    AstNode* arg1p = nodep->condp()->op1p()->unlinkFrBack();
AstNode* arg2p = nodep->expr2p()->unlinkFrBack();
AstNode* arg3p = nodep->expr1p()->unlinkFrBack();
AstNode* newp = new AstCond(nodep->fileline(), arg1p, arg2p, arg3p);
nodep->replaceWith(newp);nodep->deleteTree(); VL_DANGLING(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_CvtPackString_0(AstCvtPackString* nodep) {
	// TREEOPC("AstCvtPackString{$lhsp.castConst}",	"replaceConstString(nodep, nodep->lhsp()->castConst()->num().toString())")
	if (nodep->lhsp()->castConst()) {
	    UINFO(7,(void*)(nodep)<<" TREEOPC( AstCvtPackString $lhsp.castConst , replaceConstString(nodep, nodep->lhsp()->castConst()->num().toString()) )\n");
	    replaceConstString(nodep, nodep->lhsp()->castConst()->num().toString());
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Div_0(AstDiv* nodep) {
	// TREEOP ("AstDiv   {$lhsp.isZero, $rhsp}",	"replaceZeroChkPure(nodep,$rhsp)")
	if (m_doNConst && nodep->lhsp()->isZero()) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstDiv $lhsp.isZero, $rhsp , replaceZeroChkPure(nodep,$rhsp) )\n");
	    replaceZeroChkPure(nodep,nodep->rhsp());
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Div_1(AstDiv* nodep) {
	// TREEOP ("AstDiv   {$lhsp, $rhsp.isOne}",	"replaceWLhs(nodep)")
	if (m_doNConst && nodep->rhsp()->isOne()) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstDiv $lhsp, $rhsp.isOne , replaceWLhs(nodep) )\n");
	    replaceWLhs(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Div_2(AstDiv* nodep) {
	// TREEOP ("AstDiv   {$lhsp, operandIsPowTwo($rhsp)}",	"replaceDivShift(nodep)")
	if (m_doNConst && operandIsPowTwo(nodep->rhsp())) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstDiv $lhsp, operandIsPowTwo($rhsp) , replaceDivShift(nodep) )\n");
	    replaceDivShift(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Div_3(AstDiv* nodep) {
	// TREEOP ("AstDiv    {operandsSame($lhsp,,$rhsp)}",	"replaceNum(nodep,1)")
	if (m_doNConst && operandsSame(nodep->lhsp(),nodep->rhsp())) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstDiv operandsSame($lhsp,,$rhsp) , replaceNum(nodep,1) )\n");
	    replaceNum(nodep,1);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_DivS_0(AstDivS* nodep) {
	// TREEOP ("AstDivS  {$lhsp.isZero, $rhsp}",	"replaceZeroChkPure(nodep,$rhsp)")
	if (m_doNConst && nodep->lhsp()->isZero()) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstDivS $lhsp.isZero, $rhsp , replaceZeroChkPure(nodep,$rhsp) )\n");
	    replaceZeroChkPure(nodep,nodep->rhsp());
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_DivS_1(AstDivS* nodep) {
	// TREEOP ("AstDivS  {$lhsp, $rhsp.isOne}",	"replaceWLhs(nodep)")
	if (m_doNConst && nodep->rhsp()->isOne()) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstDivS $lhsp, $rhsp.isOne , replaceWLhs(nodep) )\n");
	    replaceWLhs(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_DivS_2(AstDivS* nodep) {
	// TREEOP ("AstDivS   {operandsSame($lhsp,,$rhsp)}",	"replaceNum(nodep,1)")
	if (m_doNConst && operandsSame(nodep->lhsp(),nodep->rhsp())) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstDivS operandsSame($lhsp,,$rhsp) , replaceNum(nodep,1) )\n");
	    replaceNum(nodep,1);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Eq_0(AstEq* nodep) {
	// TREEOPV("AstEq    {$rhsp.castExtend,operandBiExtendConstShrink(nodep)}",	"DONE")
	if (m_doV && nodep->rhsp()->castExtend() && operandBiExtendConstShrink(nodep)) {
	    UINFO(7,(void*)(nodep)<<" TREEOPV( AstEq $rhsp.castExtend,operandBiExtendConstShrink(nodep) , DONE )\n");
	    
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Eq_1(AstEq* nodep) {
	// TREEOPV("AstEq    {$rhsp.castExtend,operandBiExtendConstOver(nodep)}",	"replaceZero(nodep)")
	if (m_doV && nodep->rhsp()->castExtend() && operandBiExtendConstOver(nodep)) {
	    UINFO(7,(void*)(nodep)<<" TREEOPV( AstEq $rhsp.castExtend,operandBiExtendConstOver(nodep) , replaceZero(nodep) )\n");
	    replaceZero(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Eq_2(AstEq* nodep) {
	// TREEOP ("AstEq     {operandsSame($lhsp,,$rhsp)}",	"replaceNum(nodep,1)")
	if (m_doNConst && operandsSame(nodep->lhsp(),nodep->rhsp())) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstEq operandsSame($lhsp,,$rhsp) , replaceNum(nodep,1) )\n");
	    replaceNum(nodep,1);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Eq_3(AstEq* nodep) {
	// TREEOPV("AstEq    {$rhsp.width1, $lhsp.isZero,    $rhsp}",	"AstNot{$rhsp}")
	if (m_doV && nodep->rhsp()->width1() && nodep->lhsp()->isZero()) {
	    UINFO(7,(void*)(nodep)<<" TREEOPV( AstEq $rhsp.width1, $lhsp.isZero, $rhsp , AstNot $rhsp )\n");
	    AstNode* arg1p = nodep->rhsp()->unlinkFrBack();
AstNode* newp = new AstNot(nodep->fileline(), arg1p);
nodep->replaceWith(newp);nodep->deleteTree(); VL_DANGLING(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Eq_4(AstEq* nodep) {
	// TREEOPV("AstEq    {$lhsp.width1, $lhsp, $rhsp.isZero}",	"AstNot{$lhsp}")
	if (m_doV && nodep->lhsp()->width1() && nodep->rhsp()->isZero()) {
	    UINFO(7,(void*)(nodep)<<" TREEOPV( AstEq $lhsp.width1, $lhsp, $rhsp.isZero , AstNot $lhsp )\n");
	    AstNode* arg1p = nodep->lhsp()->unlinkFrBack();
AstNode* newp = new AstNot(nodep->fileline(), arg1p);
nodep->replaceWith(newp);nodep->deleteTree(); VL_DANGLING(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Eq_5(AstEq* nodep) {
	// TREEOPV("AstEq    {$rhsp.width1, $lhsp.isAllOnes, $rhsp}",	"replaceWRhs(nodep)")
	if (m_doV && nodep->rhsp()->width1() && nodep->lhsp()->isAllOnes()) {
	    UINFO(7,(void*)(nodep)<<" TREEOPV( AstEq $rhsp.width1, $lhsp.isAllOnes, $rhsp , replaceWRhs(nodep) )\n");
	    replaceWRhs(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Eq_6(AstEq* nodep) {
	// TREEOPV("AstEq    {$lhsp.width1, $lhsp, $rhsp.isAllOnes}",	"replaceWLhs(nodep)")
	if (m_doV && nodep->lhsp()->width1() && nodep->rhsp()->isAllOnes()) {
	    UINFO(7,(void*)(nodep)<<" TREEOPV( AstEq $lhsp.width1, $lhsp, $rhsp.isAllOnes , replaceWLhs(nodep) )\n");
	    replaceWLhs(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_EqCase_0(AstEqCase* nodep) {
	// TREEOP ("AstEqCase {operandsSame($lhsp,,$rhsp)}",	"replaceNum(nodep,1)")
	if (m_doNConst && operandsSame(nodep->lhsp(),nodep->rhsp())) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstEqCase operandsSame($lhsp,,$rhsp) , replaceNum(nodep,1) )\n");
	    replaceNum(nodep,1);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_EqD_0(AstEqD* nodep) {
	// TREEOP ("AstEqD    {operandsSame($lhsp,,$rhsp)}",	"replaceNum(nodep,1)")
	if (m_doNConst && operandsSame(nodep->lhsp(),nodep->rhsp())) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstEqD operandsSame($lhsp,,$rhsp) , replaceNum(nodep,1) )\n");
	    replaceNum(nodep,1);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_EqN_0(AstEqN* nodep) {
	// TREEOP ("AstEqN    {operandsSame($lhsp,,$rhsp)}",	"replaceNum(nodep,1)")
	if (m_doNConst && operandsSame(nodep->lhsp(),nodep->rhsp())) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstEqN operandsSame($lhsp,,$rhsp) , replaceNum(nodep,1) )\n");
	    replaceNum(nodep,1);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_EqWild_0(AstEqWild* nodep) {
	// TREEOP ("AstEqWild {operandsSame($lhsp,,$rhsp)}",	"replaceNum(nodep,1)")
	if (m_doNConst && operandsSame(nodep->lhsp(),nodep->rhsp())) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstEqWild operandsSame($lhsp,,$rhsp) , replaceNum(nodep,1) )\n");
	    replaceNum(nodep,1);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Extend_0(AstExtend* nodep) {
	// TREEOPV("AstExtend {$lhsp.castExtend}",		"replaceExtend(nodep, nodep->lhsp()->castExtend()->lhsp())")
	if (m_doV && nodep->lhsp()->castExtend()) {
	    UINFO(7,(void*)(nodep)<<" TREEOPV( AstExtend $lhsp.castExtend , replaceExtend(nodep, nodep->lhsp()->castExtend()->lhsp()) )\n");
	    replaceExtend(nodep, nodep->lhsp()->castExtend()->lhsp());
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_ExtendS_0(AstExtendS* nodep) {
	// TREEOPV("AstExtendS{$lhsp.castExtendS}",		"replaceExtend(nodep, nodep->lhsp()->castExtendS()->lhsp())")
	if (m_doV && nodep->lhsp()->castExtendS()) {
	    UINFO(7,(void*)(nodep)<<" TREEOPV( AstExtendS $lhsp.castExtendS , replaceExtend(nodep, nodep->lhsp()->castExtendS()->lhsp()) )\n");
	    replaceExtend(nodep, nodep->lhsp()->castExtendS()->lhsp());
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Gt_0(AstGt* nodep) {
	// TREEOP ("AstGt   {!$lhsp.castConst,$rhsp.castConst}",	"AstLt  {$rhsp,$lhsp}")
	if (m_doNConst && !nodep->lhsp()->castConst() && nodep->rhsp()->castConst()) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstGt !$lhsp.castConst,$rhsp.castConst , AstLt $rhsp,$lhsp )\n");
	    AstNode* arg1p = nodep->rhsp()->unlinkFrBack();
AstNode* arg2p = nodep->lhsp()->unlinkFrBack();
AstNode* newp = new AstLt(nodep->fileline(), arg1p, arg2p);
nodep->replaceWith(newp);nodep->deleteTree(); VL_DANGLING(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Gt_1(AstGt* nodep) {
	// TREEOP1("AstGt   {$lhsp.isZero, $rhsp}",		"replaceNumSigned(nodep,0)")
	if (m_doNConst && nodep->lhsp()->isZero()) {
	    UINFO(7,(void*)(nodep)<<" TREEOP1( AstGt $lhsp.isZero, $rhsp , replaceNumSigned(nodep,0) )\n");
	    replaceNumSigned(nodep,0);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Gt_2(AstGt* nodep) {
	// TREEOP1("AstGt   {$lhsp, $rhsp.isAllOnes, $lhsp->width()==$rhsp->width()}",  "replaceNumLimited(nodep,0)")
	if (m_doNConst && nodep->rhsp()->isAllOnes() && nodep->lhsp()->width()==nodep->rhsp()->width()) {
	    UINFO(7,(void*)(nodep)<<" TREEOP1( AstGt $lhsp, $rhsp.isAllOnes, $lhsp->width()==$rhsp->width() , replaceNumLimited(nodep,0) )\n");
	    replaceNumLimited(nodep,0);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Gt_3(AstGt* nodep) {
	// TREEOPV("AstGt    {$rhsp.castExtend,operandBiExtendConstShrink(nodep)}",	"DONE")
	if (m_doV && nodep->rhsp()->castExtend() && operandBiExtendConstShrink(nodep)) {
	    UINFO(7,(void*)(nodep)<<" TREEOPV( AstGt $rhsp.castExtend,operandBiExtendConstShrink(nodep) , DONE )\n");
	    
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Gt_4(AstGt* nodep) {
	// TREEOPV("AstGt    {$rhsp.castExtend,operandBiExtendConstOver(nodep)}",	"replaceNum(nodep,1)")
	if (m_doV && nodep->rhsp()->castExtend() && operandBiExtendConstOver(nodep)) {
	    UINFO(7,(void*)(nodep)<<" TREEOPV( AstGt $rhsp.castExtend,operandBiExtendConstOver(nodep) , replaceNum(nodep,1) )\n");
	    replaceNum(nodep,1);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Gt_5(AstGt* nodep) {
	// TREEOP ("AstGt     {operandsSame($lhsp,,$rhsp)}",	"replaceZero(nodep)")
	if (m_doNConst && operandsSame(nodep->lhsp(),nodep->rhsp())) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstGt operandsSame($lhsp,,$rhsp) , replaceZero(nodep) )\n");
	    replaceZero(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Gt_6(AstGt* nodep) {
	// TREEOPV("AstGt    {$lhsp.width1, $lhsp, $rhsp.isZero}",	"replaceWLhs(nodep)")
	if (m_doV && nodep->lhsp()->width1() && nodep->rhsp()->isZero()) {
	    UINFO(7,(void*)(nodep)<<" TREEOPV( AstGt $lhsp.width1, $lhsp, $rhsp.isZero , replaceWLhs(nodep) )\n");
	    replaceWLhs(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_GtD_0(AstGtD* nodep) {
	// TREEOP ("AstGtD    {operandsSame($lhsp,,$rhsp)}",	"replaceZero(nodep)")
	if (m_doNConst && operandsSame(nodep->lhsp(),nodep->rhsp())) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstGtD operandsSame($lhsp,,$rhsp) , replaceZero(nodep) )\n");
	    replaceZero(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_GtN_0(AstGtN* nodep) {
	// TREEOP ("AstGtN    {operandsSame($lhsp,,$rhsp)}",	"replaceZero(nodep)")
	if (m_doNConst && operandsSame(nodep->lhsp(),nodep->rhsp())) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstGtN operandsSame($lhsp,,$rhsp) , replaceZero(nodep) )\n");
	    replaceZero(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_GtS_0(AstGtS* nodep) {
	// TREEOP ("AstGtS  {!$lhsp.castConst,$rhsp.castConst}",	"AstLtS {$rhsp,$lhsp}")
	if (m_doNConst && !nodep->lhsp()->castConst() && nodep->rhsp()->castConst()) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstGtS !$lhsp.castConst,$rhsp.castConst , AstLtS $rhsp,$lhsp )\n");
	    AstNode* arg1p = nodep->rhsp()->unlinkFrBack();
AstNode* arg2p = nodep->lhsp()->unlinkFrBack();
AstNode* newp = new AstLtS(nodep->fileline(), arg1p, arg2p);
nodep->replaceWith(newp);nodep->deleteTree(); VL_DANGLING(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_GtS_1(AstGtS* nodep) {
	// TREEOP ("AstGtS    {operandsSame($lhsp,,$rhsp)}",	"replaceZero(nodep)")
	if (m_doNConst && operandsSame(nodep->lhsp(),nodep->rhsp())) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstGtS operandsSame($lhsp,,$rhsp) , replaceZero(nodep) )\n");
	    replaceZero(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Gte_0(AstGte* nodep) {
	// TREEOP ("AstGte  {!$lhsp.castConst,$rhsp.castConst}",	"AstLte {$rhsp,$lhsp}")
	if (m_doNConst && !nodep->lhsp()->castConst() && nodep->rhsp()->castConst()) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstGte !$lhsp.castConst,$rhsp.castConst , AstLte $rhsp,$lhsp )\n");
	    AstNode* arg1p = nodep->rhsp()->unlinkFrBack();
AstNode* arg2p = nodep->lhsp()->unlinkFrBack();
AstNode* newp = new AstLte(nodep->fileline(), arg1p, arg2p);
nodep->replaceWith(newp);nodep->deleteTree(); VL_DANGLING(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Gte_1(AstGte* nodep) {
	// TREEOP1("AstGte  {$lhsp, $rhsp.isZero}",		"replaceNumSigned(nodep,1)")
	if (m_doNConst && nodep->rhsp()->isZero()) {
	    UINFO(7,(void*)(nodep)<<" TREEOP1( AstGte $lhsp, $rhsp.isZero , replaceNumSigned(nodep,1) )\n");
	    replaceNumSigned(nodep,1);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Gte_2(AstGte* nodep) {
	// TREEOP1("AstGte  {$lhsp.isAllOnes, $rhsp, $lhsp->width()==$rhsp->width()}",  "replaceNumLimited(nodep,1)")
	if (m_doNConst && nodep->lhsp()->isAllOnes() && nodep->lhsp()->width()==nodep->rhsp()->width()) {
	    UINFO(7,(void*)(nodep)<<" TREEOP1( AstGte $lhsp.isAllOnes, $rhsp, $lhsp->width()==$rhsp->width() , replaceNumLimited(nodep,1) )\n");
	    replaceNumLimited(nodep,1);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Gte_3(AstGte* nodep) {
	// TREEOPV("AstGte   {$rhsp.castExtend,operandBiExtendConstShrink(nodep)}",	"DONE")
	if (m_doV && nodep->rhsp()->castExtend() && operandBiExtendConstShrink(nodep)) {
	    UINFO(7,(void*)(nodep)<<" TREEOPV( AstGte $rhsp.castExtend,operandBiExtendConstShrink(nodep) , DONE )\n");
	    
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Gte_4(AstGte* nodep) {
	// TREEOPV("AstGte   {$rhsp.castExtend,operandBiExtendConstOver(nodep)}",	"replaceNum(nodep,1)")
	if (m_doV && nodep->rhsp()->castExtend() && operandBiExtendConstOver(nodep)) {
	    UINFO(7,(void*)(nodep)<<" TREEOPV( AstGte $rhsp.castExtend,operandBiExtendConstOver(nodep) , replaceNum(nodep,1) )\n");
	    replaceNum(nodep,1);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Gte_5(AstGte* nodep) {
	// TREEOP ("AstGte    {operandsSame($lhsp,,$rhsp)}",	"replaceNum(nodep,1)")
	if (m_doNConst && operandsSame(nodep->lhsp(),nodep->rhsp())) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstGte operandsSame($lhsp,,$rhsp) , replaceNum(nodep,1) )\n");
	    replaceNum(nodep,1);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_GteD_0(AstGteD* nodep) {
	// TREEOP ("AstGteD   {operandsSame($lhsp,,$rhsp)}",	"replaceNum(nodep,1)")
	if (m_doNConst && operandsSame(nodep->lhsp(),nodep->rhsp())) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstGteD operandsSame($lhsp,,$rhsp) , replaceNum(nodep,1) )\n");
	    replaceNum(nodep,1);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_GteN_0(AstGteN* nodep) {
	// TREEOP ("AstGteN   {operandsSame($lhsp,,$rhsp)}",	"replaceNum(nodep,1)")
	if (m_doNConst && operandsSame(nodep->lhsp(),nodep->rhsp())) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstGteN operandsSame($lhsp,,$rhsp) , replaceNum(nodep,1) )\n");
	    replaceNum(nodep,1);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_GteS_0(AstGteS* nodep) {
	// TREEOP ("AstGteS {!$lhsp.castConst,$rhsp.castConst}",	"AstLteS{$rhsp,$lhsp}")
	if (m_doNConst && !nodep->lhsp()->castConst() && nodep->rhsp()->castConst()) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstGteS !$lhsp.castConst,$rhsp.castConst , AstLteS $rhsp,$lhsp )\n");
	    AstNode* arg1p = nodep->rhsp()->unlinkFrBack();
AstNode* arg2p = nodep->lhsp()->unlinkFrBack();
AstNode* newp = new AstLteS(nodep->fileline(), arg1p, arg2p);
nodep->replaceWith(newp);nodep->deleteTree(); VL_DANGLING(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_GteS_1(AstGteS* nodep) {
	// TREEOP ("AstGteS   {operandsSame($lhsp,,$rhsp)}",	"replaceNum(nodep,1)")
	if (m_doNConst && operandsSame(nodep->lhsp(),nodep->rhsp())) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstGteS operandsSame($lhsp,,$rhsp) , replaceNum(nodep,1) )\n");
	    replaceNum(nodep,1);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_LogAnd_0(AstLogAnd* nodep) {
	// TREEOPS("AstLogAnd   {$lhsp.isZero}",	"replaceZero(nodep)")
	if (m_doNConst && nodep->lhsp()->isZero()) {
	    UINFO(7,(void*)(nodep)<<" TREEOPS( AstLogAnd $lhsp.isZero , replaceZero(nodep) )\n");
	    replaceZero(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_LogAnd_1(AstLogAnd* nodep) {
	// TREEOP ("AstLogAnd{$lhsp.isZero, $rhsp}",	"replaceZero(nodep)")
	if (m_doNConst && nodep->lhsp()->isZero()) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstLogAnd $lhsp.isZero, $rhsp , replaceZero(nodep) )\n");
	    replaceZero(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_LogAnd_2(AstLogAnd* nodep) {
	// TREEOP ("AstLogAnd{$lhsp, $rhsp.isZero}",	"replaceZeroChkPure(nodep,$lhsp)")
	if (m_doNConst && nodep->rhsp()->isZero()) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstLogAnd $lhsp, $rhsp.isZero , replaceZeroChkPure(nodep,$lhsp) )\n");
	    replaceZeroChkPure(nodep,nodep->lhsp());
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_LogAnd_3(AstLogAnd* nodep) {
	// TREEOP ("AstLogAnd{$lhsp.isNeqZero, $rhsp}",	"replaceWRhs(nodep)")
	if (m_doNConst && nodep->lhsp()->isNeqZero()) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstLogAnd $lhsp.isNeqZero, $rhsp , replaceWRhs(nodep) )\n");
	    replaceWRhs(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_LogAnd_4(AstLogAnd* nodep) {
	// TREEOP ("AstLogAnd{$lhsp, $rhsp.isNeqZero}",	"replaceWLhs(nodep)")
	if (m_doNConst && nodep->rhsp()->isNeqZero()) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstLogAnd $lhsp, $rhsp.isNeqZero , replaceWLhs(nodep) )\n");
	    replaceWLhs(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_LogAnd_5(AstLogAnd* nodep) {
	// TREEOP ("AstLogAnd {operandsSame($lhsp,,$rhsp), $lhsp.width1}",	"replaceWLhs(nodep)")
	if (m_doNConst && operandsSame(nodep->lhsp(),nodep->rhsp()) && nodep->lhsp()->width1()) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstLogAnd operandsSame($lhsp,,$rhsp), $lhsp.width1 , replaceWLhs(nodep) )\n");
	    replaceWLhs(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_LogAnd_6(AstLogAnd* nodep) {
	// TREEOPV("AstLogAnd{$lhsp.width1, $rhsp.width1, isTPure($lhsp), isTPure($rhsp)}", "AstAnd{$lhsp,$rhsp}")
	if (m_doV && nodep->lhsp()->width1() && nodep->rhsp()->width1() && isTPure(nodep->lhsp()) && isTPure(nodep->rhsp())) {
	    UINFO(7,(void*)(nodep)<<" TREEOPV( AstLogAnd $lhsp.width1, $rhsp.width1, isTPure($lhsp), isTPure($rhsp) , AstAnd $lhsp,$rhsp )\n");
	    AstNode* arg1p = nodep->lhsp()->unlinkFrBack();
AstNode* arg2p = nodep->rhsp()->unlinkFrBack();
AstNode* newp = new AstAnd(nodep->fileline(), arg1p, arg2p);
nodep->replaceWith(newp);nodep->deleteTree(); VL_DANGLING(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_LogIf_0(AstLogIf* nodep) {
	// TREEOPS("AstLogIf {$lhsp.isZero}",		"replaceNum(nodep, 1)")
	if (m_doNConst && nodep->lhsp()->isZero()) {
	    UINFO(7,(void*)(nodep)<<" TREEOPS( AstLogIf $lhsp.isZero , replaceNum(nodep, 1) )\n");
	    replaceNum(nodep, 1);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_LogIf_1(AstLogIf* nodep) {
	// TREEOPV("AstLogIf {$lhsp, $rhsp}",		"AstLogOr{AstLogNot{$lhsp},$rhsp}")
	if (m_doV) {
	    UINFO(7,(void*)(nodep)<<" TREEOPV( AstLogIf $lhsp, $rhsp , AstLogOr AstLogNot $lhsp ,$rhsp )\n");
	    AstNode* arg1p = nodep->lhsp()->unlinkFrBack();
AstNode* arg2p = nodep->rhsp()->unlinkFrBack();
AstNode* newp = new AstLogOr(nodep->fileline(), new AstLogNot(nodep->fileline(), arg1p), arg2p);
nodep->replaceWith(newp);nodep->deleteTree(); VL_DANGLING(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_LogIff_0(AstLogIff* nodep) {
	// TREEOPV("AstLogIff{$lhsp, $rhsp}",		"AstLogNot{AstXor{$lhsp,$rhsp}}")
	if (m_doV) {
	    UINFO(7,(void*)(nodep)<<" TREEOPV( AstLogIff $lhsp, $rhsp , AstLogNot AstXor $lhsp,$rhsp )\n");
	    AstNode* arg1p = nodep->lhsp()->unlinkFrBack();
AstNode* arg2p = nodep->rhsp()->unlinkFrBack();
AstNode* newp = new AstLogNot(nodep->fileline(), new AstXor(nodep->fileline(), arg1p, arg2p));
nodep->replaceWith(newp);nodep->deleteTree(); VL_DANGLING(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_LogNot_0(AstLogNot* nodep) {
	// TREEOP ("AstLogNot{$lhsp.castLogNot}",		"replaceWChild(nodep, $lhsp->op1p())")
	if (m_doNConst && nodep->lhsp()->castLogNot()) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstLogNot $lhsp.castLogNot , replaceWChild(nodep, $lhsp->op1p()) )\n");
	    replaceWChild(nodep, nodep->lhsp()->op1p());
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_LogNot_1(AstLogNot* nodep) {
	// TREEOP ("AstLogNot{$lhsp.castEqCase}",		"AstNeqCase{$lhsp->op1p(),$lhsp->op2p()}")
	if (m_doNConst && nodep->lhsp()->castEqCase()) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstLogNot $lhsp.castEqCase , AstNeqCase $lhsp->op1p(),$lhsp->op2p() )\n");
	    AstNode* arg1p = nodep->lhsp()->op1p()->unlinkFrBack();
AstNode* arg2p = nodep->lhsp()->op2p()->unlinkFrBack();
AstNode* newp = new AstNeqCase(nodep->fileline(), arg1p, arg2p);
nodep->replaceWith(newp);nodep->deleteTree(); VL_DANGLING(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_LogNot_2(AstLogNot* nodep) {
	// TREEOP ("AstLogNot{$lhsp.castNeqCase}",		"AstEqCase {$lhsp->op1p(),$lhsp->op2p()}")
	if (m_doNConst && nodep->lhsp()->castNeqCase()) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstLogNot $lhsp.castNeqCase , AstEqCase $lhsp->op1p(),$lhsp->op2p() )\n");
	    AstNode* arg1p = nodep->lhsp()->op1p()->unlinkFrBack();
AstNode* arg2p = nodep->lhsp()->op2p()->unlinkFrBack();
AstNode* newp = new AstEqCase(nodep->fileline(), arg1p, arg2p);
nodep->replaceWith(newp);nodep->deleteTree(); VL_DANGLING(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_LogNot_3(AstLogNot* nodep) {
	// TREEOP ("AstLogNot{$lhsp.castEqWild}",		"AstNeqWild{$lhsp->op1p(),$lhsp->op2p()}")
	if (m_doNConst && nodep->lhsp()->castEqWild()) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstLogNot $lhsp.castEqWild , AstNeqWild $lhsp->op1p(),$lhsp->op2p() )\n");
	    AstNode* arg1p = nodep->lhsp()->op1p()->unlinkFrBack();
AstNode* arg2p = nodep->lhsp()->op2p()->unlinkFrBack();
AstNode* newp = new AstNeqWild(nodep->fileline(), arg1p, arg2p);
nodep->replaceWith(newp);nodep->deleteTree(); VL_DANGLING(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_LogNot_4(AstLogNot* nodep) {
	// TREEOP ("AstLogNot{$lhsp.castNeqWild}",		"AstEqWild {$lhsp->op1p(),$lhsp->op2p()}")
	if (m_doNConst && nodep->lhsp()->castNeqWild()) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstLogNot $lhsp.castNeqWild , AstEqWild $lhsp->op1p(),$lhsp->op2p() )\n");
	    AstNode* arg1p = nodep->lhsp()->op1p()->unlinkFrBack();
AstNode* arg2p = nodep->lhsp()->op2p()->unlinkFrBack();
AstNode* newp = new AstEqWild(nodep->fileline(), arg1p, arg2p);
nodep->replaceWith(newp);nodep->deleteTree(); VL_DANGLING(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_LogNot_5(AstLogNot* nodep) {
	// TREEOP ("AstLogNot{$lhsp.castEq}",			"AstNeq {$lhsp->op1p(),$lhsp->op2p()}")
	if (m_doNConst && nodep->lhsp()->castEq()) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstLogNot $lhsp.castEq , AstNeq $lhsp->op1p(),$lhsp->op2p() )\n");
	    AstNode* arg1p = nodep->lhsp()->op1p()->unlinkFrBack();
AstNode* arg2p = nodep->lhsp()->op2p()->unlinkFrBack();
AstNode* newp = new AstNeq(nodep->fileline(), arg1p, arg2p);
nodep->replaceWith(newp);nodep->deleteTree(); VL_DANGLING(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_LogNot_6(AstLogNot* nodep) {
	// TREEOP ("AstLogNot{$lhsp.castNeq}",			"AstEq  {$lhsp->op1p(),$lhsp->op2p()}")
	if (m_doNConst && nodep->lhsp()->castNeq()) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstLogNot $lhsp.castNeq , AstEq $lhsp->op1p(),$lhsp->op2p() )\n");
	    AstNode* arg1p = nodep->lhsp()->op1p()->unlinkFrBack();
AstNode* arg2p = nodep->lhsp()->op2p()->unlinkFrBack();
AstNode* newp = new AstEq(nodep->fileline(), arg1p, arg2p);
nodep->replaceWith(newp);nodep->deleteTree(); VL_DANGLING(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_LogNot_7(AstLogNot* nodep) {
	// TREEOP ("AstLogNot{$lhsp.castLt}",			"AstGte {$lhsp->op1p(),$lhsp->op2p()}")
	if (m_doNConst && nodep->lhsp()->castLt()) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstLogNot $lhsp.castLt , AstGte $lhsp->op1p(),$lhsp->op2p() )\n");
	    AstNode* arg1p = nodep->lhsp()->op1p()->unlinkFrBack();
AstNode* arg2p = nodep->lhsp()->op2p()->unlinkFrBack();
AstNode* newp = new AstGte(nodep->fileline(), arg1p, arg2p);
nodep->replaceWith(newp);nodep->deleteTree(); VL_DANGLING(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_LogNot_8(AstLogNot* nodep) {
	// TREEOP ("AstLogNot{$lhsp.castLtS}",			"AstGteS{$lhsp->op1p(),$lhsp->op2p()}")
	if (m_doNConst && nodep->lhsp()->castLtS()) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstLogNot $lhsp.castLtS , AstGteS $lhsp->op1p(),$lhsp->op2p() )\n");
	    AstNode* arg1p = nodep->lhsp()->op1p()->unlinkFrBack();
AstNode* arg2p = nodep->lhsp()->op2p()->unlinkFrBack();
AstNode* newp = new AstGteS(nodep->fileline(), arg1p, arg2p);
nodep->replaceWith(newp);nodep->deleteTree(); VL_DANGLING(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_LogNot_9(AstLogNot* nodep) {
	// TREEOP ("AstLogNot{$lhsp.castLte}",			"AstGt  {$lhsp->op1p(),$lhsp->op2p()}")
	if (m_doNConst && nodep->lhsp()->castLte()) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstLogNot $lhsp.castLte , AstGt $lhsp->op1p(),$lhsp->op2p() )\n");
	    AstNode* arg1p = nodep->lhsp()->op1p()->unlinkFrBack();
AstNode* arg2p = nodep->lhsp()->op2p()->unlinkFrBack();
AstNode* newp = new AstGt(nodep->fileline(), arg1p, arg2p);
nodep->replaceWith(newp);nodep->deleteTree(); VL_DANGLING(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_LogNot_10(AstLogNot* nodep) {
	// TREEOP ("AstLogNot{$lhsp.castLteS}",		"AstGtS {$lhsp->op1p(),$lhsp->op2p()}")
	if (m_doNConst && nodep->lhsp()->castLteS()) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstLogNot $lhsp.castLteS , AstGtS $lhsp->op1p(),$lhsp->op2p() )\n");
	    AstNode* arg1p = nodep->lhsp()->op1p()->unlinkFrBack();
AstNode* arg2p = nodep->lhsp()->op2p()->unlinkFrBack();
AstNode* newp = new AstGtS(nodep->fileline(), arg1p, arg2p);
nodep->replaceWith(newp);nodep->deleteTree(); VL_DANGLING(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_LogNot_11(AstLogNot* nodep) {
	// TREEOP ("AstLogNot{$lhsp.castGt}",			"AstLte {$lhsp->op1p(),$lhsp->op2p()}")
	if (m_doNConst && nodep->lhsp()->castGt()) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstLogNot $lhsp.castGt , AstLte $lhsp->op1p(),$lhsp->op2p() )\n");
	    AstNode* arg1p = nodep->lhsp()->op1p()->unlinkFrBack();
AstNode* arg2p = nodep->lhsp()->op2p()->unlinkFrBack();
AstNode* newp = new AstLte(nodep->fileline(), arg1p, arg2p);
nodep->replaceWith(newp);nodep->deleteTree(); VL_DANGLING(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_LogNot_12(AstLogNot* nodep) {
	// TREEOP ("AstLogNot{$lhsp.castGtS}",			"AstLteS{$lhsp->op1p(),$lhsp->op2p()}")
	if (m_doNConst && nodep->lhsp()->castGtS()) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstLogNot $lhsp.castGtS , AstLteS $lhsp->op1p(),$lhsp->op2p() )\n");
	    AstNode* arg1p = nodep->lhsp()->op1p()->unlinkFrBack();
AstNode* arg2p = nodep->lhsp()->op2p()->unlinkFrBack();
AstNode* newp = new AstLteS(nodep->fileline(), arg1p, arg2p);
nodep->replaceWith(newp);nodep->deleteTree(); VL_DANGLING(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_LogNot_13(AstLogNot* nodep) {
	// TREEOP ("AstLogNot{$lhsp.castGte}",			"AstLt  {$lhsp->op1p(),$lhsp->op2p()}")
	if (m_doNConst && nodep->lhsp()->castGte()) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstLogNot $lhsp.castGte , AstLt $lhsp->op1p(),$lhsp->op2p() )\n");
	    AstNode* arg1p = nodep->lhsp()->op1p()->unlinkFrBack();
AstNode* arg2p = nodep->lhsp()->op2p()->unlinkFrBack();
AstNode* newp = new AstLt(nodep->fileline(), arg1p, arg2p);
nodep->replaceWith(newp);nodep->deleteTree(); VL_DANGLING(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_LogNot_14(AstLogNot* nodep) {
	// TREEOP ("AstLogNot{$lhsp.castGteS}",		"AstLtS {$lhsp->op1p(),$lhsp->op2p()}")
	if (m_doNConst && nodep->lhsp()->castGteS()) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstLogNot $lhsp.castGteS , AstLtS $lhsp->op1p(),$lhsp->op2p() )\n");
	    AstNode* arg1p = nodep->lhsp()->op1p()->unlinkFrBack();
AstNode* arg2p = nodep->lhsp()->op2p()->unlinkFrBack();
AstNode* newp = new AstLtS(nodep->fileline(), arg1p, arg2p);
nodep->replaceWith(newp);nodep->deleteTree(); VL_DANGLING(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_LogNot_15(AstLogNot* nodep) {
	// TREEOPV("AstLogNot{$lhsp.width1, isTPure($lhsp)}",	"AstNot{$lhsp}")
	if (m_doV && nodep->lhsp()->width1() && isTPure(nodep->lhsp())) {
	    UINFO(7,(void*)(nodep)<<" TREEOPV( AstLogNot $lhsp.width1, isTPure($lhsp) , AstNot $lhsp )\n");
	    AstNode* arg1p = nodep->lhsp()->unlinkFrBack();
AstNode* newp = new AstNot(nodep->fileline(), arg1p);
nodep->replaceWith(newp);nodep->deleteTree(); VL_DANGLING(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_LogOr_0(AstLogOr* nodep) {
	// TREEOPS("AstLogOr   {$lhsp.isOne}",		"replaceNum(nodep, 1)")
	if (m_doNConst && nodep->lhsp()->isOne()) {
	    UINFO(7,(void*)(nodep)<<" TREEOPS( AstLogOr $lhsp.isOne , replaceNum(nodep, 1) )\n");
	    replaceNum(nodep, 1);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_LogOr_1(AstLogOr* nodep) {
	// TREEOP ("AstLogOr {$lhsp.isZero, $rhsp}",	"replaceWRhs(nodep)")
	if (m_doNConst && nodep->lhsp()->isZero()) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstLogOr $lhsp.isZero, $rhsp , replaceWRhs(nodep) )\n");
	    replaceWRhs(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_LogOr_2(AstLogOr* nodep) {
	// TREEOP ("AstLogOr {$lhsp, $rhsp.isZero}",	"replaceWLhs(nodep)")
	if (m_doNConst && nodep->rhsp()->isZero()) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstLogOr $lhsp, $rhsp.isZero , replaceWLhs(nodep) )\n");
	    replaceWLhs(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_LogOr_3(AstLogOr* nodep) {
	// TREEOP ("AstLogOr {$lhsp.isNeqZero, $rhsp}",	"replaceNum(nodep,1)")
	if (m_doNConst && nodep->lhsp()->isNeqZero()) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstLogOr $lhsp.isNeqZero, $rhsp , replaceNum(nodep,1) )\n");
	    replaceNum(nodep,1);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_LogOr_4(AstLogOr* nodep) {
	// TREEOP ("AstLogOr {$lhsp, $rhsp.isNeqZero, isTPure($lhsp)}",	"replaceNum(nodep,1)")
	if (m_doNConst && nodep->rhsp()->isNeqZero() && isTPure(nodep->lhsp())) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstLogOr $lhsp, $rhsp.isNeqZero, isTPure($lhsp) , replaceNum(nodep,1) )\n");
	    replaceNum(nodep,1);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_LogOr_5(AstLogOr* nodep) {
	// TREEOP ("AstLogOr  {operandsSame($lhsp,,$rhsp), $lhsp.width1}",	"replaceWLhs(nodep)")
	if (m_doNConst && operandsSame(nodep->lhsp(),nodep->rhsp()) && nodep->lhsp()->width1()) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstLogOr operandsSame($lhsp,,$rhsp), $lhsp.width1 , replaceWLhs(nodep) )\n");
	    replaceWLhs(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_LogOr_6(AstLogOr* nodep) {
	// TREEOPV("AstLogOr {$lhsp.width1, $rhsp.width1, isTPure($lhsp), isTPure($rhsp)}", "AstOr{$lhsp,$rhsp}")
	if (m_doV && nodep->lhsp()->width1() && nodep->rhsp()->width1() && isTPure(nodep->lhsp()) && isTPure(nodep->rhsp())) {
	    UINFO(7,(void*)(nodep)<<" TREEOPV( AstLogOr $lhsp.width1, $rhsp.width1, isTPure($lhsp), isTPure($rhsp) , AstOr $lhsp,$rhsp )\n");
	    AstNode* arg1p = nodep->lhsp()->unlinkFrBack();
AstNode* arg2p = nodep->rhsp()->unlinkFrBack();
AstNode* newp = new AstOr(nodep->fileline(), arg1p, arg2p);
nodep->replaceWith(newp);nodep->deleteTree(); VL_DANGLING(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Lt_0(AstLt* nodep) {
	// TREEOP ("AstLt   {!$lhsp.castConst,$rhsp.castConst}",	"AstGt  {$rhsp,$lhsp}")
	if (m_doNConst && !nodep->lhsp()->castConst() && nodep->rhsp()->castConst()) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstLt !$lhsp.castConst,$rhsp.castConst , AstGt $rhsp,$lhsp )\n");
	    AstNode* arg1p = nodep->rhsp()->unlinkFrBack();
AstNode* arg2p = nodep->lhsp()->unlinkFrBack();
AstNode* newp = new AstGt(nodep->fileline(), arg1p, arg2p);
nodep->replaceWith(newp);nodep->deleteTree(); VL_DANGLING(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Lt_1(AstLt* nodep) {
	// TREEOP1("AstLt   {$lhsp, $rhsp.isZero}",		"replaceNumSigned(nodep,0)")
	if (m_doNConst && nodep->rhsp()->isZero()) {
	    UINFO(7,(void*)(nodep)<<" TREEOP1( AstLt $lhsp, $rhsp.isZero , replaceNumSigned(nodep,0) )\n");
	    replaceNumSigned(nodep,0);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Lt_2(AstLt* nodep) {
	// TREEOP1("AstLt   {$lhsp.isAllOnes, $rhsp, $lhsp->width()==$rhsp->width()}",  "replaceNumLimited(nodep,0)")
	if (m_doNConst && nodep->lhsp()->isAllOnes() && nodep->lhsp()->width()==nodep->rhsp()->width()) {
	    UINFO(7,(void*)(nodep)<<" TREEOP1( AstLt $lhsp.isAllOnes, $rhsp, $lhsp->width()==$rhsp->width() , replaceNumLimited(nodep,0) )\n");
	    replaceNumLimited(nodep,0);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Lt_3(AstLt* nodep) {
	// TREEOPV("AstLt    {$rhsp.castExtend,operandBiExtendConstShrink(nodep)}",	"DONE")
	if (m_doV && nodep->rhsp()->castExtend() && operandBiExtendConstShrink(nodep)) {
	    UINFO(7,(void*)(nodep)<<" TREEOPV( AstLt $rhsp.castExtend,operandBiExtendConstShrink(nodep) , DONE )\n");
	    
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Lt_4(AstLt* nodep) {
	// TREEOPV("AstLt    {$rhsp.castExtend,operandBiExtendConstOver(nodep)}",	"replaceZero(nodep)")
	if (m_doV && nodep->rhsp()->castExtend() && operandBiExtendConstOver(nodep)) {
	    UINFO(7,(void*)(nodep)<<" TREEOPV( AstLt $rhsp.castExtend,operandBiExtendConstOver(nodep) , replaceZero(nodep) )\n");
	    replaceZero(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Lt_5(AstLt* nodep) {
	// TREEOP ("AstLt     {operandsSame($lhsp,,$rhsp)}",	"replaceZero(nodep)")
	if (m_doNConst && operandsSame(nodep->lhsp(),nodep->rhsp())) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstLt operandsSame($lhsp,,$rhsp) , replaceZero(nodep) )\n");
	    replaceZero(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Lt_6(AstLt* nodep) {
	// TREEOPV("AstLt    {$rhsp.width1, $lhsp.isZero,    $rhsp}",	"replaceWRhs(nodep)")
	if (m_doV && nodep->rhsp()->width1() && nodep->lhsp()->isZero()) {
	    UINFO(7,(void*)(nodep)<<" TREEOPV( AstLt $rhsp.width1, $lhsp.isZero, $rhsp , replaceWRhs(nodep) )\n");
	    replaceWRhs(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_LtD_0(AstLtD* nodep) {
	// TREEOP ("AstLtD    {operandsSame($lhsp,,$rhsp)}",	"replaceZero(nodep)")
	if (m_doNConst && operandsSame(nodep->lhsp(),nodep->rhsp())) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstLtD operandsSame($lhsp,,$rhsp) , replaceZero(nodep) )\n");
	    replaceZero(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_LtN_0(AstLtN* nodep) {
	// TREEOP ("AstLtN    {operandsSame($lhsp,,$rhsp)}",	"replaceZero(nodep)")
	if (m_doNConst && operandsSame(nodep->lhsp(),nodep->rhsp())) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstLtN operandsSame($lhsp,,$rhsp) , replaceZero(nodep) )\n");
	    replaceZero(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_LtS_0(AstLtS* nodep) {
	// TREEOP ("AstLtS  {!$lhsp.castConst,$rhsp.castConst}",	"AstGtS {$rhsp,$lhsp}")
	if (m_doNConst && !nodep->lhsp()->castConst() && nodep->rhsp()->castConst()) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstLtS !$lhsp.castConst,$rhsp.castConst , AstGtS $rhsp,$lhsp )\n");
	    AstNode* arg1p = nodep->rhsp()->unlinkFrBack();
AstNode* arg2p = nodep->lhsp()->unlinkFrBack();
AstNode* newp = new AstGtS(nodep->fileline(), arg1p, arg2p);
nodep->replaceWith(newp);nodep->deleteTree(); VL_DANGLING(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_LtS_1(AstLtS* nodep) {
	// TREEOP ("AstLtS    {operandsSame($lhsp,,$rhsp)}",	"replaceZero(nodep)")
	if (m_doNConst && operandsSame(nodep->lhsp(),nodep->rhsp())) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstLtS operandsSame($lhsp,,$rhsp) , replaceZero(nodep) )\n");
	    replaceZero(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Lte_0(AstLte* nodep) {
	// TREEOP ("AstLte  {!$lhsp.castConst,$rhsp.castConst}",	"AstGte {$rhsp,$lhsp}")
	if (m_doNConst && !nodep->lhsp()->castConst() && nodep->rhsp()->castConst()) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstLte !$lhsp.castConst,$rhsp.castConst , AstGte $rhsp,$lhsp )\n");
	    AstNode* arg1p = nodep->rhsp()->unlinkFrBack();
AstNode* arg2p = nodep->lhsp()->unlinkFrBack();
AstNode* newp = new AstGte(nodep->fileline(), arg1p, arg2p);
nodep->replaceWith(newp);nodep->deleteTree(); VL_DANGLING(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Lte_1(AstLte* nodep) {
	// TREEOP1("AstLte  {$lhsp.isZero, $rhsp}",		"replaceNumSigned(nodep,1)")
	if (m_doNConst && nodep->lhsp()->isZero()) {
	    UINFO(7,(void*)(nodep)<<" TREEOP1( AstLte $lhsp.isZero, $rhsp , replaceNumSigned(nodep,1) )\n");
	    replaceNumSigned(nodep,1);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Lte_2(AstLte* nodep) {
	// TREEOP1("AstLte  {$lhsp, $rhsp.isAllOnes, $lhsp->width()==$rhsp->width()}",  "replaceNumLimited(nodep,1)")
	if (m_doNConst && nodep->rhsp()->isAllOnes() && nodep->lhsp()->width()==nodep->rhsp()->width()) {
	    UINFO(7,(void*)(nodep)<<" TREEOP1( AstLte $lhsp, $rhsp.isAllOnes, $lhsp->width()==$rhsp->width() , replaceNumLimited(nodep,1) )\n");
	    replaceNumLimited(nodep,1);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Lte_3(AstLte* nodep) {
	// TREEOPV("AstLte   {$rhsp.castExtend,operandBiExtendConstShrink(nodep)}",	"DONE")
	if (m_doV && nodep->rhsp()->castExtend() && operandBiExtendConstShrink(nodep)) {
	    UINFO(7,(void*)(nodep)<<" TREEOPV( AstLte $rhsp.castExtend,operandBiExtendConstShrink(nodep) , DONE )\n");
	    
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Lte_4(AstLte* nodep) {
	// TREEOPV("AstLte   {$rhsp.castExtend,operandBiExtendConstOver(nodep)}",	"replaceZero(nodep)")
	if (m_doV && nodep->rhsp()->castExtend() && operandBiExtendConstOver(nodep)) {
	    UINFO(7,(void*)(nodep)<<" TREEOPV( AstLte $rhsp.castExtend,operandBiExtendConstOver(nodep) , replaceZero(nodep) )\n");
	    replaceZero(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Lte_5(AstLte* nodep) {
	// TREEOP ("AstLte    {operandsSame($lhsp,,$rhsp)}",	"replaceNum(nodep,1)")
	if (m_doNConst && operandsSame(nodep->lhsp(),nodep->rhsp())) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstLte operandsSame($lhsp,,$rhsp) , replaceNum(nodep,1) )\n");
	    replaceNum(nodep,1);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Lte_6(AstLte* nodep) {
	// TREEOPV("AstLte   {$lhsp->width()==$rhsp->width(), $rhsp.isAllOnes}", "replaceNum(nodep,1)")
	if (m_doV && nodep->lhsp()->width()==nodep->rhsp()->width() && nodep->rhsp()->isAllOnes()) {
	    UINFO(7,(void*)(nodep)<<" TREEOPV( AstLte $lhsp->width()==$rhsp->width(), $rhsp.isAllOnes , replaceNum(nodep,1) )\n");
	    replaceNum(nodep,1);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_LteD_0(AstLteD* nodep) {
	// TREEOP ("AstLteD   {operandsSame($lhsp,,$rhsp)}",	"replaceNum(nodep,1)")
	if (m_doNConst && operandsSame(nodep->lhsp(),nodep->rhsp())) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstLteD operandsSame($lhsp,,$rhsp) , replaceNum(nodep,1) )\n");
	    replaceNum(nodep,1);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_LteN_0(AstLteN* nodep) {
	// TREEOP ("AstLteN   {operandsSame($lhsp,,$rhsp)}",	"replaceNum(nodep,1)")
	if (m_doNConst && operandsSame(nodep->lhsp(),nodep->rhsp())) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstLteN operandsSame($lhsp,,$rhsp) , replaceNum(nodep,1) )\n");
	    replaceNum(nodep,1);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_LteS_0(AstLteS* nodep) {
	// TREEOP ("AstLteS {!$lhsp.castConst,$rhsp.castConst}",	"AstGteS{$rhsp,$lhsp}")
	if (m_doNConst && !nodep->lhsp()->castConst() && nodep->rhsp()->castConst()) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstLteS !$lhsp.castConst,$rhsp.castConst , AstGteS $rhsp,$lhsp )\n");
	    AstNode* arg1p = nodep->rhsp()->unlinkFrBack();
AstNode* arg2p = nodep->lhsp()->unlinkFrBack();
AstNode* newp = new AstGteS(nodep->fileline(), arg1p, arg2p);
nodep->replaceWith(newp);nodep->deleteTree(); VL_DANGLING(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_LteS_1(AstLteS* nodep) {
	// TREEOP ("AstLteS   {operandsSame($lhsp,,$rhsp)}",	"replaceNum(nodep,1)")
	if (m_doNConst && operandsSame(nodep->lhsp(),nodep->rhsp())) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstLteS operandsSame($lhsp,,$rhsp) , replaceNum(nodep,1) )\n");
	    replaceNum(nodep,1);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Mul_0(AstMul* nodep) {
	// TREEOP ("AstMul   {$lhsp.isZero, $rhsp}",	"replaceZeroChkPure(nodep,$rhsp)")
	if (m_doNConst && nodep->lhsp()->isZero()) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstMul $lhsp.isZero, $rhsp , replaceZeroChkPure(nodep,$rhsp) )\n");
	    replaceZeroChkPure(nodep,nodep->rhsp());
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Mul_1(AstMul* nodep) {
	// TREEOP ("AstMul   {$lhsp, $rhsp.isZero}",	"replaceZeroChkPure(nodep,$lhsp)")
	if (m_doNConst && nodep->rhsp()->isZero()) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstMul $lhsp, $rhsp.isZero , replaceZeroChkPure(nodep,$lhsp) )\n");
	    replaceZeroChkPure(nodep,nodep->lhsp());
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Mul_2(AstMul* nodep) {
	// TREEOP ("AstMul   {$lhsp.isOne, $rhsp}",	"replaceWRhs(nodep)")
	if (m_doNConst && nodep->lhsp()->isOne()) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstMul $lhsp.isOne, $rhsp , replaceWRhs(nodep) )\n");
	    replaceWRhs(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Mul_3(AstMul* nodep) {
	// TREEOP ("AstMul   {operandIsPowTwo($lhsp), $rhsp}",	"replaceMulShift(nodep)")
	if (m_doNConst && operandIsPowTwo(nodep->lhsp())) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstMul operandIsPowTwo($lhsp), $rhsp , replaceMulShift(nodep) )\n");
	    replaceMulShift(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_MulS_0(AstMulS* nodep) {
	// TREEOP ("AstMulS  {$lhsp.isZero, $rhsp}",	"replaceZeroChkPure(nodep,$rhsp)")
	if (m_doNConst && nodep->lhsp()->isZero()) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstMulS $lhsp.isZero, $rhsp , replaceZeroChkPure(nodep,$rhsp) )\n");
	    replaceZeroChkPure(nodep,nodep->rhsp());
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_MulS_1(AstMulS* nodep) {
	// TREEOP ("AstMulS  {$lhsp, $rhsp.isZero}",	"replaceZeroChkPure(nodep,$lhsp)")
	if (m_doNConst && nodep->rhsp()->isZero()) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstMulS $lhsp, $rhsp.isZero , replaceZeroChkPure(nodep,$lhsp) )\n");
	    replaceZeroChkPure(nodep,nodep->lhsp());
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_MulS_2(AstMulS* nodep) {
	// TREEOP ("AstMulS  {$lhsp.isOne, $rhsp}",	"replaceWRhs(nodep)")
	if (m_doNConst && nodep->lhsp()->isOne()) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstMulS $lhsp.isOne, $rhsp , replaceWRhs(nodep) )\n");
	    replaceWRhs(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Neq_0(AstNeq* nodep) {
	// TREEOPV("AstNeq   {$rhsp.castExtend,operandBiExtendConstShrink(nodep)}",	"DONE")
	if (m_doV && nodep->rhsp()->castExtend() && operandBiExtendConstShrink(nodep)) {
	    UINFO(7,(void*)(nodep)<<" TREEOPV( AstNeq $rhsp.castExtend,operandBiExtendConstShrink(nodep) , DONE )\n");
	    
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Neq_1(AstNeq* nodep) {
	// TREEOPV("AstNeq   {$rhsp.castExtend,operandBiExtendConstOver(nodep)}",	"replaceNum(nodep,1)")
	if (m_doV && nodep->rhsp()->castExtend() && operandBiExtendConstOver(nodep)) {
	    UINFO(7,(void*)(nodep)<<" TREEOPV( AstNeq $rhsp.castExtend,operandBiExtendConstOver(nodep) , replaceNum(nodep,1) )\n");
	    replaceNum(nodep,1);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Neq_2(AstNeq* nodep) {
	// TREEOP ("AstNeq    {operandsSame($lhsp,,$rhsp)}",	"replaceZero(nodep)")
	if (m_doNConst && operandsSame(nodep->lhsp(),nodep->rhsp())) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstNeq operandsSame($lhsp,,$rhsp) , replaceZero(nodep) )\n");
	    replaceZero(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Neq_3(AstNeq* nodep) {
	// TREEOPV("AstNeq   {$rhsp.width1, $lhsp.isZero,    $rhsp}",	"replaceWRhs(nodep)")
	if (m_doV && nodep->rhsp()->width1() && nodep->lhsp()->isZero()) {
	    UINFO(7,(void*)(nodep)<<" TREEOPV( AstNeq $rhsp.width1, $lhsp.isZero, $rhsp , replaceWRhs(nodep) )\n");
	    replaceWRhs(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Neq_4(AstNeq* nodep) {
	// TREEOPV("AstNeq   {$lhsp.width1, $lhsp, $rhsp.isZero}",	"replaceWLhs(nodep)")
	if (m_doV && nodep->lhsp()->width1() && nodep->rhsp()->isZero()) {
	    UINFO(7,(void*)(nodep)<<" TREEOPV( AstNeq $lhsp.width1, $lhsp, $rhsp.isZero , replaceWLhs(nodep) )\n");
	    replaceWLhs(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Neq_5(AstNeq* nodep) {
	// TREEOPV("AstNeq   {$rhsp.width1, $lhsp.isAllOnes, $rhsp}",	"AstNot{$rhsp}")
	if (m_doV && nodep->rhsp()->width1() && nodep->lhsp()->isAllOnes()) {
	    UINFO(7,(void*)(nodep)<<" TREEOPV( AstNeq $rhsp.width1, $lhsp.isAllOnes, $rhsp , AstNot $rhsp )\n");
	    AstNode* arg1p = nodep->rhsp()->unlinkFrBack();
AstNode* newp = new AstNot(nodep->fileline(), arg1p);
nodep->replaceWith(newp);nodep->deleteTree(); VL_DANGLING(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Neq_6(AstNeq* nodep) {
	// TREEOPV("AstNeq   {$lhsp.width1, $lhsp, $rhsp.isAllOnes}",	"AstNot{$lhsp}")
	if (m_doV && nodep->lhsp()->width1() && nodep->rhsp()->isAllOnes()) {
	    UINFO(7,(void*)(nodep)<<" TREEOPV( AstNeq $lhsp.width1, $lhsp, $rhsp.isAllOnes , AstNot $lhsp )\n");
	    AstNode* arg1p = nodep->lhsp()->unlinkFrBack();
AstNode* newp = new AstNot(nodep->fileline(), arg1p);
nodep->replaceWith(newp);nodep->deleteTree(); VL_DANGLING(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_NeqCase_0(AstNeqCase* nodep) {
	// TREEOP ("AstNeqCase{operandsSame($lhsp,,$rhsp)}",	"replaceZero(nodep)")
	if (m_doNConst && operandsSame(nodep->lhsp(),nodep->rhsp())) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstNeqCase operandsSame($lhsp,,$rhsp) , replaceZero(nodep) )\n");
	    replaceZero(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_NeqD_0(AstNeqD* nodep) {
	// TREEOP ("AstNeqD   {operandsSame($lhsp,,$rhsp)}",	"replaceZero(nodep)")
	if (m_doNConst && operandsSame(nodep->lhsp(),nodep->rhsp())) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstNeqD operandsSame($lhsp,,$rhsp) , replaceZero(nodep) )\n");
	    replaceZero(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_NeqN_0(AstNeqN* nodep) {
	// TREEOP ("AstNeqN   {operandsSame($lhsp,,$rhsp)}",	"replaceZero(nodep)")
	if (m_doNConst && operandsSame(nodep->lhsp(),nodep->rhsp())) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstNeqN operandsSame($lhsp,,$rhsp) , replaceZero(nodep) )\n");
	    replaceZero(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_NeqWild_0(AstNeqWild* nodep) {
	// TREEOP ("AstNeqWild{operandsSame($lhsp,,$rhsp)}",	"replaceZero(nodep)")
	if (m_doNConst && operandsSame(nodep->lhsp(),nodep->rhsp())) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstNeqWild operandsSame($lhsp,,$rhsp) , replaceZero(nodep) )\n");
	    replaceZero(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_NodeBiCom_0(AstNodeBiCom* nodep) {
	// TREEOP ("AstNodeBiCom{!$lhsp.castConst, $rhsp.castConst}",	"swapSides(nodep)")
	if (m_doNConst && !nodep->lhsp()->castConst() && nodep->rhsp()->castConst()) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstNodeBiCom !$lhsp.castConst, $rhsp.castConst , swapSides(nodep) )\n");
	    swapSides(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_NodeBiComAsv_0(AstNodeBiComAsv* nodep) {
	// TREEOP ("AstNodeBiComAsv{operandAsvConst(nodep)}",	"replaceAsv(nodep)")
	if (m_doNConst && operandAsvConst(nodep)) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstNodeBiComAsv operandAsvConst(nodep) , replaceAsv(nodep) )\n");
	    replaceAsv(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_NodeBiComAsv_1(AstNodeBiComAsv* nodep) {
	// TREEOP ("AstNodeBiComAsv{operandAsvSame(nodep)}",	"replaceAsv(nodep)")
	if (m_doNConst && operandAsvSame(nodep)) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstNodeBiComAsv operandAsvSame(nodep) , replaceAsv(nodep) )\n");
	    replaceAsv(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_NodeBiComAsv_2(AstNodeBiComAsv* nodep) {
	// TREEOP ("AstNodeBiComAsv{operandAsvLUp(nodep)}",	"replaceAsvLUp(nodep)")
	if (m_doNConst && operandAsvLUp(nodep)) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstNodeBiComAsv operandAsvLUp(nodep) , replaceAsvLUp(nodep) )\n");
	    replaceAsvLUp(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_NodeBiComAsv_3(AstNodeBiComAsv* nodep) {
	// TREEOP ("AstNodeBiComAsv{operandAsvRUp(nodep)}",	"replaceAsvRUp(nodep)")
	if (m_doNConst && operandAsvRUp(nodep)) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstNodeBiComAsv operandAsvRUp(nodep) , replaceAsvRUp(nodep) )\n");
	    replaceAsvRUp(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_NodeBiop_0(AstNodeBiop* nodep) {
	// TREEOPC("AstNodeBiop {$lhsp.castConst, $rhsp.castConst}",  "replaceConst(nodep)")
	if (nodep->lhsp()->castConst() && nodep->rhsp()->castConst()) {
	    UINFO(7,(void*)(nodep)<<" TREEOPC( AstNodeBiop $lhsp.castConst, $rhsp.castConst , replaceConst(nodep) )\n");
	    replaceConst(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_NodeCond_0(AstNodeCond* nodep) {
	// TREEOP ("AstNodeCond{$condp.isZero,       $expr1p, $expr2p}", "replaceWChild(nodep,$expr2p)")
	if (m_doNConst && nodep->condp()->isZero()) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstNodeCond $condp.isZero, $expr1p, $expr2p , replaceWChild(nodep,$expr2p) )\n");
	    replaceWChild(nodep,nodep->expr2p());
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_NodeCond_1(AstNodeCond* nodep) {
	// TREEOP ("AstNodeCond{$condp.isNeqZero,    $expr1p, $expr2p}", "replaceWChild(nodep,$expr1p)")
	if (m_doNConst && nodep->condp()->isNeqZero()) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstNodeCond $condp.isNeqZero, $expr1p, $expr2p , replaceWChild(nodep,$expr1p) )\n");
	    replaceWChild(nodep,nodep->expr1p());
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_NodeCond_2(AstNodeCond* nodep) {
	// TREEOPC("AstNodeCond{$condp.isZero,       $expr1p.castConst, $expr2p.castConst}", "replaceWChild(nodep,$expr2p)")
	if (nodep->condp()->isZero() && nodep->expr1p()->castConst() && nodep->expr2p()->castConst()) {
	    UINFO(7,(void*)(nodep)<<" TREEOPC( AstNodeCond $condp.isZero, $expr1p.castConst, $expr2p.castConst , replaceWChild(nodep,$expr2p) )\n");
	    replaceWChild(nodep,nodep->expr2p());
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_NodeCond_3(AstNodeCond* nodep) {
	// TREEOPC("AstNodeCond{$condp.isNeqZero,    $expr1p.castConst, $expr2p.castConst}", "replaceWChild(nodep,$expr1p)")
	if (nodep->condp()->isNeqZero() && nodep->expr1p()->castConst() && nodep->expr2p()->castConst()) {
	    UINFO(7,(void*)(nodep)<<" TREEOPC( AstNodeCond $condp.isNeqZero, $expr1p.castConst, $expr2p.castConst , replaceWChild(nodep,$expr1p) )\n");
	    replaceWChild(nodep,nodep->expr1p());
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_NodeCond_4(AstNodeCond* nodep) {
	// TREEOP ("AstNodeCond{$condp, operandsSame($expr1p,,$expr2p)}","replaceWChild(nodep,$expr1p)")
	if (m_doNConst && operandsSame(nodep->expr1p(),nodep->expr2p())) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstNodeCond $condp, operandsSame($expr1p,,$expr2p) , replaceWChild(nodep,$expr1p) )\n");
	    replaceWChild(nodep,nodep->expr1p());
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_NodeCond_5(AstNodeCond* nodep) {
	// TREEOP ("AstNodeCond{$condp.width1, $expr1p.width1,   $expr1p.isAllOnes, $expr2p}", "AstLogOr {$condp, $expr2p}")
	if (m_doNConst && nodep->condp()->width1() && nodep->expr1p()->width1() && nodep->expr1p()->isAllOnes()) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstNodeCond $condp.width1, $expr1p.width1, $expr1p.isAllOnes, $expr2p , AstLogOr $condp, $expr2p )\n");
	    AstNode* arg1p = nodep->condp()->unlinkFrBack();
AstNode* arg2p = nodep->expr2p()->unlinkFrBack();
AstNode* newp = new AstLogOr(nodep->fileline(), arg1p, arg2p);
nodep->replaceWith(newp);nodep->deleteTree(); VL_DANGLING(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_NodeCond_6(AstNodeCond* nodep) {
	// TREEOP ("AstNodeCond{$condp.width1, $expr1p.width1,   $expr1p,    $expr2p.isZero}", "AstLogAnd{$condp, $expr1p}")
	if (m_doNConst && nodep->condp()->width1() && nodep->expr1p()->width1() && nodep->expr2p()->isZero()) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstNodeCond $condp.width1, $expr1p.width1, $expr1p, $expr2p.isZero , AstLogAnd $condp, $expr1p )\n");
	    AstNode* arg1p = nodep->condp()->unlinkFrBack();
AstNode* arg2p = nodep->expr1p()->unlinkFrBack();
AstNode* newp = new AstLogAnd(nodep->fileline(), arg1p, arg2p);
nodep->replaceWith(newp);nodep->deleteTree(); VL_DANGLING(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_NodeCond_7(AstNodeCond* nodep) {
	// TREEOP ("AstNodeCond{$condp.width1, $expr1p.width1,   $expr1p, $expr2p.isAllOnes}", "AstLogOr {AstNot{$condp}, $expr1p}")
	if (m_doNConst && nodep->condp()->width1() && nodep->expr1p()->width1() && nodep->expr2p()->isAllOnes()) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstNodeCond $condp.width1, $expr1p.width1, $expr1p, $expr2p.isAllOnes , AstLogOr AstNot $condp , $expr1p )\n");
	    AstNode* arg1p = nodep->condp()->unlinkFrBack();
AstNode* arg2p = nodep->expr1p()->unlinkFrBack();
AstNode* newp = new AstLogOr(nodep->fileline(), new AstNot(nodep->fileline(), arg1p), arg2p);
nodep->replaceWith(newp);nodep->deleteTree(); VL_DANGLING(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_NodeCond_8(AstNodeCond* nodep) {
	// TREEOP ("AstNodeCond{$condp.width1, $expr1p.width1,   $expr1p.isZero,    $expr2p}", "AstLogAnd{AstNot{$condp}, $expr2p}")
	if (m_doNConst && nodep->condp()->width1() && nodep->expr1p()->width1() && nodep->expr1p()->isZero()) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstNodeCond $condp.width1, $expr1p.width1, $expr1p.isZero, $expr2p , AstLogAnd AstNot $condp , $expr2p )\n");
	    AstNode* arg1p = nodep->condp()->unlinkFrBack();
AstNode* arg2p = nodep->expr2p()->unlinkFrBack();
AstNode* newp = new AstLogAnd(nodep->fileline(), new AstNot(nodep->fileline(), arg1p), arg2p);
nodep->replaceWith(newp);nodep->deleteTree(); VL_DANGLING(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_NodeCond_9(AstNodeCond* nodep) {
	// TREEOP ("AstNodeCond{!$condp.width1, operandBoolShift(nodep->condp())}", "replaceBoolShift(nodep->condp())")
	if (m_doNConst && !nodep->condp()->width1() && operandBoolShift(nodep->condp())) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstNodeCond !$condp.width1, operandBoolShift(nodep->condp()) , replaceBoolShift(nodep->condp()) )\n");
	    replaceBoolShift(nodep->condp());
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_NodeUniop_0(AstNodeUniop* nodep) {
	// TREEOPC("AstNodeUniop{$lhsp.castConst, !nodep->isOpaque()}",  "replaceConst(nodep)")
	if (nodep->lhsp()->castConst() && !nodep->isOpaque()) {
	    UINFO(7,(void*)(nodep)<<" TREEOPC( AstNodeUniop $lhsp.castConst, !nodep->isOpaque() , replaceConst(nodep) )\n");
	    replaceConst(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Not_0(AstNot* nodep) {
	// TREEOP ("AstNot   {$lhsp.castNot,  $lhsp->width()==$lhsp->castNot()->lhsp()->width()}",	"replaceWChild(nodep, $lhsp->op1p())")
	if (m_doNConst && nodep->lhsp()->castNot() && nodep->lhsp()->width()==nodep->lhsp()->castNot()->lhsp()->width()) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstNot $lhsp.castNot, $lhsp->width()==$lhsp->castNot()->lhsp()->width() , replaceWChild(nodep, $lhsp->op1p()) )\n");
	    replaceWChild(nodep, nodep->lhsp()->op1p());
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Not_1(AstNot* nodep) {
	// TREEOPV("AstNot   {$lhsp.castEqCase, $lhsp.width1}","AstNeqCase{$lhsp->op1p(),$lhsp->op2p()}")
	if (m_doV && nodep->lhsp()->castEqCase() && nodep->lhsp()->width1()) {
	    UINFO(7,(void*)(nodep)<<" TREEOPV( AstNot $lhsp.castEqCase, $lhsp.width1 , AstNeqCase $lhsp->op1p(),$lhsp->op2p() )\n");
	    AstNode* arg1p = nodep->lhsp()->op1p()->unlinkFrBack();
AstNode* arg2p = nodep->lhsp()->op2p()->unlinkFrBack();
AstNode* newp = new AstNeqCase(nodep->fileline(), arg1p, arg2p);
nodep->replaceWith(newp);nodep->deleteTree(); VL_DANGLING(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Not_2(AstNot* nodep) {
	// TREEOPV("AstNot   {$lhsp.castNeqCase, $lhsp.width1}","AstEqCase {$lhsp->op1p(),$lhsp->op2p()}")
	if (m_doV && nodep->lhsp()->castNeqCase() && nodep->lhsp()->width1()) {
	    UINFO(7,(void*)(nodep)<<" TREEOPV( AstNot $lhsp.castNeqCase, $lhsp.width1 , AstEqCase $lhsp->op1p(),$lhsp->op2p() )\n");
	    AstNode* arg1p = nodep->lhsp()->op1p()->unlinkFrBack();
AstNode* arg2p = nodep->lhsp()->op2p()->unlinkFrBack();
AstNode* newp = new AstEqCase(nodep->fileline(), arg1p, arg2p);
nodep->replaceWith(newp);nodep->deleteTree(); VL_DANGLING(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Not_3(AstNot* nodep) {
	// TREEOPV("AstNot   {$lhsp.castEqWild, $lhsp.width1}","AstNeqWild{$lhsp->op1p(),$lhsp->op2p()}")
	if (m_doV && nodep->lhsp()->castEqWild() && nodep->lhsp()->width1()) {
	    UINFO(7,(void*)(nodep)<<" TREEOPV( AstNot $lhsp.castEqWild, $lhsp.width1 , AstNeqWild $lhsp->op1p(),$lhsp->op2p() )\n");
	    AstNode* arg1p = nodep->lhsp()->op1p()->unlinkFrBack();
AstNode* arg2p = nodep->lhsp()->op2p()->unlinkFrBack();
AstNode* newp = new AstNeqWild(nodep->fileline(), arg1p, arg2p);
nodep->replaceWith(newp);nodep->deleteTree(); VL_DANGLING(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Not_4(AstNot* nodep) {
	// TREEOPV("AstNot   {$lhsp.castNeqWild, $lhsp.width1}","AstEqWild {$lhsp->op1p(),$lhsp->op2p()}")
	if (m_doV && nodep->lhsp()->castNeqWild() && nodep->lhsp()->width1()) {
	    UINFO(7,(void*)(nodep)<<" TREEOPV( AstNot $lhsp.castNeqWild, $lhsp.width1 , AstEqWild $lhsp->op1p(),$lhsp->op2p() )\n");
	    AstNode* arg1p = nodep->lhsp()->op1p()->unlinkFrBack();
AstNode* arg2p = nodep->lhsp()->op2p()->unlinkFrBack();
AstNode* newp = new AstEqWild(nodep->fileline(), arg1p, arg2p);
nodep->replaceWith(newp);nodep->deleteTree(); VL_DANGLING(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Not_5(AstNot* nodep) {
	// TREEOPV("AstNot   {$lhsp.castEq, $lhsp.width1}",	"AstNeq {$lhsp->op1p(),$lhsp->op2p()}")
	if (m_doV && nodep->lhsp()->castEq() && nodep->lhsp()->width1()) {
	    UINFO(7,(void*)(nodep)<<" TREEOPV( AstNot $lhsp.castEq, $lhsp.width1 , AstNeq $lhsp->op1p(),$lhsp->op2p() )\n");
	    AstNode* arg1p = nodep->lhsp()->op1p()->unlinkFrBack();
AstNode* arg2p = nodep->lhsp()->op2p()->unlinkFrBack();
AstNode* newp = new AstNeq(nodep->fileline(), arg1p, arg2p);
nodep->replaceWith(newp);nodep->deleteTree(); VL_DANGLING(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Not_6(AstNot* nodep) {
	// TREEOPV("AstNot   {$lhsp.castNeq, $lhsp.width1}",	"AstEq  {$lhsp->op1p(),$lhsp->op2p()}")
	if (m_doV && nodep->lhsp()->castNeq() && nodep->lhsp()->width1()) {
	    UINFO(7,(void*)(nodep)<<" TREEOPV( AstNot $lhsp.castNeq, $lhsp.width1 , AstEq $lhsp->op1p(),$lhsp->op2p() )\n");
	    AstNode* arg1p = nodep->lhsp()->op1p()->unlinkFrBack();
AstNode* arg2p = nodep->lhsp()->op2p()->unlinkFrBack();
AstNode* newp = new AstEq(nodep->fileline(), arg1p, arg2p);
nodep->replaceWith(newp);nodep->deleteTree(); VL_DANGLING(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Not_7(AstNot* nodep) {
	// TREEOPV("AstNot   {$lhsp.castLt, $lhsp.width1}",	"AstGte {$lhsp->op1p(),$lhsp->op2p()}")
	if (m_doV && nodep->lhsp()->castLt() && nodep->lhsp()->width1()) {
	    UINFO(7,(void*)(nodep)<<" TREEOPV( AstNot $lhsp.castLt, $lhsp.width1 , AstGte $lhsp->op1p(),$lhsp->op2p() )\n");
	    AstNode* arg1p = nodep->lhsp()->op1p()->unlinkFrBack();
AstNode* arg2p = nodep->lhsp()->op2p()->unlinkFrBack();
AstNode* newp = new AstGte(nodep->fileline(), arg1p, arg2p);
nodep->replaceWith(newp);nodep->deleteTree(); VL_DANGLING(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Not_8(AstNot* nodep) {
	// TREEOPV("AstNot   {$lhsp.castLtS, $lhsp.width1}",	"AstGteS{$lhsp->op1p(),$lhsp->op2p()}")
	if (m_doV && nodep->lhsp()->castLtS() && nodep->lhsp()->width1()) {
	    UINFO(7,(void*)(nodep)<<" TREEOPV( AstNot $lhsp.castLtS, $lhsp.width1 , AstGteS $lhsp->op1p(),$lhsp->op2p() )\n");
	    AstNode* arg1p = nodep->lhsp()->op1p()->unlinkFrBack();
AstNode* arg2p = nodep->lhsp()->op2p()->unlinkFrBack();
AstNode* newp = new AstGteS(nodep->fileline(), arg1p, arg2p);
nodep->replaceWith(newp);nodep->deleteTree(); VL_DANGLING(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Not_9(AstNot* nodep) {
	// TREEOPV("AstNot   {$lhsp.castLte, $lhsp.width1}",	"AstGt  {$lhsp->op1p(),$lhsp->op2p()}")
	if (m_doV && nodep->lhsp()->castLte() && nodep->lhsp()->width1()) {
	    UINFO(7,(void*)(nodep)<<" TREEOPV( AstNot $lhsp.castLte, $lhsp.width1 , AstGt $lhsp->op1p(),$lhsp->op2p() )\n");
	    AstNode* arg1p = nodep->lhsp()->op1p()->unlinkFrBack();
AstNode* arg2p = nodep->lhsp()->op2p()->unlinkFrBack();
AstNode* newp = new AstGt(nodep->fileline(), arg1p, arg2p);
nodep->replaceWith(newp);nodep->deleteTree(); VL_DANGLING(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Not_10(AstNot* nodep) {
	// TREEOPV("AstNot   {$lhsp.castLteS, $lhsp.width1}",	"AstGtS {$lhsp->op1p(),$lhsp->op2p()}")
	if (m_doV && nodep->lhsp()->castLteS() && nodep->lhsp()->width1()) {
	    UINFO(7,(void*)(nodep)<<" TREEOPV( AstNot $lhsp.castLteS, $lhsp.width1 , AstGtS $lhsp->op1p(),$lhsp->op2p() )\n");
	    AstNode* arg1p = nodep->lhsp()->op1p()->unlinkFrBack();
AstNode* arg2p = nodep->lhsp()->op2p()->unlinkFrBack();
AstNode* newp = new AstGtS(nodep->fileline(), arg1p, arg2p);
nodep->replaceWith(newp);nodep->deleteTree(); VL_DANGLING(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Not_11(AstNot* nodep) {
	// TREEOPV("AstNot   {$lhsp.castGt, $lhsp.width1}",	"AstLte {$lhsp->op1p(),$lhsp->op2p()}")
	if (m_doV && nodep->lhsp()->castGt() && nodep->lhsp()->width1()) {
	    UINFO(7,(void*)(nodep)<<" TREEOPV( AstNot $lhsp.castGt, $lhsp.width1 , AstLte $lhsp->op1p(),$lhsp->op2p() )\n");
	    AstNode* arg1p = nodep->lhsp()->op1p()->unlinkFrBack();
AstNode* arg2p = nodep->lhsp()->op2p()->unlinkFrBack();
AstNode* newp = new AstLte(nodep->fileline(), arg1p, arg2p);
nodep->replaceWith(newp);nodep->deleteTree(); VL_DANGLING(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Not_12(AstNot* nodep) {
	// TREEOPV("AstNot   {$lhsp.castGtS, $lhsp.width1}",	"AstLteS{$lhsp->op1p(),$lhsp->op2p()}")
	if (m_doV && nodep->lhsp()->castGtS() && nodep->lhsp()->width1()) {
	    UINFO(7,(void*)(nodep)<<" TREEOPV( AstNot $lhsp.castGtS, $lhsp.width1 , AstLteS $lhsp->op1p(),$lhsp->op2p() )\n");
	    AstNode* arg1p = nodep->lhsp()->op1p()->unlinkFrBack();
AstNode* arg2p = nodep->lhsp()->op2p()->unlinkFrBack();
AstNode* newp = new AstLteS(nodep->fileline(), arg1p, arg2p);
nodep->replaceWith(newp);nodep->deleteTree(); VL_DANGLING(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Not_13(AstNot* nodep) {
	// TREEOPV("AstNot   {$lhsp.castGte, $lhsp.width1}",	"AstLt  {$lhsp->op1p(),$lhsp->op2p()}")
	if (m_doV && nodep->lhsp()->castGte() && nodep->lhsp()->width1()) {
	    UINFO(7,(void*)(nodep)<<" TREEOPV( AstNot $lhsp.castGte, $lhsp.width1 , AstLt $lhsp->op1p(),$lhsp->op2p() )\n");
	    AstNode* arg1p = nodep->lhsp()->op1p()->unlinkFrBack();
AstNode* arg2p = nodep->lhsp()->op2p()->unlinkFrBack();
AstNode* newp = new AstLt(nodep->fileline(), arg1p, arg2p);
nodep->replaceWith(newp);nodep->deleteTree(); VL_DANGLING(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Not_14(AstNot* nodep) {
	// TREEOPV("AstNot   {$lhsp.castGteS, $lhsp.width1}",	"AstLtS {$lhsp->op1p(),$lhsp->op2p()}")
	if (m_doV && nodep->lhsp()->castGteS() && nodep->lhsp()->width1()) {
	    UINFO(7,(void*)(nodep)<<" TREEOPV( AstNot $lhsp.castGteS, $lhsp.width1 , AstLtS $lhsp->op1p(),$lhsp->op2p() )\n");
	    AstNode* arg1p = nodep->lhsp()->op1p()->unlinkFrBack();
AstNode* arg2p = nodep->lhsp()->op2p()->unlinkFrBack();
AstNode* newp = new AstLtS(nodep->fileline(), arg1p, arg2p);
nodep->replaceWith(newp);nodep->deleteTree(); VL_DANGLING(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_OneHot_0(AstOneHot* nodep) {
	// TREEOPV("AstOneHot{$lhsp.width1}",		"replaceWLhs(nodep)")
	if (m_doV && nodep->lhsp()->width1()) {
	    UINFO(7,(void*)(nodep)<<" TREEOPV( AstOneHot $lhsp.width1 , replaceWLhs(nodep) )\n");
	    replaceWLhs(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_OneHot0_0(AstOneHot0* nodep) {
	// TREEOPV("AstOneHot0{$lhsp.width1}",		"replaceNum(nodep,1)")
	if (m_doV && nodep->lhsp()->width1()) {
	    UINFO(7,(void*)(nodep)<<" TREEOPV( AstOneHot0 $lhsp.width1 , replaceNum(nodep,1) )\n");
	    replaceNum(nodep,1);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Or_0(AstOr* nodep) {
	// TREEOP ("AstOr    {$lhsp.isZero, $rhsp}",	"replaceWRhs(nodep)")
	if (m_doNConst && nodep->lhsp()->isZero()) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstOr $lhsp.isZero, $rhsp , replaceWRhs(nodep) )\n");
	    replaceWRhs(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Or_1(AstOr* nodep) {
	// TREEOP ("AstOr    {$lhsp, $rhsp.isZero}",	"replaceWLhs(nodep)")
	if (m_doNConst && nodep->rhsp()->isZero()) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstOr $lhsp, $rhsp.isZero , replaceWLhs(nodep) )\n");
	    replaceWLhs(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Or_2(AstOr* nodep) {
	// TREEOP ("AstOr    {$lhsp.isAllOnes, $rhsp, isTPure($rhsp)}",	"replaceWLhs(nodep)")
	if (m_doNConst && nodep->lhsp()->isAllOnes() && isTPure(nodep->rhsp())) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstOr $lhsp.isAllOnes, $rhsp, isTPure($rhsp) , replaceWLhs(nodep) )\n");
	    replaceWLhs(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Or_3(AstOr* nodep) {
	// TREEOP ("AstOr    {$lhsp, $rhsp.isAllOnes, isTPure($lhsp)}",	"replaceWRhs(nodep)")
	if (m_doNConst && nodep->rhsp()->isAllOnes() && isTPure(nodep->lhsp())) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstOr $lhsp, $rhsp.isAllOnes, isTPure($lhsp) , replaceWRhs(nodep) )\n");
	    replaceWRhs(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Or_4(AstOr* nodep) {
	// TREEOP ("AstOr     {operandsSame($lhsp,,$rhsp)}",	"replaceWLhs(nodep)")
	if (m_doNConst && operandsSame(nodep->lhsp(),nodep->rhsp())) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstOr operandsSame($lhsp,,$rhsp) , replaceWLhs(nodep) )\n");
	    replaceWLhs(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Or_5(AstOr* nodep) {
	// TREEOP ("AstOr  {$lhsp.castAnd,$rhsp.castAnd,operandAndOrSame(nodep)}",	"replaceAndOr(nodep)")
	if (m_doNConst && nodep->lhsp()->castAnd() && nodep->rhsp()->castAnd() && operandAndOrSame(nodep)) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstOr $lhsp.castAnd,$rhsp.castAnd,operandAndOrSame(nodep) , replaceAndOr(nodep) )\n");
	    replaceAndOr(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Or_6(AstOr* nodep) {
	// TREEOP ("AstOr  {matchOrAndNot(nodep)}",		"DONE")
	if (m_doNConst && matchOrAndNot(nodep)) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstOr matchOrAndNot(nodep) , DONE )\n");
	    
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Or_7(AstOr* nodep) {
	// TREEOP ("AstOr  {operandShiftSame(nodep)}",		"replaceShiftSame(nodep)")
	if (m_doNConst && operandShiftSame(nodep)) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstOr operandShiftSame(nodep) , replaceShiftSame(nodep) )\n");
	    replaceShiftSame(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Pow_0(AstPow* nodep) {
	// TREEOP ("AstPow   {$rhsp.isZero}",		"replaceNum(nodep, 1)")
	if (m_doNConst && nodep->rhsp()->isZero()) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstPow $rhsp.isZero , replaceNum(nodep, 1) )\n");
	    replaceNum(nodep, 1);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Pow_1(AstPow* nodep) {
	// TREEOP ("AstPow   {$lhsp.isZero, !$rhsp.isZero}",	"replaceZeroChkPure(nodep,$rhsp)")
	if (m_doNConst && nodep->lhsp()->isZero() && !nodep->rhsp()->isZero()) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstPow $lhsp.isZero, !$rhsp.isZero , replaceZeroChkPure(nodep,$rhsp) )\n");
	    replaceZeroChkPure(nodep,nodep->rhsp());
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Pow_2(AstPow* nodep) {
	// TREEOP ("AstPow   {operandIsTwo($lhsp), $rhsp}",	"replacePowShift(nodep)")
	if (m_doNConst && operandIsTwo(nodep->lhsp())) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstPow operandIsTwo($lhsp), $rhsp , replacePowShift(nodep) )\n");
	    replacePowShift(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_PowSS_0(AstPowSS* nodep) {
	// TREEOP ("AstPowSS {$rhsp.isZero}",		"replaceNum(nodep, 1)")
	if (m_doNConst && nodep->rhsp()->isZero()) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstPowSS $rhsp.isZero , replaceNum(nodep, 1) )\n");
	    replaceNum(nodep, 1);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_PowSU_0(AstPowSU* nodep) {
	// TREEOP ("AstPowSU {$rhsp.isZero}",		"replaceNum(nodep, 1)")
	if (m_doNConst && nodep->rhsp()->isZero()) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstPowSU $rhsp.isZero , replaceNum(nodep, 1) )\n");
	    replaceNum(nodep, 1);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_PowSU_1(AstPowSU* nodep) {
	// TREEOP ("AstPowSU {$lhsp.isZero, !$rhsp.isZero}",	"replaceZeroChkPure(nodep,$rhsp)")
	if (m_doNConst && nodep->lhsp()->isZero() && !nodep->rhsp()->isZero()) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstPowSU $lhsp.isZero, !$rhsp.isZero , replaceZeroChkPure(nodep,$rhsp) )\n");
	    replaceZeroChkPure(nodep,nodep->rhsp());
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_PowSU_2(AstPowSU* nodep) {
	// TREEOP ("AstPowSU {$lhsp.isZero, !$rhsp.isZero}",	"replaceZeroChkPure(nodep,$rhsp)")
	if (m_doNConst && nodep->lhsp()->isZero() && !nodep->rhsp()->isZero()) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstPowSU $lhsp.isZero, !$rhsp.isZero , replaceZeroChkPure(nodep,$rhsp) )\n");
	    replaceZeroChkPure(nodep,nodep->rhsp());
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_PowUS_0(AstPowUS* nodep) {
	// TREEOP ("AstPowUS {$rhsp.isZero}",		"replaceNum(nodep, 1)")
	if (m_doNConst && nodep->rhsp()->isZero()) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstPowUS $rhsp.isZero , replaceNum(nodep, 1) )\n");
	    replaceNum(nodep, 1);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_PowUS_1(AstPowUS* nodep) {
	// TREEOP ("AstPowUS {$lhsp.isZero, !$rhsp.isZero}",	"replaceZeroChkPure(nodep,$rhsp)")
	if (m_doNConst && nodep->lhsp()->isZero() && !nodep->rhsp()->isZero()) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstPowUS $lhsp.isZero, !$rhsp.isZero , replaceZeroChkPure(nodep,$rhsp) )\n");
	    replaceZeroChkPure(nodep,nodep->rhsp());
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_RedAnd_0(AstRedAnd* nodep) {
	// TREEOPV("AstRedAnd{$lhsp, $lhsp.width1}",	"replaceWLhs(nodep)")
	if (m_doV && nodep->lhsp()->width1()) {
	    UINFO(7,(void*)(nodep)<<" TREEOPV( AstRedAnd $lhsp, $lhsp.width1 , replaceWLhs(nodep) )\n");
	    replaceWLhs(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_RedAnd_1(AstRedAnd* nodep) {
	// TREEOPV("AstRedAnd{$lhsp.castConcat}",	"AstAnd{AstRedAnd{$lhsp->castConcat()->lhsp()}, AstRedAnd{$lhsp->castConcat()->rhsp()}}")
	if (m_doV && nodep->lhsp()->castConcat()) {
	    UINFO(7,(void*)(nodep)<<" TREEOPV( AstRedAnd $lhsp.castConcat , AstAnd AstRedAnd $lhsp->castConcat()->lhsp() , AstRedAnd $lhsp->castConcat()->rhsp() )\n");
	    AstNode* arg1p = nodep->lhsp()->castConcat()->lhsp()->unlinkFrBack();
AstNode* arg2p = nodep->lhsp()->castConcat()->rhsp()->unlinkFrBack();
AstNode* newp = new AstAnd(nodep->fileline(), new AstRedAnd(nodep->fileline(), arg1p), new AstRedAnd(nodep->fileline(), arg2p));
nodep->replaceWith(newp);nodep->deleteTree(); VL_DANGLING(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_RedAnd_2(AstRedAnd* nodep) {
	// TREEOPV("AstRedAnd{$lhsp.castExtend, $lhsp->width() > $lhsp->castExtend()->lhsp()->width()}",	"replaceZero(nodep)")
	if (m_doV && nodep->lhsp()->castExtend() && nodep->lhsp()->width() > nodep->lhsp()->castExtend()->lhsp()->width()) {
	    UINFO(7,(void*)(nodep)<<" TREEOPV( AstRedAnd $lhsp.castExtend, $lhsp->width() > $lhsp->castExtend()->lhsp()->width() , replaceZero(nodep) )\n");
	    replaceZero(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_RedOr_0(AstRedOr* nodep) {
	// TREEOPV("AstRedOr {$lhsp, $lhsp.width1}",	"replaceWLhs(nodep)")
	if (m_doV && nodep->lhsp()->width1()) {
	    UINFO(7,(void*)(nodep)<<" TREEOPV( AstRedOr $lhsp, $lhsp.width1 , replaceWLhs(nodep) )\n");
	    replaceWLhs(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_RedOr_1(AstRedOr* nodep) {
	// TREEOPV("AstRedOr {$lhsp.castConcat}",	"AstOr {AstRedOr {$lhsp->castConcat()->lhsp()}, AstRedOr {$lhsp->castConcat()->rhsp()}}")
	if (m_doV && nodep->lhsp()->castConcat()) {
	    UINFO(7,(void*)(nodep)<<" TREEOPV( AstRedOr $lhsp.castConcat , AstOr AstRedOr $lhsp->castConcat()->lhsp() , AstRedOr $lhsp->castConcat()->rhsp() )\n");
	    AstNode* arg1p = nodep->lhsp()->castConcat()->lhsp()->unlinkFrBack();
AstNode* arg2p = nodep->lhsp()->castConcat()->rhsp()->unlinkFrBack();
AstNode* newp = new AstOr(nodep->fileline(), new AstRedOr(nodep->fileline(), arg1p), new AstRedOr(nodep->fileline(), arg2p));
nodep->replaceWith(newp);nodep->deleteTree(); VL_DANGLING(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_RedOr_2(AstRedOr* nodep) {
	// TREEOPV("AstRedOr {$lhsp.castExtend}",	"AstRedOr {$lhsp->castExtend()->lhsp()}")
	if (m_doV && nodep->lhsp()->castExtend()) {
	    UINFO(7,(void*)(nodep)<<" TREEOPV( AstRedOr $lhsp.castExtend , AstRedOr $lhsp->castExtend()->lhsp() )\n");
	    AstNode* arg1p = nodep->lhsp()->castExtend()->lhsp()->unlinkFrBack();
AstNode* newp = new AstRedOr(nodep->fileline(), arg1p);
nodep->replaceWith(newp);nodep->deleteTree(); VL_DANGLING(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_RedXnor_0(AstRedXnor* nodep) {
	// TREEOPV("AstRedXnor{$lhsp}",		"AstNot{AstRedXor{$lhsp}}")
	if (m_doV) {
	    UINFO(7,(void*)(nodep)<<" TREEOPV( AstRedXnor $lhsp , AstNot AstRedXor $lhsp )\n");
	    AstNode* arg1p = nodep->lhsp()->unlinkFrBack();
AstNode* newp = new AstNot(nodep->fileline(), new AstRedXor(nodep->fileline(), arg1p));
nodep->replaceWith(newp);nodep->deleteTree(); VL_DANGLING(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_RedXor_0(AstRedXor* nodep) {
	// TREEOPV("AstRedXor{$lhsp, $lhsp.width1}",	"replaceWLhs(nodep)")
	if (m_doV && nodep->lhsp()->width1()) {
	    UINFO(7,(void*)(nodep)<<" TREEOPV( AstRedXor $lhsp, $lhsp.width1 , replaceWLhs(nodep) )\n");
	    replaceWLhs(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_RedXor_1(AstRedXor* nodep) {
	// TREEOPV("AstRedXor{$lhsp.castConcat}",	"AstXor{AstRedXor{$lhsp->castConcat()->lhsp()}, AstRedXor{$lhsp->castConcat()->rhsp()}}")
	if (m_doV && nodep->lhsp()->castConcat()) {
	    UINFO(7,(void*)(nodep)<<" TREEOPV( AstRedXor $lhsp.castConcat , AstXor AstRedXor $lhsp->castConcat()->lhsp() , AstRedXor $lhsp->castConcat()->rhsp() )\n");
	    AstNode* arg1p = nodep->lhsp()->castConcat()->lhsp()->unlinkFrBack();
AstNode* arg2p = nodep->lhsp()->castConcat()->rhsp()->unlinkFrBack();
AstNode* newp = new AstXor(nodep->fileline(), new AstRedXor(nodep->fileline(), arg1p), new AstRedXor(nodep->fileline(), arg2p));
nodep->replaceWith(newp);nodep->deleteTree(); VL_DANGLING(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_RedXor_2(AstRedXor* nodep) {
	// TREEOPV("AstRedXor{$lhsp.castExtend}",	"AstRedXor{$lhsp->castExtend()->lhsp()}")
	if (m_doV && nodep->lhsp()->castExtend()) {
	    UINFO(7,(void*)(nodep)<<" TREEOPV( AstRedXor $lhsp.castExtend , AstRedXor $lhsp->castExtend()->lhsp() )\n");
	    AstNode* arg1p = nodep->lhsp()->castExtend()->lhsp()->unlinkFrBack();
AstNode* newp = new AstRedXor(nodep->fileline(), arg1p);
nodep->replaceWith(newp);nodep->deleteTree(); VL_DANGLING(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Replicate_0(AstReplicate* nodep) {
	// TREEOPV("AstReplicate{$lhsp, $rhsp.isOne, $lhsp->width()==nodep->width()}",	"replaceWLhs(nodep)")
	if (m_doV && nodep->rhsp()->isOne() && nodep->lhsp()->width()==nodep->width()) {
	    UINFO(7,(void*)(nodep)<<" TREEOPV( AstReplicate $lhsp, $rhsp.isOne, $lhsp->width()==nodep->width() , replaceWLhs(nodep) )\n");
	    replaceWLhs(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Replicate_1(AstReplicate* nodep) {
	// TREEOPV("AstReplicate{$lhsp.castReplicate, operandRepRep(nodep)}", "DONE")
	if (m_doV && nodep->lhsp()->castReplicate() && operandRepRep(nodep)) {
	    UINFO(7,(void*)(nodep)<<" TREEOPV( AstReplicate $lhsp.castReplicate, operandRepRep(nodep) , DONE )\n");
	    
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_ReplicateN_0(AstReplicateN* nodep) {
	// TREEOPV("AstReplicateN{$lhsp, $rhsp.isOne, $lhsp->width()==nodep->width()}", "replaceWLhs(nodep)")
	if (m_doV && nodep->rhsp()->isOne() && nodep->lhsp()->width()==nodep->width()) {
	    UINFO(7,(void*)(nodep)<<" TREEOPV( AstReplicateN $lhsp, $rhsp.isOne, $lhsp->width()==nodep->width() , replaceWLhs(nodep) )\n");
	    replaceWLhs(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Sel_0(AstSel* nodep) {
	// TREEOP1("AstSel{warnSelect(nodep)}",	"NEVER")
	if (m_doNConst && warnSelect(nodep)) {
	    UINFO(7,(void*)(nodep)<<" TREEOP1( AstSel warnSelect(nodep) , NEVER )\n");
	    nodep->v3fatalSrc("Executing transform that was NEVERed");
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Sel_1(AstSel* nodep) {
	// TREEOPV("AstSel{operandSelExtend(nodep)}",	"DONE")
	if (m_doV && operandSelExtend(nodep)) {
	    UINFO(7,(void*)(nodep)<<" TREEOPV( AstSel operandSelExtend(nodep) , DONE )\n");
	    
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Sel_2(AstSel* nodep) {
	// TREEOPV("AstSel{operandSelFull(nodep)}",	"replaceWChild(nodep, nodep->fromp())")
	if (m_doV && operandSelFull(nodep)) {
	    UINFO(7,(void*)(nodep)<<" TREEOPV( AstSel operandSelFull(nodep) , replaceWChild(nodep, nodep->fromp()) )\n");
	    replaceWChild(nodep, nodep->fromp());
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Sel_3(AstSel* nodep) {
	// TREEOPV("AstSel{$fromp.castSel}",		"replaceSelSel(nodep)")
	if (m_doV && nodep->fromp()->castSel()) {
	    UINFO(7,(void*)(nodep)<<" TREEOPV( AstSel $fromp.castSel , replaceSelSel(nodep) )\n");
	    replaceSelSel(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Sel_4(AstSel* nodep) {
	// TREEOPV("AstSel{$fromp.castAdd, operandSelBiLower(nodep)}",	"DONE")
	if (m_doV && nodep->fromp()->castAdd() && operandSelBiLower(nodep)) {
	    UINFO(7,(void*)(nodep)<<" TREEOPV( AstSel $fromp.castAdd, operandSelBiLower(nodep) , DONE )\n");
	    
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Sel_5(AstSel* nodep) {
	// TREEOPV("AstSel{$fromp.castAnd, operandSelBiLower(nodep)}",	"DONE")
	if (m_doV && nodep->fromp()->castAnd() && operandSelBiLower(nodep)) {
	    UINFO(7,(void*)(nodep)<<" TREEOPV( AstSel $fromp.castAnd, operandSelBiLower(nodep) , DONE )\n");
	    
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Sel_6(AstSel* nodep) {
	// TREEOPV("AstSel{$fromp.castOr,  operandSelBiLower(nodep)}",	"DONE")
	if (m_doV && nodep->fromp()->castOr() && operandSelBiLower(nodep)) {
	    UINFO(7,(void*)(nodep)<<" TREEOPV( AstSel $fromp.castOr, operandSelBiLower(nodep) , DONE )\n");
	    
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Sel_7(AstSel* nodep) {
	// TREEOPV("AstSel{$fromp.castSub, operandSelBiLower(nodep)}",	"DONE")
	if (m_doV && nodep->fromp()->castSub() && operandSelBiLower(nodep)) {
	    UINFO(7,(void*)(nodep)<<" TREEOPV( AstSel $fromp.castSub, operandSelBiLower(nodep) , DONE )\n");
	    
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Sel_8(AstSel* nodep) {
	// TREEOPV("AstSel{$fromp.castXnor,operandSelBiLower(nodep)}",	"DONE")
	if (m_doV && nodep->fromp()->castXnor() && operandSelBiLower(nodep)) {
	    UINFO(7,(void*)(nodep)<<" TREEOPV( AstSel $fromp.castXnor,operandSelBiLower(nodep) , DONE )\n");
	    
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Sel_9(AstSel* nodep) {
	// TREEOPV("AstSel{$fromp.castXor, operandSelBiLower(nodep)}",	"DONE")
	if (m_doV && nodep->fromp()->castXor() && operandSelBiLower(nodep)) {
	    UINFO(7,(void*)(nodep)<<" TREEOPV( AstSel $fromp.castXor, operandSelBiLower(nodep) , DONE )\n");
	    
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Sel_10(AstSel* nodep) {
	// TREEOPV("AstSel{$fromp.castShiftR, operandSelShiftLower(nodep)}",	"DONE")
	if (m_doV && nodep->fromp()->castShiftR() && operandSelShiftLower(nodep)) {
	    UINFO(7,(void*)(nodep)<<" TREEOPV( AstSel $fromp.castShiftR, operandSelShiftLower(nodep) , DONE )\n");
	    
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Sel_11(AstSel* nodep) {
	// TREEOPC("AstSel{$fromp.castConst, $lsbp.castConst, $widthp.castConst, }",	"replaceConst(nodep)")
	if (nodep->fromp()->castConst() && nodep->lsbp()->castConst() && nodep->widthp()->castConst()) {
	    UINFO(7,(void*)(nodep)<<" TREEOPC( AstSel $fromp.castConst, $lsbp.castConst, $widthp.castConst, , replaceConst(nodep) )\n");
	    replaceConst(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Sel_12(AstSel* nodep) {
	// TREEOPV("AstSel{$fromp.castConcat, $lsbp.castConst, $widthp.castConst, }",	"replaceSelConcat(nodep)")
	if (m_doV && nodep->fromp()->castConcat() && nodep->lsbp()->castConst() && nodep->widthp()->castConst()) {
	    UINFO(7,(void*)(nodep)<<" TREEOPV( AstSel $fromp.castConcat, $lsbp.castConst, $widthp.castConst, , replaceSelConcat(nodep) )\n");
	    replaceSelConcat(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Sel_13(AstSel* nodep) {
	// TREEOPV("AstSel{$fromp.castReplicate, $lsbp.castConst, $widthp.castConst, operandSelReplicate(nodep) }",	"DONE")
	if (m_doV && nodep->fromp()->castReplicate() && nodep->lsbp()->castConst() && nodep->widthp()->castConst() && operandSelReplicate(nodep) ) {
	    UINFO(7,(void*)(nodep)<<" TREEOPV( AstSel $fromp.castReplicate, $lsbp.castConst, $widthp.castConst, operandSelReplicate(nodep) , DONE )\n");
	    
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Sel_14(AstSel* nodep) {
	// TREEOPV("AstSel{$fromp.castBufIf1}",		"replaceSelIntoBiop(nodep)")
	if (m_doV && nodep->fromp()->castBufIf1()) {
	    UINFO(7,(void*)(nodep)<<" TREEOPV( AstSel $fromp.castBufIf1 , replaceSelIntoBiop(nodep) )\n");
	    replaceSelIntoBiop(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Sel_15(AstSel* nodep) {
	// TREEOPV("AstSel{$fromp.castNot}",			"replaceSelIntoUniop(nodep)")
	if (m_doV && nodep->fromp()->castNot()) {
	    UINFO(7,(void*)(nodep)<<" TREEOPV( AstSel $fromp.castNot , replaceSelIntoUniop(nodep) )\n");
	    replaceSelIntoUniop(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Sel_16(AstSel* nodep) {
	// TREEOPV("AstSel{$fromp.castAnd,$lhsp.castConst}",	"replaceSelIntoUniop(nodep)")
	if (m_doV && nodep->fromp()->castAnd() && nodep->lhsp()->castConst()) {
	    UINFO(7,(void*)(nodep)<<" TREEOPV( AstSel $fromp.castAnd,$lhsp.castConst , replaceSelIntoUniop(nodep) )\n");
	    replaceSelIntoUniop(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Sel_17(AstSel* nodep) {
	// TREEOPV("AstSel{$fromp.castOr,$lhsp.castConst}",	"replaceSelIntoUniop(nodep)")
	if (m_doV && nodep->fromp()->castOr() && nodep->lhsp()->castConst()) {
	    UINFO(7,(void*)(nodep)<<" TREEOPV( AstSel $fromp.castOr,$lhsp.castConst , replaceSelIntoUniop(nodep) )\n");
	    replaceSelIntoUniop(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Sel_18(AstSel* nodep) {
	// TREEOPV("AstSel{$fromp.castXor,$lhsp.castConst}",	"replaceSelIntoUniop(nodep)")
	if (m_doV && nodep->fromp()->castXor() && nodep->lhsp()->castConst()) {
	    UINFO(7,(void*)(nodep)<<" TREEOPV( AstSel $fromp.castXor,$lhsp.castConst , replaceSelIntoUniop(nodep) )\n");
	    replaceSelIntoUniop(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Sel_19(AstSel* nodep) {
	// TREEOPV("AstSel{$fromp.castXnor,$lhsp.castConst}",	"replaceSelIntoUniop(nodep)")
	if (m_doV && nodep->fromp()->castXnor() && nodep->lhsp()->castConst()) {
	    UINFO(7,(void*)(nodep)<<" TREEOPV( AstSel $fromp.castXnor,$lhsp.castConst , replaceSelIntoUniop(nodep) )\n");
	    replaceSelIntoUniop(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_ShiftL_0(AstShiftL* nodep) {
	// TREEOP ("AstShiftL{$lhsp.isZero, $rhsp}",	"replaceZeroChkPure(nodep,$rhsp)")
	if (m_doNConst && nodep->lhsp()->isZero()) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstShiftL $lhsp.isZero, $rhsp , replaceZeroChkPure(nodep,$rhsp) )\n");
	    replaceZeroChkPure(nodep,nodep->rhsp());
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_ShiftL_1(AstShiftL* nodep) {
	// TREEOP ("AstShiftL{$lhsp, $rhsp.isZero}",	"replaceWLhs(nodep)")
	if (m_doNConst && nodep->rhsp()->isZero()) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstShiftL $lhsp, $rhsp.isZero , replaceWLhs(nodep) )\n");
	    replaceWLhs(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_ShiftL_2(AstShiftL* nodep) {
	// TREEOP ("AstShiftL{operandHugeShiftL(nodep)}",	"replaceZero(nodep)")
	if (m_doNConst && operandHugeShiftL(nodep)) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstShiftL operandHugeShiftL(nodep) , replaceZero(nodep) )\n");
	    replaceZero(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_ShiftL_3(AstShiftL* nodep) {
	// TREEOP ("AstShiftL{operandShiftOp(nodep)}",		"replaceShiftOp(nodep)")
	if (m_doNConst && operandShiftOp(nodep)) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstShiftL operandShiftOp(nodep) , replaceShiftOp(nodep) )\n");
	    replaceShiftOp(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_ShiftL_4(AstShiftL* nodep) {
	// TREEOP ("AstShiftL{operandShiftShift(nodep)}",	"replaceShiftShift(nodep)")
	if (m_doNConst && operandShiftShift(nodep)) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstShiftL operandShiftShift(nodep) , replaceShiftShift(nodep) )\n");
	    replaceShiftShift(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_ShiftR_0(AstShiftR* nodep) {
	// TREEOP ("AstShiftR{$lhsp.isZero, $rhsp}",	"replaceZeroChkPure(nodep,$rhsp)")
	if (m_doNConst && nodep->lhsp()->isZero()) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstShiftR $lhsp.isZero, $rhsp , replaceZeroChkPure(nodep,$rhsp) )\n");
	    replaceZeroChkPure(nodep,nodep->rhsp());
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_ShiftR_1(AstShiftR* nodep) {
	// TREEOP ("AstShiftR{$lhsp, $rhsp.isZero}",	"replaceWLhs(nodep)")
	if (m_doNConst && nodep->rhsp()->isZero()) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstShiftR $lhsp, $rhsp.isZero , replaceWLhs(nodep) )\n");
	    replaceWLhs(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_ShiftR_2(AstShiftR* nodep) {
	// TREEOP ("AstShiftR{operandHugeShiftR(nodep)}",	"replaceZero(nodep)")
	if (m_doNConst && operandHugeShiftR(nodep)) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstShiftR operandHugeShiftR(nodep) , replaceZero(nodep) )\n");
	    replaceZero(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_ShiftR_3(AstShiftR* nodep) {
	// TREEOP ("AstShiftR{operandShiftOp(nodep)}",		"replaceShiftOp(nodep)")
	if (m_doNConst && operandShiftOp(nodep)) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstShiftR operandShiftOp(nodep) , replaceShiftOp(nodep) )\n");
	    replaceShiftOp(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_ShiftR_4(AstShiftR* nodep) {
	// TREEOP ("AstShiftR{operandShiftShift(nodep)}",	"replaceShiftShift(nodep)")
	if (m_doNConst && operandShiftShift(nodep)) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstShiftR operandShiftShift(nodep) , replaceShiftShift(nodep) )\n");
	    replaceShiftShift(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_ShiftRS_0(AstShiftRS* nodep) {
	// TREEOP ("AstShiftRS{$lhsp.isZero, $rhsp}",	"replaceZeroChkPure(nodep,$rhsp)")
	if (m_doNConst && nodep->lhsp()->isZero()) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstShiftRS $lhsp.isZero, $rhsp , replaceZeroChkPure(nodep,$rhsp) )\n");
	    replaceZeroChkPure(nodep,nodep->rhsp());
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_ShiftRS_1(AstShiftRS* nodep) {
	// TREEOP ("AstShiftRS{$lhsp, $rhsp.isZero}",	"replaceWLhs(nodep)")
	if (m_doNConst && nodep->rhsp()->isZero()) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstShiftRS $lhsp, $rhsp.isZero , replaceWLhs(nodep) )\n");
	    replaceWLhs(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Sub_0(AstSub* nodep) {
	// TREEOP ("AstSub   {$lhsp.isZero, $rhsp}",	"AstNegate{$rhsp}")
	if (m_doNConst && nodep->lhsp()->isZero()) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstSub $lhsp.isZero, $rhsp , AstNegate $rhsp )\n");
	    AstNode* arg1p = nodep->rhsp()->unlinkFrBack();
AstNode* newp = new AstNegate(nodep->fileline(), arg1p);
nodep->replaceWith(newp);nodep->deleteTree(); VL_DANGLING(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Sub_1(AstSub* nodep) {
	// TREEOP ("AstSub   {$lhsp, $rhsp.isZero}",	"replaceWLhs(nodep)")
	if (m_doNConst && nodep->rhsp()->isZero()) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstSub $lhsp, $rhsp.isZero , replaceWLhs(nodep) )\n");
	    replaceWLhs(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Sub_2(AstSub* nodep) {
	// TREEOP ("AstSub   {$lhsp.castAdd, operandSubAdd(nodep)}", "AstAdd{AstSub{$lhsp->castAdd()->lhsp(),$rhsp}, $lhsp->castAdd()->rhsp()}")
	if (m_doNConst && nodep->lhsp()->castAdd() && operandSubAdd(nodep)) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstSub $lhsp.castAdd, operandSubAdd(nodep) , AstAdd AstSub $lhsp->castAdd()->lhsp(),$rhsp , $lhsp->castAdd()->rhsp() )\n");
	    AstNode* arg1p = nodep->lhsp()->castAdd()->lhsp()->unlinkFrBack();
AstNode* arg2p = nodep->rhsp()->unlinkFrBack();
AstNode* arg3p = nodep->lhsp()->castAdd()->rhsp()->unlinkFrBack();
AstNode* newp = new AstAdd(nodep->fileline(), new AstSub(nodep->fileline(), arg1p, arg2p), arg3p);
nodep->replaceWith(newp);nodep->deleteTree(); VL_DANGLING(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Sub_3(AstSub* nodep) {
	// TREEOP ("AstSub    {operandsSame($lhsp,,$rhsp)}",	"replaceZero(nodep)")
	if (m_doNConst && operandsSame(nodep->lhsp(),nodep->rhsp())) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstSub operandsSame($lhsp,,$rhsp) , replaceZero(nodep) )\n");
	    replaceZero(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_WordSel_0(AstWordSel* nodep) {
	// TREEOP ("AstWordSel{operandWordOOB(nodep)}",	"replaceZero(nodep)")
	if (m_doNConst && operandWordOOB(nodep)) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstWordSel operandWordOOB(nodep) , replaceZero(nodep) )\n");
	    replaceZero(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Xnor_0(AstXnor* nodep) {
	// TREEOP ("AstXnor  {$lhsp.isZero, $rhsp}",	"AstNot{$rhsp}")
	if (m_doNConst && nodep->lhsp()->isZero()) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstXnor $lhsp.isZero, $rhsp , AstNot $rhsp )\n");
	    AstNode* arg1p = nodep->rhsp()->unlinkFrBack();
AstNode* newp = new AstNot(nodep->fileline(), arg1p);
nodep->replaceWith(newp);nodep->deleteTree(); VL_DANGLING(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Xnor_1(AstXnor* nodep) {
	// TREEOP ("AstXnor  {$lhsp, $rhsp.isZero}",	"AstNot{$lhsp}")
	if (m_doNConst && nodep->rhsp()->isZero()) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstXnor $lhsp, $rhsp.isZero , AstNot $lhsp )\n");
	    AstNode* arg1p = nodep->lhsp()->unlinkFrBack();
AstNode* newp = new AstNot(nodep->fileline(), arg1p);
nodep->replaceWith(newp);nodep->deleteTree(); VL_DANGLING(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Xnor_2(AstXnor* nodep) {
	// TREEOP ("AstXnor  {$lhsp.isAllOnes, $rhsp}",	"replaceWRhs(nodep)")
	if (m_doNConst && nodep->lhsp()->isAllOnes()) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstXnor $lhsp.isAllOnes, $rhsp , replaceWRhs(nodep) )\n");
	    replaceWRhs(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Xnor_3(AstXnor* nodep) {
	// TREEOP ("AstXnor   {operandsSame($lhsp,,$rhsp)}",	"replaceAllOnes(nodep)")
	if (m_doNConst && operandsSame(nodep->lhsp(),nodep->rhsp())) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstXnor operandsSame($lhsp,,$rhsp) , replaceAllOnes(nodep) )\n");
	    replaceAllOnes(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Xor_0(AstXor* nodep) {
	// TREEOP ("AstXor   {$lhsp.isZero, $rhsp}",	"replaceWRhs(nodep)")
	if (m_doNConst && nodep->lhsp()->isZero()) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstXor $lhsp.isZero, $rhsp , replaceWRhs(nodep) )\n");
	    replaceWRhs(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Xor_1(AstXor* nodep) {
	// TREEOP ("AstXor   {$lhsp, $rhsp.isZero}",	"replaceWLhs(nodep)")
	if (m_doNConst && nodep->rhsp()->isZero()) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstXor $lhsp, $rhsp.isZero , replaceWLhs(nodep) )\n");
	    replaceWLhs(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Xor_2(AstXor* nodep) {
	// TREEOP ("AstXor   {$lhsp.isAllOnes, $rhsp}",	"AstNot{$rhsp}")
	if (m_doNConst && nodep->lhsp()->isAllOnes()) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstXor $lhsp.isAllOnes, $rhsp , AstNot $rhsp )\n");
	    AstNode* arg1p = nodep->rhsp()->unlinkFrBack();
AstNode* newp = new AstNot(nodep->fileline(), arg1p);
nodep->replaceWith(newp);nodep->deleteTree(); VL_DANGLING(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Xor_3(AstXor* nodep) {
	// TREEOP ("AstXor    {operandsSame($lhsp,,$rhsp)}",	"replaceZero(nodep)")
	if (m_doNConst && operandsSame(nodep->lhsp(),nodep->rhsp())) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstXor operandsSame($lhsp,,$rhsp) , replaceZero(nodep) )\n");
	    replaceZero(nodep);
	    return true;
	}
	return false;
    }
    // Generated by astgen
    bool match_Xor_4(AstXor* nodep) {
	// TREEOP ("AstXor {operandShiftSame(nodep)}",		"replaceShiftSame(nodep)")
	if (m_doNConst && operandShiftSame(nodep)) {
	    UINFO(7,(void*)(nodep)<<" TREEOP ( AstXor operandShiftSame(nodep) , replaceShiftSame(nodep) )\n");
	    replaceShiftSame(nodep);
	    return true;
	}
	return false;
    }
    // TREEOP visitors, call each base type's match
    // Bottom class up, as more simple transforms are generally better
    // Generated by astgen
    virtual void visit(AstAdd* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeBiop_0(nodep)) return;
	if (match_NodeBiCom_0(nodep)) return;
	if (match_NodeBiComAsv_0(nodep)) return;
	if (match_NodeBiComAsv_1(nodep)) return;
	if (match_NodeBiComAsv_2(nodep)) return;
	if (match_NodeBiComAsv_3(nodep)) return;
	if (match_Add_0(nodep)) return;
	if (match_Add_1(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstAddD* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeBiop_0(nodep)) return;
	if (match_NodeBiCom_0(nodep)) return;
	if (match_NodeBiComAsv_0(nodep)) return;
	if (match_NodeBiComAsv_1(nodep)) return;
	if (match_NodeBiComAsv_2(nodep)) return;
	if (match_NodeBiComAsv_3(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstAnd* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeBiop_0(nodep)) return;
	if (match_NodeBiCom_0(nodep)) return;
	if (match_NodeBiComAsv_0(nodep)) return;
	if (match_NodeBiComAsv_1(nodep)) return;
	if (match_NodeBiComAsv_2(nodep)) return;
	if (match_NodeBiComAsv_3(nodep)) return;
	if (match_And_0(nodep)) return;
	if (match_And_1(nodep)) return;
	if (match_And_2(nodep)) return;
	if (match_And_3(nodep)) return;
	if (match_And_4(nodep)) return;
	if (match_And_5(nodep)) return;
	if (match_And_6(nodep)) return;
    }
    // Generated by astgen
    virtual void visitGen(AstArraySel* nodep) {
	if (match_NodeBiop_0(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstBitsToRealD* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeUniop_0(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstBufIf1* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeBiop_0(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstCCast* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeUniop_0(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstCLog2* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeUniop_0(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstCeilD* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeUniop_0(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstChangeXor* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeBiop_0(nodep)) return;
	if (match_NodeBiCom_0(nodep)) return;
	if (match_NodeBiComAsv_0(nodep)) return;
	if (match_NodeBiComAsv_1(nodep)) return;
	if (match_NodeBiComAsv_2(nodep)) return;
	if (match_NodeBiComAsv_3(nodep)) return;
	if (match_ChangeXor_0(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstConcat* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeBiop_0(nodep)) return;
	if (match_Concat_0(nodep)) return;
	if (match_Concat_1(nodep)) return;
	if (match_Concat_2(nodep)) return;
	if (match_Concat_3(nodep)) return;
	if (match_Concat_4(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstConcatN* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeBiop_0(nodep)) return;
    }
    // Generated by astgen with short-circuiting
    virtual void visit(AstCond* nodep) {
	nodep->lhsp()->iterateAndNext(*this);
	if (match_Cond_0(nodep)) return;
	if (match_Cond_1(nodep)) return;
	nodep->rhsp()->iterateAndNext(*this);
	AstNodeTriop *tnp = nodep->castNodeTriop();
	if (tnp && tnp->thsp()) tnp->thsp()->iterateAndNext(*this);
	if (match_NodeCond_0(nodep)) return;
	if (match_NodeCond_1(nodep)) return;
	if (match_NodeCond_2(nodep)) return;
	if (match_NodeCond_3(nodep)) return;
	if (match_NodeCond_4(nodep)) return;
	if (match_NodeCond_5(nodep)) return;
	if (match_NodeCond_6(nodep)) return;
	if (match_NodeCond_7(nodep)) return;
	if (match_NodeCond_8(nodep)) return;
	if (match_NodeCond_9(nodep)) return;
	if (match_Cond_2(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstCondBound* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeCond_0(nodep)) return;
	if (match_NodeCond_1(nodep)) return;
	if (match_NodeCond_2(nodep)) return;
	if (match_NodeCond_3(nodep)) return;
	if (match_NodeCond_4(nodep)) return;
	if (match_NodeCond_5(nodep)) return;
	if (match_NodeCond_6(nodep)) return;
	if (match_NodeCond_7(nodep)) return;
	if (match_NodeCond_8(nodep)) return;
	if (match_NodeCond_9(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstCountOnes* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeUniop_0(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstCvtPackString* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeUniop_0(nodep)) return;
	if (match_CvtPackString_0(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstDiv* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeBiop_0(nodep)) return;
	if (match_Div_0(nodep)) return;
	if (match_Div_1(nodep)) return;
	if (match_Div_2(nodep)) return;
	if (match_Div_3(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstDivD* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeBiop_0(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstDivS* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeBiop_0(nodep)) return;
	if (match_DivS_0(nodep)) return;
	if (match_DivS_1(nodep)) return;
	if (match_DivS_2(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstEq* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeBiop_0(nodep)) return;
	if (match_NodeBiCom_0(nodep)) return;
	if (match_Eq_0(nodep)) return;
	if (match_Eq_1(nodep)) return;
	if (match_Eq_2(nodep)) return;
	if (match_Eq_3(nodep)) return;
	if (match_Eq_4(nodep)) return;
	if (match_Eq_5(nodep)) return;
	if (match_Eq_6(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstEqCase* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeBiop_0(nodep)) return;
	if (match_NodeBiCom_0(nodep)) return;
	if (match_EqCase_0(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstEqD* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeBiop_0(nodep)) return;
	if (match_NodeBiCom_0(nodep)) return;
	if (match_EqD_0(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstEqN* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeBiop_0(nodep)) return;
	if (match_NodeBiCom_0(nodep)) return;
	if (match_EqN_0(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstEqWild* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeBiop_0(nodep)) return;
	if (match_EqWild_0(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstExpD* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeUniop_0(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstExtend* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeUniop_0(nodep)) return;
	if (match_Extend_0(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstExtendS* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeUniop_0(nodep)) return;
	if (match_ExtendS_0(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstFEof* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeUniop_0(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstFGetC* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeUniop_0(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstFGetS* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeBiop_0(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstFloorD* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeUniop_0(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstGt* nodep) {
	nodep->iterateChildren(*this);
	if (match_Gt_2(nodep)) return;
	if (match_Gt_1(nodep)) return;
	if (match_NodeBiop_0(nodep)) return;
	if (match_Gt_0(nodep)) return;
	if (match_Gt_3(nodep)) return;
	if (match_Gt_4(nodep)) return;
	if (match_Gt_5(nodep)) return;
	if (match_Gt_6(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstGtD* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeBiop_0(nodep)) return;
	if (match_GtD_0(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstGtN* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeBiop_0(nodep)) return;
	if (match_GtN_0(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstGtS* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeBiop_0(nodep)) return;
	if (match_GtS_0(nodep)) return;
	if (match_GtS_1(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstGte* nodep) {
	nodep->iterateChildren(*this);
	if (match_Gte_2(nodep)) return;
	if (match_Gte_1(nodep)) return;
	if (match_NodeBiop_0(nodep)) return;
	if (match_Gte_0(nodep)) return;
	if (match_Gte_3(nodep)) return;
	if (match_Gte_4(nodep)) return;
	if (match_Gte_5(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstGteD* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeBiop_0(nodep)) return;
	if (match_GteD_0(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstGteN* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeBiop_0(nodep)) return;
	if (match_GteN_0(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstGteS* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeBiop_0(nodep)) return;
	if (match_GteS_0(nodep)) return;
	if (match_GteS_1(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstIToRD* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeUniop_0(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstIsUnknown* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeUniop_0(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstLenN* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeUniop_0(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstLog10D* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeUniop_0(nodep)) return;
    }
    // Generated by astgen with short-circuiting
    virtual void visit(AstLogAnd* nodep) {
	nodep->lhsp()->iterateAndNext(*this);
	if (match_LogAnd_0(nodep)) return;
	nodep->rhsp()->iterateAndNext(*this);
	AstNodeTriop *tnp = nodep->castNodeTriop();
	if (tnp && tnp->thsp()) tnp->thsp()->iterateAndNext(*this);
	if (match_NodeBiop_0(nodep)) return;
	if (match_LogAnd_1(nodep)) return;
	if (match_LogAnd_2(nodep)) return;
	if (match_LogAnd_3(nodep)) return;
	if (match_LogAnd_4(nodep)) return;
	if (match_LogAnd_5(nodep)) return;
	if (match_LogAnd_6(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstLogD* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeUniop_0(nodep)) return;
    }
    // Generated by astgen with short-circuiting
    virtual void visit(AstLogIf* nodep) {
	nodep->lhsp()->iterateAndNext(*this);
	if (match_LogIf_0(nodep)) return;
	nodep->rhsp()->iterateAndNext(*this);
	AstNodeTriop *tnp = nodep->castNodeTriop();
	if (tnp && tnp->thsp()) tnp->thsp()->iterateAndNext(*this);
	if (match_NodeBiop_0(nodep)) return;
	if (match_LogIf_1(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstLogIff* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeBiop_0(nodep)) return;
	if (match_NodeBiCom_0(nodep)) return;
	if (match_LogIff_0(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstLogNot* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeUniop_0(nodep)) return;
	if (match_LogNot_0(nodep)) return;
	if (match_LogNot_1(nodep)) return;
	if (match_LogNot_2(nodep)) return;
	if (match_LogNot_3(nodep)) return;
	if (match_LogNot_4(nodep)) return;
	if (match_LogNot_5(nodep)) return;
	if (match_LogNot_6(nodep)) return;
	if (match_LogNot_7(nodep)) return;
	if (match_LogNot_8(nodep)) return;
	if (match_LogNot_9(nodep)) return;
	if (match_LogNot_10(nodep)) return;
	if (match_LogNot_11(nodep)) return;
	if (match_LogNot_12(nodep)) return;
	if (match_LogNot_13(nodep)) return;
	if (match_LogNot_14(nodep)) return;
	if (match_LogNot_15(nodep)) return;
    }
    // Generated by astgen with short-circuiting
    virtual void visit(AstLogOr* nodep) {
	nodep->lhsp()->iterateAndNext(*this);
	if (match_LogOr_0(nodep)) return;
	nodep->rhsp()->iterateAndNext(*this);
	AstNodeTriop *tnp = nodep->castNodeTriop();
	if (tnp && tnp->thsp()) tnp->thsp()->iterateAndNext(*this);
	if (match_NodeBiop_0(nodep)) return;
	if (match_LogOr_1(nodep)) return;
	if (match_LogOr_2(nodep)) return;
	if (match_LogOr_3(nodep)) return;
	if (match_LogOr_4(nodep)) return;
	if (match_LogOr_5(nodep)) return;
	if (match_LogOr_6(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstLt* nodep) {
	nodep->iterateChildren(*this);
	if (match_Lt_2(nodep)) return;
	if (match_Lt_1(nodep)) return;
	if (match_NodeBiop_0(nodep)) return;
	if (match_Lt_0(nodep)) return;
	if (match_Lt_3(nodep)) return;
	if (match_Lt_4(nodep)) return;
	if (match_Lt_5(nodep)) return;
	if (match_Lt_6(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstLtD* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeBiop_0(nodep)) return;
	if (match_LtD_0(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstLtN* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeBiop_0(nodep)) return;
	if (match_LtN_0(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstLtS* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeBiop_0(nodep)) return;
	if (match_LtS_0(nodep)) return;
	if (match_LtS_1(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstLte* nodep) {
	nodep->iterateChildren(*this);
	if (match_Lte_2(nodep)) return;
	if (match_Lte_1(nodep)) return;
	if (match_NodeBiop_0(nodep)) return;
	if (match_Lte_0(nodep)) return;
	if (match_Lte_3(nodep)) return;
	if (match_Lte_4(nodep)) return;
	if (match_Lte_5(nodep)) return;
	if (match_Lte_6(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstLteD* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeBiop_0(nodep)) return;
	if (match_LteD_0(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstLteN* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeBiop_0(nodep)) return;
	if (match_LteN_0(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstLteS* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeBiop_0(nodep)) return;
	if (match_LteS_0(nodep)) return;
	if (match_LteS_1(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstModDiv* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeBiop_0(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstModDivS* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeBiop_0(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstMul* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeBiop_0(nodep)) return;
	if (match_NodeBiCom_0(nodep)) return;
	if (match_NodeBiComAsv_0(nodep)) return;
	if (match_NodeBiComAsv_1(nodep)) return;
	if (match_NodeBiComAsv_2(nodep)) return;
	if (match_NodeBiComAsv_3(nodep)) return;
	if (match_Mul_0(nodep)) return;
	if (match_Mul_1(nodep)) return;
	if (match_Mul_2(nodep)) return;
	if (match_Mul_3(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstMulD* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeBiop_0(nodep)) return;
	if (match_NodeBiCom_0(nodep)) return;
	if (match_NodeBiComAsv_0(nodep)) return;
	if (match_NodeBiComAsv_1(nodep)) return;
	if (match_NodeBiComAsv_2(nodep)) return;
	if (match_NodeBiComAsv_3(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstMulS* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeBiop_0(nodep)) return;
	if (match_NodeBiCom_0(nodep)) return;
	if (match_NodeBiComAsv_0(nodep)) return;
	if (match_NodeBiComAsv_1(nodep)) return;
	if (match_NodeBiComAsv_2(nodep)) return;
	if (match_NodeBiComAsv_3(nodep)) return;
	if (match_MulS_0(nodep)) return;
	if (match_MulS_1(nodep)) return;
	if (match_MulS_2(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstNegate* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeUniop_0(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstNegateD* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeUniop_0(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstNeq* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeBiop_0(nodep)) return;
	if (match_NodeBiCom_0(nodep)) return;
	if (match_Neq_0(nodep)) return;
	if (match_Neq_1(nodep)) return;
	if (match_Neq_2(nodep)) return;
	if (match_Neq_3(nodep)) return;
	if (match_Neq_4(nodep)) return;
	if (match_Neq_5(nodep)) return;
	if (match_Neq_6(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstNeqCase* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeBiop_0(nodep)) return;
	if (match_NodeBiCom_0(nodep)) return;
	if (match_NeqCase_0(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstNeqD* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeBiop_0(nodep)) return;
	if (match_NodeBiCom_0(nodep)) return;
	if (match_NeqD_0(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstNeqN* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeBiop_0(nodep)) return;
	if (match_NodeBiCom_0(nodep)) return;
	if (match_NeqN_0(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstNeqWild* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeBiop_0(nodep)) return;
	if (match_NeqWild_0(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstNodeBiCom* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeBiop_0(nodep)) return;
	if (match_NodeBiCom_0(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstNodeBiComAsv* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeBiop_0(nodep)) return;
	if (match_NodeBiCom_0(nodep)) return;
	if (match_NodeBiComAsv_0(nodep)) return;
	if (match_NodeBiComAsv_1(nodep)) return;
	if (match_NodeBiComAsv_2(nodep)) return;
	if (match_NodeBiComAsv_3(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstNodeBiop* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeBiop_0(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstNodeCond* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeCond_0(nodep)) return;
	if (match_NodeCond_1(nodep)) return;
	if (match_NodeCond_2(nodep)) return;
	if (match_NodeCond_3(nodep)) return;
	if (match_NodeCond_4(nodep)) return;
	if (match_NodeCond_5(nodep)) return;
	if (match_NodeCond_6(nodep)) return;
	if (match_NodeCond_7(nodep)) return;
	if (match_NodeCond_8(nodep)) return;
	if (match_NodeCond_9(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstNodeSel* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeBiop_0(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstNodeStream* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeBiop_0(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstNodeUniop* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeUniop_0(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstNot* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeUniop_0(nodep)) return;
	if (match_Not_0(nodep)) return;
	if (match_Not_1(nodep)) return;
	if (match_Not_2(nodep)) return;
	if (match_Not_3(nodep)) return;
	if (match_Not_4(nodep)) return;
	if (match_Not_5(nodep)) return;
	if (match_Not_6(nodep)) return;
	if (match_Not_7(nodep)) return;
	if (match_Not_8(nodep)) return;
	if (match_Not_9(nodep)) return;
	if (match_Not_10(nodep)) return;
	if (match_Not_11(nodep)) return;
	if (match_Not_12(nodep)) return;
	if (match_Not_13(nodep)) return;
	if (match_Not_14(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstOneHot* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeUniop_0(nodep)) return;
	if (match_OneHot_0(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstOneHot0* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeUniop_0(nodep)) return;
	if (match_OneHot0_0(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstOr* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeBiop_0(nodep)) return;
	if (match_NodeBiCom_0(nodep)) return;
	if (match_NodeBiComAsv_0(nodep)) return;
	if (match_NodeBiComAsv_1(nodep)) return;
	if (match_NodeBiComAsv_2(nodep)) return;
	if (match_NodeBiComAsv_3(nodep)) return;
	if (match_Or_0(nodep)) return;
	if (match_Or_1(nodep)) return;
	if (match_Or_2(nodep)) return;
	if (match_Or_3(nodep)) return;
	if (match_Or_4(nodep)) return;
	if (match_Or_5(nodep)) return;
	if (match_Or_6(nodep)) return;
	if (match_Or_7(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstPow* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeBiop_0(nodep)) return;
	if (match_Pow_0(nodep)) return;
	if (match_Pow_1(nodep)) return;
	if (match_Pow_2(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstPowD* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeBiop_0(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstPowSS* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeBiop_0(nodep)) return;
	if (match_PowSS_0(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstPowSU* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeBiop_0(nodep)) return;
	if (match_PowSU_0(nodep)) return;
	if (match_PowSU_1(nodep)) return;
	if (match_PowSU_2(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstPowUS* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeBiop_0(nodep)) return;
	if (match_PowUS_0(nodep)) return;
	if (match_PowUS_1(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstRToIRoundS* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeUniop_0(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstRToIS* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeUniop_0(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstRealToBits* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeUniop_0(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstRedAnd* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeUniop_0(nodep)) return;
	if (match_RedAnd_0(nodep)) return;
	if (match_RedAnd_1(nodep)) return;
	if (match_RedAnd_2(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstRedOr* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeUniop_0(nodep)) return;
	if (match_RedOr_0(nodep)) return;
	if (match_RedOr_1(nodep)) return;
	if (match_RedOr_2(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstRedXnor* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeUniop_0(nodep)) return;
	if (match_RedXnor_0(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstRedXor* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeUniop_0(nodep)) return;
	if (match_RedXor_0(nodep)) return;
	if (match_RedXor_1(nodep)) return;
	if (match_RedXor_2(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstReplicate* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeBiop_0(nodep)) return;
	if (match_Replicate_0(nodep)) return;
	if (match_Replicate_1(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstReplicateN* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeBiop_0(nodep)) return;
	if (match_ReplicateN_0(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstSel* nodep) {
	nodep->iterateChildren(*this);
	if (match_Sel_0(nodep)) return;
	if (match_Sel_1(nodep)) return;
	if (match_Sel_2(nodep)) return;
	if (match_Sel_3(nodep)) return;
	if (match_Sel_4(nodep)) return;
	if (match_Sel_5(nodep)) return;
	if (match_Sel_6(nodep)) return;
	if (match_Sel_7(nodep)) return;
	if (match_Sel_8(nodep)) return;
	if (match_Sel_9(nodep)) return;
	if (match_Sel_10(nodep)) return;
	if (match_Sel_11(nodep)) return;
	if (match_Sel_12(nodep)) return;
	if (match_Sel_13(nodep)) return;
	if (match_Sel_14(nodep)) return;
	if (match_Sel_15(nodep)) return;
	if (match_Sel_16(nodep)) return;
	if (match_Sel_17(nodep)) return;
	if (match_Sel_18(nodep)) return;
	if (match_Sel_19(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstShiftL* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeBiop_0(nodep)) return;
	if (match_ShiftL_0(nodep)) return;
	if (match_ShiftL_1(nodep)) return;
	if (match_ShiftL_2(nodep)) return;
	if (match_ShiftL_3(nodep)) return;
	if (match_ShiftL_4(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstShiftR* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeBiop_0(nodep)) return;
	if (match_ShiftR_0(nodep)) return;
	if (match_ShiftR_1(nodep)) return;
	if (match_ShiftR_2(nodep)) return;
	if (match_ShiftR_3(nodep)) return;
	if (match_ShiftR_4(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstShiftRS* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeBiop_0(nodep)) return;
	if (match_ShiftRS_0(nodep)) return;
	if (match_ShiftRS_1(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstSigned* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeUniop_0(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstSqrtD* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeUniop_0(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstStreamL* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeBiop_0(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstStreamR* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeBiop_0(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstSub* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeBiop_0(nodep)) return;
	if (match_Sub_0(nodep)) return;
	if (match_Sub_1(nodep)) return;
	if (match_Sub_2(nodep)) return;
	if (match_Sub_3(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstSubD* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeBiop_0(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstUnsigned* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeUniop_0(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstWordSel* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeBiop_0(nodep)) return;
	if (match_WordSel_0(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstXnor* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeBiop_0(nodep)) return;
	if (match_NodeBiCom_0(nodep)) return;
	if (match_NodeBiComAsv_0(nodep)) return;
	if (match_NodeBiComAsv_1(nodep)) return;
	if (match_NodeBiComAsv_2(nodep)) return;
	if (match_NodeBiComAsv_3(nodep)) return;
	if (match_Xnor_0(nodep)) return;
	if (match_Xnor_1(nodep)) return;
	if (match_Xnor_2(nodep)) return;
	if (match_Xnor_3(nodep)) return;
    }
    // Generated by astgen
    virtual void visit(AstXor* nodep) {
	nodep->iterateChildren(*this);
	if (match_NodeBiop_0(nodep)) return;
	if (match_NodeBiCom_0(nodep)) return;
	if (match_NodeBiComAsv_0(nodep)) return;
	if (match_NodeBiComAsv_1(nodep)) return;
	if (match_NodeBiComAsv_2(nodep)) return;
	if (match_NodeBiComAsv_3(nodep)) return;
	if (match_Xor_0(nodep)) return;
	if (match_Xor_1(nodep)) return;
	if (match_Xor_2(nodep)) return;
	if (match_Xor_3(nodep)) return;
	if (match_Xor_4(nodep)) return;
    }
#line 2148 "../V3Const.cpp"
    // Generic constants on both side.  Do this first to avoid other replacements
//    TREEOPC("AstNodeBiop {$lhsp.castConst, $rhsp.castConst}",  "replaceConst(nodep)");
#line 5631 "V3Const__gen.cpp"
#line 2150 "../V3Const.cpp"
//    TREEOPC("AstNodeUniop{$lhsp.castConst, !nodep->isOpaque()}",  "replaceConst(nodep)");
#line 5634 "V3Const__gen.cpp"
#line 2151 "../V3Const.cpp"
    // Zero on one side or the other
//    TREEOP ("AstAdd   {$lhsp.isZero, $rhsp}",	"replaceWRhs(nodep)");
#line 5638 "V3Const__gen.cpp"
#line 2153 "../V3Const.cpp"
//    TREEOP ("AstAnd   {$lhsp.isZero, $rhsp, isTPure($rhsp)}",	"replaceZero(nodep)");  // Can't use replaceZeroChkPure as we make this pattern in ChkPure
#line 5641 "V3Const__gen.cpp"
#line 2154 "../V3Const.cpp"
    // This visit function here must allow for short-circuiting.
//    TREEOPS("AstLogAnd   {$lhsp.isZero}",	"replaceZero(nodep)");
#line 5645 "V3Const__gen.cpp"
#line 2156 "../V3Const.cpp"
//    TREEOP ("AstLogAnd{$lhsp.isZero, $rhsp}",	"replaceZero(nodep)");
#line 5648 "V3Const__gen.cpp"
#line 2157 "../V3Const.cpp"
    // This visit function here must allow for short-circuiting.
//    TREEOPS("AstLogOr   {$lhsp.isOne}",		"replaceNum(nodep, 1)");
#line 5652 "V3Const__gen.cpp"
#line 2159 "../V3Const.cpp"
//    TREEOP ("AstLogOr {$lhsp.isZero, $rhsp}",	"replaceWRhs(nodep)");
#line 5655 "V3Const__gen.cpp"
#line 2160 "../V3Const.cpp"
//    TREEOP ("AstDiv   {$lhsp.isZero, $rhsp}",	"replaceZeroChkPure(nodep,$rhsp)");
#line 5658 "V3Const__gen.cpp"
#line 2161 "../V3Const.cpp"
//    TREEOP ("AstDivS  {$lhsp.isZero, $rhsp}",	"replaceZeroChkPure(nodep,$rhsp)");
#line 5661 "V3Const__gen.cpp"
#line 2162 "../V3Const.cpp"
//    TREEOP ("AstMul   {$lhsp.isZero, $rhsp}",	"replaceZeroChkPure(nodep,$rhsp)");
#line 5664 "V3Const__gen.cpp"
#line 2163 "../V3Const.cpp"
//    TREEOP ("AstMulS  {$lhsp.isZero, $rhsp}",	"replaceZeroChkPure(nodep,$rhsp)");
#line 5667 "V3Const__gen.cpp"
#line 2164 "../V3Const.cpp"
//    TREEOP ("AstPow   {$rhsp.isZero}",		"replaceNum(nodep, 1)");  // Overrides lhs zero rule
#line 5670 "V3Const__gen.cpp"
#line 2165 "../V3Const.cpp"
//    TREEOP ("AstPowSS {$rhsp.isZero}",		"replaceNum(nodep, 1)");  // Overrides lhs zero rule
#line 5673 "V3Const__gen.cpp"
#line 2166 "../V3Const.cpp"
//    TREEOP ("AstPowSU {$rhsp.isZero}",		"replaceNum(nodep, 1)");  // Overrides lhs zero rule
#line 5676 "V3Const__gen.cpp"
#line 2167 "../V3Const.cpp"
//    TREEOP ("AstPowUS {$rhsp.isZero}",		"replaceNum(nodep, 1)");  // Overrides lhs zero rule
#line 5679 "V3Const__gen.cpp"
#line 2168 "../V3Const.cpp"
//    TREEOP ("AstPow   {$lhsp.isZero, !$rhsp.isZero}",	"replaceZeroChkPure(nodep,$rhsp)");
#line 5682 "V3Const__gen.cpp"
#line 2169 "../V3Const.cpp"
//    TREEOP ("AstPowSU {$lhsp.isZero, !$rhsp.isZero}",	"replaceZeroChkPure(nodep,$rhsp)");
#line 5685 "V3Const__gen.cpp"
#line 2170 "../V3Const.cpp"
//    TREEOP ("AstPowUS {$lhsp.isZero, !$rhsp.isZero}",	"replaceZeroChkPure(nodep,$rhsp)");
#line 5688 "V3Const__gen.cpp"
#line 2171 "../V3Const.cpp"
//    TREEOP ("AstPowSU {$lhsp.isZero, !$rhsp.isZero}",	"replaceZeroChkPure(nodep,$rhsp)");
#line 5691 "V3Const__gen.cpp"
#line 2172 "../V3Const.cpp"
//    TREEOP ("AstOr    {$lhsp.isZero, $rhsp}",	"replaceWRhs(nodep)");
#line 5694 "V3Const__gen.cpp"
#line 2173 "../V3Const.cpp"
//    TREEOP ("AstShiftL{$lhsp.isZero, $rhsp}",	"replaceZeroChkPure(nodep,$rhsp)");
#line 5697 "V3Const__gen.cpp"
#line 2174 "../V3Const.cpp"
//    TREEOP ("AstShiftR{$lhsp.isZero, $rhsp}",	"replaceZeroChkPure(nodep,$rhsp)");
#line 5700 "V3Const__gen.cpp"
#line 2175 "../V3Const.cpp"
//    TREEOP ("AstShiftRS{$lhsp.isZero, $rhsp}",	"replaceZeroChkPure(nodep,$rhsp)");
#line 5703 "V3Const__gen.cpp"
#line 2176 "../V3Const.cpp"
//    TREEOP ("AstXor   {$lhsp.isZero, $rhsp}",	"replaceWRhs(nodep)");
#line 5706 "V3Const__gen.cpp"
#line 2177 "../V3Const.cpp"
//    TREEOP ("AstXnor  {$lhsp.isZero, $rhsp}",	"AstNot{$rhsp}");
#line 5709 "V3Const__gen.cpp"
#line 2178 "../V3Const.cpp"
//    TREEOP ("AstSub   {$lhsp.isZero, $rhsp}",	"AstNegate{$rhsp}");
#line 5712 "V3Const__gen.cpp"
#line 2179 "../V3Const.cpp"
//    TREEOP ("AstAdd   {$lhsp, $rhsp.isZero}",	"replaceWLhs(nodep)");
#line 5715 "V3Const__gen.cpp"
#line 2180 "../V3Const.cpp"
//    TREEOP ("AstAnd   {$lhsp, $rhsp.isZero}",	"replaceZeroChkPure(nodep,$lhsp)");
#line 5718 "V3Const__gen.cpp"
#line 2181 "../V3Const.cpp"
//    TREEOP ("AstLogAnd{$lhsp, $rhsp.isZero}",	"replaceZeroChkPure(nodep,$lhsp)");
#line 5721 "V3Const__gen.cpp"
#line 2182 "../V3Const.cpp"
//    TREEOP ("AstLogOr {$lhsp, $rhsp.isZero}",	"replaceWLhs(nodep)");
#line 5724 "V3Const__gen.cpp"
#line 2183 "../V3Const.cpp"
//    TREEOP ("AstMul   {$lhsp, $rhsp.isZero}",	"replaceZeroChkPure(nodep,$lhsp)");
#line 5727 "V3Const__gen.cpp"
#line 2184 "../V3Const.cpp"
//    TREEOP ("AstMulS  {$lhsp, $rhsp.isZero}",	"replaceZeroChkPure(nodep,$lhsp)");
#line 5730 "V3Const__gen.cpp"
#line 2185 "../V3Const.cpp"
//    TREEOP ("AstOr    {$lhsp, $rhsp.isZero}",	"replaceWLhs(nodep)");
#line 5733 "V3Const__gen.cpp"
#line 2186 "../V3Const.cpp"
//    TREEOP ("AstShiftL{$lhsp, $rhsp.isZero}",	"replaceWLhs(nodep)");
#line 5736 "V3Const__gen.cpp"
#line 2187 "../V3Const.cpp"
//    TREEOP ("AstShiftR{$lhsp, $rhsp.isZero}",	"replaceWLhs(nodep)");
#line 5739 "V3Const__gen.cpp"
#line 2188 "../V3Const.cpp"
//    TREEOP ("AstShiftRS{$lhsp, $rhsp.isZero}",	"replaceWLhs(nodep)");
#line 5742 "V3Const__gen.cpp"
#line 2189 "../V3Const.cpp"
//    TREEOP ("AstSub   {$lhsp, $rhsp.isZero}",	"replaceWLhs(nodep)");
#line 5745 "V3Const__gen.cpp"
#line 2190 "../V3Const.cpp"
//    TREEOP ("AstXor   {$lhsp, $rhsp.isZero}",	"replaceWLhs(nodep)");
#line 5748 "V3Const__gen.cpp"
#line 2191 "../V3Const.cpp"
//    TREEOP ("AstXnor  {$lhsp, $rhsp.isZero}",	"AstNot{$lhsp}");
#line 5751 "V3Const__gen.cpp"
#line 2192 "../V3Const.cpp"
    // Non-zero on one side or the other
//    TREEOP ("AstAnd   {$lhsp.isAllOnes, $rhsp}",	"replaceWRhs(nodep)");
#line 5755 "V3Const__gen.cpp"
#line 2194 "../V3Const.cpp"
//    TREEOP ("AstLogAnd{$lhsp.isNeqZero, $rhsp}",	"replaceWRhs(nodep)");
#line 5758 "V3Const__gen.cpp"
#line 2195 "../V3Const.cpp"
//    TREEOP ("AstOr    {$lhsp.isAllOnes, $rhsp, isTPure($rhsp)}",	"replaceWLhs(nodep)"); //->allOnes
#line 5761 "V3Const__gen.cpp"
#line 2196 "../V3Const.cpp"
//    TREEOP ("AstLogOr {$lhsp.isNeqZero, $rhsp}",	"replaceNum(nodep,1)");
#line 5764 "V3Const__gen.cpp"
#line 2197 "../V3Const.cpp"
//    TREEOP ("AstAnd   {$lhsp, $rhsp.isAllOnes}",	"replaceWLhs(nodep)");
#line 5767 "V3Const__gen.cpp"
#line 2198 "../V3Const.cpp"
//    TREEOP ("AstLogAnd{$lhsp, $rhsp.isNeqZero}",	"replaceWLhs(nodep)");
#line 5770 "V3Const__gen.cpp"
#line 2199 "../V3Const.cpp"
//    TREEOP ("AstOr    {$lhsp, $rhsp.isAllOnes, isTPure($lhsp)}",	"replaceWRhs(nodep)"); //->allOnes
#line 5773 "V3Const__gen.cpp"
#line 2200 "../V3Const.cpp"
//    TREEOP ("AstLogOr {$lhsp, $rhsp.isNeqZero, isTPure($lhsp)}",	"replaceNum(nodep,1)");
#line 5776 "V3Const__gen.cpp"
#line 2201 "../V3Const.cpp"
//    TREEOP ("AstXor   {$lhsp.isAllOnes, $rhsp}",	"AstNot{$rhsp}");
#line 5779 "V3Const__gen.cpp"
#line 2202 "../V3Const.cpp"
//    TREEOP ("AstXnor  {$lhsp.isAllOnes, $rhsp}",	"replaceWRhs(nodep)");
#line 5782 "V3Const__gen.cpp"
#line 2203 "../V3Const.cpp"
//    TREEOP ("AstMul   {$lhsp.isOne, $rhsp}",	"replaceWRhs(nodep)");
#line 5785 "V3Const__gen.cpp"
#line 2204 "../V3Const.cpp"
//    TREEOP ("AstMulS  {$lhsp.isOne, $rhsp}",	"replaceWRhs(nodep)");
#line 5788 "V3Const__gen.cpp"
#line 2205 "../V3Const.cpp"
//    TREEOP ("AstDiv   {$lhsp, $rhsp.isOne}",	"replaceWLhs(nodep)");
#line 5791 "V3Const__gen.cpp"
#line 2206 "../V3Const.cpp"
//    TREEOP ("AstDivS  {$lhsp, $rhsp.isOne}",	"replaceWLhs(nodep)");
#line 5794 "V3Const__gen.cpp"
#line 2207 "../V3Const.cpp"
//    TREEOP ("AstMul   {operandIsPowTwo($lhsp), $rhsp}",	"replaceMulShift(nodep)");  // a*2^n -> a<<n
#line 5797 "V3Const__gen.cpp"
#line 2208 "../V3Const.cpp"
//    TREEOP ("AstDiv   {$lhsp, operandIsPowTwo($rhsp)}",	"replaceDivShift(nodep)");  // a/2^n -> a>>n
#line 5800 "V3Const__gen.cpp"
#line 2209 "../V3Const.cpp"
//    TREEOP ("AstPow   {operandIsTwo($lhsp), $rhsp}",	"replacePowShift(nodep)");  // 2**a == 1<<a
#line 5803 "V3Const__gen.cpp"
#line 2210 "../V3Const.cpp"
//    TREEOP ("AstSub   {$lhsp.castAdd, operandSubAdd(nodep)}", "AstAdd{AstSub{$lhsp->castAdd()->lhsp(),$rhsp}, $lhsp->castAdd()->rhsp()}"); // ((a+x)-y) -> (a+(x-y))
#line 5806 "V3Const__gen.cpp"
#line 2211 "../V3Const.cpp"
    // Trinary ops
    // Note V3Case::Sel requires Cond to always be conditionally executed in C to prevent core dump!
//    TREEOP ("AstNodeCond{$condp.isZero,       $expr1p, $expr2p}", "replaceWChild(nodep,$expr2p)");
#line 5811 "V3Const__gen.cpp"
#line 2214 "../V3Const.cpp"
//    TREEOP ("AstNodeCond{$condp.isNeqZero,    $expr1p, $expr2p}", "replaceWChild(nodep,$expr1p)");
#line 5814 "V3Const__gen.cpp"
#line 2215 "../V3Const.cpp"
//    TREEOPC("AstNodeCond{$condp.isZero,       $expr1p.castConst, $expr2p.castConst}", "replaceWChild(nodep,$expr2p)");
#line 5817 "V3Const__gen.cpp"
#line 2216 "../V3Const.cpp"
//    TREEOPC("AstNodeCond{$condp.isNeqZero,    $expr1p.castConst, $expr2p.castConst}", "replaceWChild(nodep,$expr1p)");
#line 5820 "V3Const__gen.cpp"
#line 2217 "../V3Const.cpp"
//    TREEOP ("AstNodeCond{$condp, operandsSame($expr1p,,$expr2p)}","replaceWChild(nodep,$expr1p)");
#line 5823 "V3Const__gen.cpp"
#line 2218 "../V3Const.cpp"
    // This visit function here must allow for short-circuiting.
//    TREEOPS("AstCond {$lhsp.isZero}",		"replaceWIteratedThs(nodep)");
#line 5827 "V3Const__gen.cpp"
#line 2220 "../V3Const.cpp"
//    TREEOPS("AstCond {$lhsp.isNeqZero}",	"replaceWIteratedRhs(nodep)");
#line 5830 "V3Const__gen.cpp"
#line 2221 "../V3Const.cpp"
//    TREEOP ("AstCond{$condp.castNot,       $expr1p, $expr2p}", "AstCond{$condp->op1p(), $expr2p, $expr1p}");
#line 5833 "V3Const__gen.cpp"
#line 2222 "../V3Const.cpp"
//    TREEOP ("AstNodeCond{$condp.width1, $expr1p.width1,   $expr1p.isAllOnes, $expr2p}", "AstLogOr {$condp, $expr2p}");  // a?1:b == a||b
#line 5836 "V3Const__gen.cpp"
#line 2223 "../V3Const.cpp"
//    TREEOP ("AstNodeCond{$condp.width1, $expr1p.width1,   $expr1p,    $expr2p.isZero}", "AstLogAnd{$condp, $expr1p}");  // a?b:0 == a&&b
#line 5839 "V3Const__gen.cpp"
#line 2224 "../V3Const.cpp"
//    TREEOP ("AstNodeCond{$condp.width1, $expr1p.width1,   $expr1p, $expr2p.isAllOnes}", "AstLogOr {AstNot{$condp}, $expr1p}");  // a?b:1 == ~a||b
#line 5842 "V3Const__gen.cpp"
#line 2225 "../V3Const.cpp"
//    TREEOP ("AstNodeCond{$condp.width1, $expr1p.width1,   $expr1p.isZero,    $expr2p}", "AstLogAnd{AstNot{$condp}, $expr2p}");  // a?0:b == ~a&&b
#line 5845 "V3Const__gen.cpp"
#line 2226 "../V3Const.cpp"
//    TREEOP ("AstNodeCond{!$condp.width1, operandBoolShift(nodep->condp())}", "replaceBoolShift(nodep->condp())");
#line 5848 "V3Const__gen.cpp"
#line 2227 "../V3Const.cpp"
    // Prefer constants on left, since that often needs a shift, it lets constant red remove the shift
//    TREEOP ("AstNodeBiCom{!$lhsp.castConst, $rhsp.castConst}",	"swapSides(nodep)");
#line 5852 "V3Const__gen.cpp"
#line 2229 "../V3Const.cpp"
//    TREEOP ("AstNodeBiComAsv{operandAsvConst(nodep)}",	"replaceAsv(nodep)");
#line 5855 "V3Const__gen.cpp"
#line 2230 "../V3Const.cpp"
//    TREEOP ("AstNodeBiComAsv{operandAsvSame(nodep)}",	"replaceAsv(nodep)");
#line 5858 "V3Const__gen.cpp"
#line 2231 "../V3Const.cpp"
//    TREEOP ("AstNodeBiComAsv{operandAsvLUp(nodep)}",	"replaceAsvLUp(nodep)");
#line 5861 "V3Const__gen.cpp"
#line 2232 "../V3Const.cpp"
//    TREEOP ("AstNodeBiComAsv{operandAsvRUp(nodep)}",	"replaceAsvRUp(nodep)");
#line 5864 "V3Const__gen.cpp"
#line 2233 "../V3Const.cpp"
//    TREEOP ("AstLt   {!$lhsp.castConst,$rhsp.castConst}",	"AstGt  {$rhsp,$lhsp}");
#line 5867 "V3Const__gen.cpp"
#line 2234 "../V3Const.cpp"
//    TREEOP ("AstLtS  {!$lhsp.castConst,$rhsp.castConst}",	"AstGtS {$rhsp,$lhsp}");
#line 5870 "V3Const__gen.cpp"
#line 2235 "../V3Const.cpp"
//    TREEOP ("AstLte  {!$lhsp.castConst,$rhsp.castConst}",	"AstGte {$rhsp,$lhsp}");
#line 5873 "V3Const__gen.cpp"
#line 2236 "../V3Const.cpp"
//    TREEOP ("AstLteS {!$lhsp.castConst,$rhsp.castConst}",	"AstGteS{$rhsp,$lhsp}");
#line 5876 "V3Const__gen.cpp"
#line 2237 "../V3Const.cpp"
//    TREEOP ("AstGt   {!$lhsp.castConst,$rhsp.castConst}",	"AstLt  {$rhsp,$lhsp}");
#line 5879 "V3Const__gen.cpp"
#line 2238 "../V3Const.cpp"
//    TREEOP ("AstGtS  {!$lhsp.castConst,$rhsp.castConst}",	"AstLtS {$rhsp,$lhsp}");
#line 5882 "V3Const__gen.cpp"
#line 2239 "../V3Const.cpp"
//    TREEOP ("AstGte  {!$lhsp.castConst,$rhsp.castConst}",	"AstLte {$rhsp,$lhsp}");
#line 5885 "V3Const__gen.cpp"
#line 2240 "../V3Const.cpp"
//    TREEOP ("AstGteS {!$lhsp.castConst,$rhsp.castConst}",	"AstLteS{$rhsp,$lhsp}");
#line 5888 "V3Const__gen.cpp"
#line 2241 "../V3Const.cpp"
    //    v--- *1* as These ops are always first, as we warn before replacing
//    TREEOP1("AstLt   {$lhsp, $rhsp.isZero}",		"replaceNumSigned(nodep,0)");
#line 5892 "V3Const__gen.cpp"
#line 2243 "../V3Const.cpp"
//    TREEOP1("AstGte  {$lhsp, $rhsp.isZero}",		"replaceNumSigned(nodep,1)");
#line 5895 "V3Const__gen.cpp"
#line 2244 "../V3Const.cpp"
//    TREEOP1("AstGt   {$lhsp.isZero, $rhsp}",		"replaceNumSigned(nodep,0)");
#line 5898 "V3Const__gen.cpp"
#line 2245 "../V3Const.cpp"
//    TREEOP1("AstLte  {$lhsp.isZero, $rhsp}",		"replaceNumSigned(nodep,1)");
#line 5901 "V3Const__gen.cpp"
#line 2246 "../V3Const.cpp"
//    TREEOP1("AstGt   {$lhsp, $rhsp.isAllOnes, $lhsp->width()==$rhsp->width()}",  "replaceNumLimited(nodep,0)");
#line 5904 "V3Const__gen.cpp"
#line 2247 "../V3Const.cpp"
//    TREEOP1("AstLte  {$lhsp, $rhsp.isAllOnes, $lhsp->width()==$rhsp->width()}",  "replaceNumLimited(nodep,1)");
#line 5907 "V3Const__gen.cpp"
#line 2248 "../V3Const.cpp"
//    TREEOP1("AstLt   {$lhsp.isAllOnes, $rhsp, $lhsp->width()==$rhsp->width()}",  "replaceNumLimited(nodep,0)");
#line 5910 "V3Const__gen.cpp"
#line 2249 "../V3Const.cpp"
//    TREEOP1("AstGte  {$lhsp.isAllOnes, $rhsp, $lhsp->width()==$rhsp->width()}",  "replaceNumLimited(nodep,1)");
#line 5913 "V3Const__gen.cpp"
#line 2250 "../V3Const.cpp"
    // Two level bubble pushing
//    TREEOP ("AstNot   {$lhsp.castNot,  $lhsp->width()==$lhsp->castNot()->lhsp()->width()}",	"replaceWChild(nodep, $lhsp->op1p())");  // NOT(NOT(x))->x
#line 5917 "V3Const__gen.cpp"
#line 2252 "../V3Const.cpp"
//    TREEOP ("AstLogNot{$lhsp.castLogNot}",		"replaceWChild(nodep, $lhsp->op1p())");  // LOGNOT(LOGNOT(x))->x
#line 5920 "V3Const__gen.cpp"
#line 2253 "../V3Const.cpp"
//    TREEOPV("AstNot   {$lhsp.castEqCase, $lhsp.width1}","AstNeqCase{$lhsp->op1p(),$lhsp->op2p()}");
#line 5923 "V3Const__gen.cpp"
#line 2254 "../V3Const.cpp"
//    TREEOP ("AstLogNot{$lhsp.castEqCase}",		"AstNeqCase{$lhsp->op1p(),$lhsp->op2p()}");
#line 5926 "V3Const__gen.cpp"
#line 2255 "../V3Const.cpp"
//    TREEOPV("AstNot   {$lhsp.castNeqCase, $lhsp.width1}","AstEqCase {$lhsp->op1p(),$lhsp->op2p()}");
#line 5929 "V3Const__gen.cpp"
#line 2256 "../V3Const.cpp"
//    TREEOP ("AstLogNot{$lhsp.castNeqCase}",		"AstEqCase {$lhsp->op1p(),$lhsp->op2p()}");
#line 5932 "V3Const__gen.cpp"
#line 2257 "../V3Const.cpp"
//    TREEOPV("AstNot   {$lhsp.castEqWild, $lhsp.width1}","AstNeqWild{$lhsp->op1p(),$lhsp->op2p()}");
#line 5935 "V3Const__gen.cpp"
#line 2258 "../V3Const.cpp"
//    TREEOP ("AstLogNot{$lhsp.castEqWild}",		"AstNeqWild{$lhsp->op1p(),$lhsp->op2p()}");
#line 5938 "V3Const__gen.cpp"
#line 2259 "../V3Const.cpp"
//    TREEOPV("AstNot   {$lhsp.castNeqWild, $lhsp.width1}","AstEqWild {$lhsp->op1p(),$lhsp->op2p()}");
#line 5941 "V3Const__gen.cpp"
#line 2260 "../V3Const.cpp"
//    TREEOP ("AstLogNot{$lhsp.castNeqWild}",		"AstEqWild {$lhsp->op1p(),$lhsp->op2p()}");
#line 5944 "V3Const__gen.cpp"
#line 2261 "../V3Const.cpp"
//    TREEOPV("AstNot   {$lhsp.castEq, $lhsp.width1}",	"AstNeq {$lhsp->op1p(),$lhsp->op2p()}");
#line 5947 "V3Const__gen.cpp"
#line 2262 "../V3Const.cpp"
//    TREEOP ("AstLogNot{$lhsp.castEq}",			"AstNeq {$lhsp->op1p(),$lhsp->op2p()}");
#line 5950 "V3Const__gen.cpp"
#line 2263 "../V3Const.cpp"
//    TREEOPV("AstNot   {$lhsp.castNeq, $lhsp.width1}",	"AstEq  {$lhsp->op1p(),$lhsp->op2p()}");
#line 5953 "V3Const__gen.cpp"
#line 2264 "../V3Const.cpp"
//    TREEOP ("AstLogNot{$lhsp.castNeq}",			"AstEq  {$lhsp->op1p(),$lhsp->op2p()}");
#line 5956 "V3Const__gen.cpp"
#line 2265 "../V3Const.cpp"
//    TREEOPV("AstNot   {$lhsp.castLt, $lhsp.width1}",	"AstGte {$lhsp->op1p(),$lhsp->op2p()}");
#line 5959 "V3Const__gen.cpp"
#line 2266 "../V3Const.cpp"
//    TREEOP ("AstLogNot{$lhsp.castLt}",			"AstGte {$lhsp->op1p(),$lhsp->op2p()}");
#line 5962 "V3Const__gen.cpp"
#line 2267 "../V3Const.cpp"
//    TREEOPV("AstNot   {$lhsp.castLtS, $lhsp.width1}",	"AstGteS{$lhsp->op1p(),$lhsp->op2p()}");
#line 5965 "V3Const__gen.cpp"
#line 2268 "../V3Const.cpp"
//    TREEOP ("AstLogNot{$lhsp.castLtS}",			"AstGteS{$lhsp->op1p(),$lhsp->op2p()}");
#line 5968 "V3Const__gen.cpp"
#line 2269 "../V3Const.cpp"
//    TREEOPV("AstNot   {$lhsp.castLte, $lhsp.width1}",	"AstGt  {$lhsp->op1p(),$lhsp->op2p()}");
#line 5971 "V3Const__gen.cpp"
#line 2270 "../V3Const.cpp"
//    TREEOP ("AstLogNot{$lhsp.castLte}",			"AstGt  {$lhsp->op1p(),$lhsp->op2p()}");
#line 5974 "V3Const__gen.cpp"
#line 2271 "../V3Const.cpp"
//    TREEOPV("AstNot   {$lhsp.castLteS, $lhsp.width1}",	"AstGtS {$lhsp->op1p(),$lhsp->op2p()}");
#line 5977 "V3Const__gen.cpp"
#line 2272 "../V3Const.cpp"
//    TREEOP ("AstLogNot{$lhsp.castLteS}",		"AstGtS {$lhsp->op1p(),$lhsp->op2p()}");
#line 5980 "V3Const__gen.cpp"
#line 2273 "../V3Const.cpp"
//    TREEOPV("AstNot   {$lhsp.castGt, $lhsp.width1}",	"AstLte {$lhsp->op1p(),$lhsp->op2p()}");
#line 5983 "V3Const__gen.cpp"
#line 2274 "../V3Const.cpp"
//    TREEOP ("AstLogNot{$lhsp.castGt}",			"AstLte {$lhsp->op1p(),$lhsp->op2p()}");
#line 5986 "V3Const__gen.cpp"
#line 2275 "../V3Const.cpp"
//    TREEOPV("AstNot   {$lhsp.castGtS, $lhsp.width1}",	"AstLteS{$lhsp->op1p(),$lhsp->op2p()}");
#line 5989 "V3Const__gen.cpp"
#line 2276 "../V3Const.cpp"
//    TREEOP ("AstLogNot{$lhsp.castGtS}",			"AstLteS{$lhsp->op1p(),$lhsp->op2p()}");
#line 5992 "V3Const__gen.cpp"
#line 2277 "../V3Const.cpp"
//    TREEOPV("AstNot   {$lhsp.castGte, $lhsp.width1}",	"AstLt  {$lhsp->op1p(),$lhsp->op2p()}");
#line 5995 "V3Const__gen.cpp"
#line 2278 "../V3Const.cpp"
//    TREEOP ("AstLogNot{$lhsp.castGte}",			"AstLt  {$lhsp->op1p(),$lhsp->op2p()}");
#line 5998 "V3Const__gen.cpp"
#line 2279 "../V3Const.cpp"
//    TREEOPV("AstNot   {$lhsp.castGteS, $lhsp.width1}",	"AstLtS {$lhsp->op1p(),$lhsp->op2p()}");
#line 6001 "V3Const__gen.cpp"
#line 2280 "../V3Const.cpp"
//    TREEOP ("AstLogNot{$lhsp.castGteS}",		"AstLtS {$lhsp->op1p(),$lhsp->op2p()}");
#line 6004 "V3Const__gen.cpp"
#line 2281 "../V3Const.cpp"
    // Not common, but avoids compiler warnings about over shifting
//    TREEOP ("AstShiftL{operandHugeShiftL(nodep)}",	"replaceZero(nodep)");
#line 6008 "V3Const__gen.cpp"
#line 2283 "../V3Const.cpp"
//    TREEOP ("AstShiftR{operandHugeShiftR(nodep)}",	"replaceZero(nodep)");
#line 6011 "V3Const__gen.cpp"
#line 2284 "../V3Const.cpp"
//    TREEOP ("AstShiftL{operandShiftOp(nodep)}",		"replaceShiftOp(nodep)");
#line 6014 "V3Const__gen.cpp"
#line 2285 "../V3Const.cpp"
//    TREEOP ("AstShiftR{operandShiftOp(nodep)}",		"replaceShiftOp(nodep)");
#line 6017 "V3Const__gen.cpp"
#line 2286 "../V3Const.cpp"
//    TREEOP ("AstShiftL{operandShiftShift(nodep)}",	"replaceShiftShift(nodep)");
#line 6020 "V3Const__gen.cpp"
#line 2287 "../V3Const.cpp"
//    TREEOP ("AstShiftR{operandShiftShift(nodep)}",	"replaceShiftShift(nodep)");
#line 6023 "V3Const__gen.cpp"
#line 2288 "../V3Const.cpp"
//    TREEOP ("AstWordSel{operandWordOOB(nodep)}",	"replaceZero(nodep)");
#line 6026 "V3Const__gen.cpp"
#line 2289 "../V3Const.cpp"
    // Compress out EXTENDs to appease loop unroller
//    TREEOPV("AstEq    {$rhsp.castExtend,operandBiExtendConstShrink(nodep)}",	"DONE");
#line 6030 "V3Const__gen.cpp"
#line 2291 "../V3Const.cpp"
//    TREEOPV("AstNeq   {$rhsp.castExtend,operandBiExtendConstShrink(nodep)}",	"DONE");
#line 6033 "V3Const__gen.cpp"
#line 2292 "../V3Const.cpp"
//    TREEOPV("AstGt    {$rhsp.castExtend,operandBiExtendConstShrink(nodep)}",	"DONE");
#line 6036 "V3Const__gen.cpp"
#line 2293 "../V3Const.cpp"
//    TREEOPV("AstGte   {$rhsp.castExtend,operandBiExtendConstShrink(nodep)}",	"DONE");
#line 6039 "V3Const__gen.cpp"
#line 2294 "../V3Const.cpp"
//    TREEOPV("AstLt    {$rhsp.castExtend,operandBiExtendConstShrink(nodep)}",	"DONE");
#line 6042 "V3Const__gen.cpp"
#line 2295 "../V3Const.cpp"
//    TREEOPV("AstLte   {$rhsp.castExtend,operandBiExtendConstShrink(nodep)}",	"DONE");
#line 6045 "V3Const__gen.cpp"
#line 2296 "../V3Const.cpp"
//    TREEOPV("AstEq    {$rhsp.castExtend,operandBiExtendConstOver(nodep)}",	"replaceZero(nodep)");
#line 6048 "V3Const__gen.cpp"
#line 2297 "../V3Const.cpp"
//    TREEOPV("AstNeq   {$rhsp.castExtend,operandBiExtendConstOver(nodep)}",	"replaceNum(nodep,1)");
#line 6051 "V3Const__gen.cpp"
#line 2298 "../V3Const.cpp"
//    TREEOPV("AstGt    {$rhsp.castExtend,operandBiExtendConstOver(nodep)}",	"replaceNum(nodep,1)");
#line 6054 "V3Const__gen.cpp"
#line 2299 "../V3Const.cpp"
//    TREEOPV("AstGte   {$rhsp.castExtend,operandBiExtendConstOver(nodep)}",	"replaceNum(nodep,1)");
#line 6057 "V3Const__gen.cpp"
#line 2300 "../V3Const.cpp"
//    TREEOPV("AstLt    {$rhsp.castExtend,operandBiExtendConstOver(nodep)}",	"replaceZero(nodep)");
#line 6060 "V3Const__gen.cpp"
#line 2301 "../V3Const.cpp"
//    TREEOPV("AstLte   {$rhsp.castExtend,operandBiExtendConstOver(nodep)}",	"replaceZero(nodep)");
#line 6063 "V3Const__gen.cpp"
#line 2302 "../V3Const.cpp"
    // Identical operands on both sides
    // AstLogAnd/AstLogOr already converted to AstAnd/AstOr for these rules
    // AstAdd->ShiftL(#,1) but uncommon
//    TREEOP ("AstAnd    {operandsSame($lhsp,,$rhsp)}",	"replaceWLhs(nodep)");
#line 6069 "V3Const__gen.cpp"
#line 2306 "../V3Const.cpp"
//    TREEOP ("AstChangeXor{operandsSame($lhsp,,$rhsp)}",	"replaceZero(nodep)");
#line 6072 "V3Const__gen.cpp"
#line 2307 "../V3Const.cpp"
//    TREEOP ("AstDiv    {operandsSame($lhsp,,$rhsp)}",	"replaceNum(nodep,1)");
#line 6075 "V3Const__gen.cpp"
#line 2308 "../V3Const.cpp"
//    TREEOP ("AstDivS   {operandsSame($lhsp,,$rhsp)}",	"replaceNum(nodep,1)");
#line 6078 "V3Const__gen.cpp"
#line 2309 "../V3Const.cpp"
//    TREEOP ("AstOr     {operandsSame($lhsp,,$rhsp)}",	"replaceWLhs(nodep)");
#line 6081 "V3Const__gen.cpp"
#line 2310 "../V3Const.cpp"
//    TREEOP ("AstSub    {operandsSame($lhsp,,$rhsp)}",	"replaceZero(nodep)");
#line 6084 "V3Const__gen.cpp"
#line 2311 "../V3Const.cpp"
//    TREEOP ("AstXnor   {operandsSame($lhsp,,$rhsp)}",	"replaceAllOnes(nodep)");
#line 6087 "V3Const__gen.cpp"
#line 2312 "../V3Const.cpp"
//    TREEOP ("AstXor    {operandsSame($lhsp,,$rhsp)}",	"replaceZero(nodep)");
#line 6090 "V3Const__gen.cpp"
#line 2313 "../V3Const.cpp"
//    TREEOP ("AstEq     {operandsSame($lhsp,,$rhsp)}",	"replaceNum(nodep,1)");  // We let X==X -> 1, although in a true 4-state sim it's X.
#line 6093 "V3Const__gen.cpp"
#line 2314 "../V3Const.cpp"
//    TREEOP ("AstEqD    {operandsSame($lhsp,,$rhsp)}",	"replaceNum(nodep,1)");  // We let X==X -> 1, although in a true 4-state sim it's X.
#line 6096 "V3Const__gen.cpp"
#line 2315 "../V3Const.cpp"
//    TREEOP ("AstEqN    {operandsSame($lhsp,,$rhsp)}",	"replaceNum(nodep,1)");  // We let X==X -> 1, although in a true 4-state sim it's X.
#line 6099 "V3Const__gen.cpp"
#line 2316 "../V3Const.cpp"
//    TREEOP ("AstEqCase {operandsSame($lhsp,,$rhsp)}",	"replaceNum(nodep,1)");
#line 6102 "V3Const__gen.cpp"
#line 2317 "../V3Const.cpp"
//    TREEOP ("AstEqWild {operandsSame($lhsp,,$rhsp)}",	"replaceNum(nodep,1)");
#line 6105 "V3Const__gen.cpp"
#line 2318 "../V3Const.cpp"
//    TREEOP ("AstGt     {operandsSame($lhsp,,$rhsp)}",	"replaceZero(nodep)");
#line 6108 "V3Const__gen.cpp"
#line 2319 "../V3Const.cpp"
//    TREEOP ("AstGtD    {operandsSame($lhsp,,$rhsp)}",	"replaceZero(nodep)");
#line 6111 "V3Const__gen.cpp"
#line 2320 "../V3Const.cpp"
//    TREEOP ("AstGtN    {operandsSame($lhsp,,$rhsp)}",	"replaceZero(nodep)");
#line 6114 "V3Const__gen.cpp"
#line 2321 "../V3Const.cpp"
//    TREEOP ("AstGtS    {operandsSame($lhsp,,$rhsp)}",	"replaceZero(nodep)");
#line 6117 "V3Const__gen.cpp"
#line 2322 "../V3Const.cpp"
//    TREEOP ("AstGte    {operandsSame($lhsp,,$rhsp)}",	"replaceNum(nodep,1)");
#line 6120 "V3Const__gen.cpp"
#line 2323 "../V3Const.cpp"
//    TREEOP ("AstGteD   {operandsSame($lhsp,,$rhsp)}",	"replaceNum(nodep,1)");
#line 6123 "V3Const__gen.cpp"
#line 2324 "../V3Const.cpp"
//    TREEOP ("AstGteN   {operandsSame($lhsp,,$rhsp)}",	"replaceNum(nodep,1)");
#line 6126 "V3Const__gen.cpp"
#line 2325 "../V3Const.cpp"
//    TREEOP ("AstGteS   {operandsSame($lhsp,,$rhsp)}",	"replaceNum(nodep,1)");
#line 6129 "V3Const__gen.cpp"
#line 2326 "../V3Const.cpp"
//    TREEOP ("AstLt     {operandsSame($lhsp,,$rhsp)}",	"replaceZero(nodep)");
#line 6132 "V3Const__gen.cpp"
#line 2327 "../V3Const.cpp"
//    TREEOP ("AstLtD    {operandsSame($lhsp,,$rhsp)}",	"replaceZero(nodep)");
#line 6135 "V3Const__gen.cpp"
#line 2328 "../V3Const.cpp"
//    TREEOP ("AstLtN    {operandsSame($lhsp,,$rhsp)}",	"replaceZero(nodep)");
#line 6138 "V3Const__gen.cpp"
#line 2329 "../V3Const.cpp"
//    TREEOP ("AstLtS    {operandsSame($lhsp,,$rhsp)}",	"replaceZero(nodep)");
#line 6141 "V3Const__gen.cpp"
#line 2330 "../V3Const.cpp"
//    TREEOP ("AstLte    {operandsSame($lhsp,,$rhsp)}",	"replaceNum(nodep,1)");
#line 6144 "V3Const__gen.cpp"
#line 2331 "../V3Const.cpp"
//    TREEOP ("AstLteD   {operandsSame($lhsp,,$rhsp)}",	"replaceNum(nodep,1)");
#line 6147 "V3Const__gen.cpp"
#line 2332 "../V3Const.cpp"
//    TREEOP ("AstLteN   {operandsSame($lhsp,,$rhsp)}",	"replaceNum(nodep,1)");
#line 6150 "V3Const__gen.cpp"
#line 2333 "../V3Const.cpp"
//    TREEOP ("AstLteS   {operandsSame($lhsp,,$rhsp)}",	"replaceNum(nodep,1)");
#line 6153 "V3Const__gen.cpp"
#line 2334 "../V3Const.cpp"
//    TREEOP ("AstNeq    {operandsSame($lhsp,,$rhsp)}",	"replaceZero(nodep)");
#line 6156 "V3Const__gen.cpp"
#line 2335 "../V3Const.cpp"
//    TREEOP ("AstNeqD   {operandsSame($lhsp,,$rhsp)}",	"replaceZero(nodep)");
#line 6159 "V3Const__gen.cpp"
#line 2336 "../V3Const.cpp"
//    TREEOP ("AstNeqN   {operandsSame($lhsp,,$rhsp)}",	"replaceZero(nodep)");
#line 6162 "V3Const__gen.cpp"
#line 2337 "../V3Const.cpp"
//    TREEOP ("AstNeqCase{operandsSame($lhsp,,$rhsp)}",	"replaceZero(nodep)");
#line 6165 "V3Const__gen.cpp"
#line 2338 "../V3Const.cpp"
//    TREEOP ("AstNeqWild{operandsSame($lhsp,,$rhsp)}",	"replaceZero(nodep)");
#line 6168 "V3Const__gen.cpp"
#line 2339 "../V3Const.cpp"
//    TREEOP ("AstLogAnd {operandsSame($lhsp,,$rhsp), $lhsp.width1}",	"replaceWLhs(nodep)");
#line 6171 "V3Const__gen.cpp"
#line 2340 "../V3Const.cpp"
//    TREEOP ("AstLogOr  {operandsSame($lhsp,,$rhsp), $lhsp.width1}",	"replaceWLhs(nodep)");
#line 6174 "V3Const__gen.cpp"
#line 2341 "../V3Const.cpp"
    ///=== Verilog operators
    // Comparison against 1'b0/1'b1; must be careful about widths.
    // These use Not, so must be Verilog only
//    TREEOPV("AstEq    {$rhsp.width1, $lhsp.isZero,    $rhsp}",	"AstNot{$rhsp}");
#line 6180 "V3Const__gen.cpp"
#line 2345 "../V3Const.cpp"
//    TREEOPV("AstEq    {$lhsp.width1, $lhsp, $rhsp.isZero}",	"AstNot{$lhsp}");
#line 6183 "V3Const__gen.cpp"
#line 2346 "../V3Const.cpp"
//    TREEOPV("AstEq    {$rhsp.width1, $lhsp.isAllOnes, $rhsp}",	"replaceWRhs(nodep)");
#line 6186 "V3Const__gen.cpp"
#line 2347 "../V3Const.cpp"
//    TREEOPV("AstEq    {$lhsp.width1, $lhsp, $rhsp.isAllOnes}",	"replaceWLhs(nodep)");
#line 6189 "V3Const__gen.cpp"
#line 2348 "../V3Const.cpp"
//    TREEOPV("AstNeq   {$rhsp.width1, $lhsp.isZero,    $rhsp}",	"replaceWRhs(nodep)");
#line 6192 "V3Const__gen.cpp"
#line 2349 "../V3Const.cpp"
//    TREEOPV("AstNeq   {$lhsp.width1, $lhsp, $rhsp.isZero}",	"replaceWLhs(nodep)");
#line 6195 "V3Const__gen.cpp"
#line 2350 "../V3Const.cpp"
//    TREEOPV("AstNeq   {$rhsp.width1, $lhsp.isAllOnes, $rhsp}",	"AstNot{$rhsp}");
#line 6198 "V3Const__gen.cpp"
#line 2351 "../V3Const.cpp"
//    TREEOPV("AstNeq   {$lhsp.width1, $lhsp, $rhsp.isAllOnes}",	"AstNot{$lhsp}");
#line 6201 "V3Const__gen.cpp"
#line 2352 "../V3Const.cpp"
//    TREEOPV("AstLt    {$rhsp.width1, $lhsp.isZero,    $rhsp}",	"replaceWRhs(nodep)");  // Because not signed #s
#line 6204 "V3Const__gen.cpp"
#line 2353 "../V3Const.cpp"
//    TREEOPV("AstGt    {$lhsp.width1, $lhsp, $rhsp.isZero}",	"replaceWLhs(nodep)");  // Because not signed #s
#line 6207 "V3Const__gen.cpp"
#line 2354 "../V3Const.cpp"
    // Useful for CONDs added around ARRAYSEL's in V3Case step
//    TREEOPV("AstLte   {$lhsp->width()==$rhsp->width(), $rhsp.isAllOnes}", "replaceNum(nodep,1)");
#line 6211 "V3Const__gen.cpp"
#line 2356 "../V3Const.cpp"
    // Simplify reduction operators
    // This also gets &{...,0,....} => const 0  (Common for unused_ok signals)
//    TREEOPV("AstRedAnd{$lhsp, $lhsp.width1}",	"replaceWLhs(nodep)");
#line 6216 "V3Const__gen.cpp"
#line 2359 "../V3Const.cpp"
//    TREEOPV("AstRedOr {$lhsp, $lhsp.width1}",	"replaceWLhs(nodep)");
#line 6219 "V3Const__gen.cpp"
#line 2360 "../V3Const.cpp"
//    TREEOPV("AstRedXor{$lhsp, $lhsp.width1}",	"replaceWLhs(nodep)");
#line 6222 "V3Const__gen.cpp"
#line 2361 "../V3Const.cpp"
//    TREEOPV("AstRedAnd{$lhsp.castConcat}",	"AstAnd{AstRedAnd{$lhsp->castConcat()->lhsp()}, AstRedAnd{$lhsp->castConcat()->rhsp()}}");    // &{a,b} => {&a}&{&b}
#line 6225 "V3Const__gen.cpp"
#line 2362 "../V3Const.cpp"
//    TREEOPV("AstRedOr {$lhsp.castConcat}",	"AstOr {AstRedOr {$lhsp->castConcat()->lhsp()}, AstRedOr {$lhsp->castConcat()->rhsp()}}");    // |{a,b} => {|a}|{|b}
#line 6228 "V3Const__gen.cpp"
#line 2363 "../V3Const.cpp"
//    TREEOPV("AstRedXor{$lhsp.castConcat}",	"AstXor{AstRedXor{$lhsp->castConcat()->lhsp()}, AstRedXor{$lhsp->castConcat()->rhsp()}}");    // ^{a,b} => {^a}^{^b}
#line 6231 "V3Const__gen.cpp"
#line 2364 "../V3Const.cpp"
//    TREEOPV("AstRedAnd{$lhsp.castExtend, $lhsp->width() > $lhsp->castExtend()->lhsp()->width()}",	"replaceZero(nodep)");	// &{0,...} => 0    Prevents compiler limited range error
#line 6234 "V3Const__gen.cpp"
#line 2365 "../V3Const.cpp"
//    TREEOPV("AstRedOr {$lhsp.castExtend}",	"AstRedOr {$lhsp->castExtend()->lhsp()}");
#line 6237 "V3Const__gen.cpp"
#line 2366 "../V3Const.cpp"
//    TREEOPV("AstRedXor{$lhsp.castExtend}",	"AstRedXor{$lhsp->castExtend()->lhsp()}");
#line 6240 "V3Const__gen.cpp"
#line 2367 "../V3Const.cpp"
//    TREEOPV("AstOneHot{$lhsp.width1}",		"replaceWLhs(nodep)");
#line 6243 "V3Const__gen.cpp"
#line 2368 "../V3Const.cpp"
//    TREEOPV("AstOneHot0{$lhsp.width1}",		"replaceNum(nodep,1)");
#line 6246 "V3Const__gen.cpp"
#line 2369 "../V3Const.cpp"
    // Binary AND/OR is faster than logical and/or (usually)
//    TREEOPV("AstLogAnd{$lhsp.width1, $rhsp.width1, isTPure($lhsp), isTPure($rhsp)}", "AstAnd{$lhsp,$rhsp}");
#line 6250 "V3Const__gen.cpp"
#line 2371 "../V3Const.cpp"
//    TREEOPV("AstLogOr {$lhsp.width1, $rhsp.width1, isTPure($lhsp), isTPure($rhsp)}", "AstOr{$lhsp,$rhsp}");
#line 6253 "V3Const__gen.cpp"
#line 2372 "../V3Const.cpp"
//    TREEOPV("AstLogNot{$lhsp.width1, isTPure($lhsp)}",	"AstNot{$lhsp}");
#line 6256 "V3Const__gen.cpp"
#line 2373 "../V3Const.cpp"
    // CONCAT(CONCAT({a},{b}),{c}) -> CONCAT({a},CONCAT({b},{c}))
    // CONCAT({const},CONCAT({const},{c})) -> CONCAT((constifiedCONC{const|const},{c}))
//    TREEOPV("AstConcat{operandConcatMove(nodep)}",	"moveConcat(nodep)");
#line 6261 "V3Const__gen.cpp"
#line 2376 "../V3Const.cpp"
//    TREEOPV("AstConcat{$lhsp.isZero, $rhsp}",		"replaceExtend(nodep, nodep->rhsp())");
#line 6264 "V3Const__gen.cpp"
#line 2377 "../V3Const.cpp"
    // CONCAT(a[1],a[0]) -> a[1:0]
//    TREEOPV("AstConcat{$lhsp.castSel, $rhsp.castSel, ifAdjacentSel($lhsp->castSel(),,$rhsp->castSel())}",  "replaceConcatSel(nodep)");
#line 6268 "V3Const__gen.cpp"
#line 2379 "../V3Const.cpp"
//    TREEOPV("AstConcat{ifConcatMergeableBiop($lhsp), concatMergeable($lhsp,,$rhsp)}", "replaceConcatMerge(nodep)");
#line 6271 "V3Const__gen.cpp"
#line 2380 "../V3Const.cpp"
    // Common two-level operations that can be simplified
//    TREEOP ("AstAnd {$lhsp.castOr, $rhsp.castOr, operandAndOrSame(nodep)}",	"replaceAndOr(nodep)");
#line 6275 "V3Const__gen.cpp"
#line 2382 "../V3Const.cpp"
//    TREEOP ("AstOr  {$lhsp.castAnd,$rhsp.castAnd,operandAndOrSame(nodep)}",	"replaceAndOr(nodep)");
#line 6278 "V3Const__gen.cpp"
#line 2383 "../V3Const.cpp"
//    TREEOP ("AstOr  {matchOrAndNot(nodep)}",		"DONE");
#line 6281 "V3Const__gen.cpp"
#line 2384 "../V3Const.cpp"
//    TREEOP ("AstAnd {operandShiftSame(nodep)}",		"replaceShiftSame(nodep)");
#line 6284 "V3Const__gen.cpp"
#line 2385 "../V3Const.cpp"
//    TREEOP ("AstOr  {operandShiftSame(nodep)}",		"replaceShiftSame(nodep)");
#line 6287 "V3Const__gen.cpp"
#line 2386 "../V3Const.cpp"
//    TREEOP ("AstXor {operandShiftSame(nodep)}",		"replaceShiftSame(nodep)");
#line 6290 "V3Const__gen.cpp"
#line 2387 "../V3Const.cpp"
    //      "AstXnor{operandShiftSame(nodep)}",		// Cannot ShiftSame as the shifted-in zeros might create a one
    // Note can't simplify a extend{extends}, extends{extend}, as the sign bits end up in the wrong places
//    TREEOPV("AstExtend {$lhsp.castExtend}",		"replaceExtend(nodep, nodep->lhsp()->castExtend()->lhsp())");
#line 6295 "V3Const__gen.cpp"
#line 2390 "../V3Const.cpp"
//    TREEOPV("AstExtendS{$lhsp.castExtendS}",		"replaceExtend(nodep, nodep->lhsp()->castExtendS()->lhsp())");
#line 6298 "V3Const__gen.cpp"
#line 2391 "../V3Const.cpp"
//    TREEOPV("AstReplicate{$lhsp, $rhsp.isOne, $lhsp->width()==nodep->width()}",	"replaceWLhs(nodep)");  // {1{lhs}}->lhs
#line 6301 "V3Const__gen.cpp"
#line 2392 "../V3Const.cpp"
//    TREEOPV("AstReplicateN{$lhsp, $rhsp.isOne, $lhsp->width()==nodep->width()}", "replaceWLhs(nodep)");  // {1{lhs}}->lhs
#line 6304 "V3Const__gen.cpp"
#line 2393 "../V3Const.cpp"
//    TREEOPV("AstReplicate{$lhsp.castReplicate, operandRepRep(nodep)}", "DONE");  // {2{3{lhs}}}->{6{lhs}}
#line 6307 "V3Const__gen.cpp"
#line 2394 "../V3Const.cpp"
//    TREEOPV("AstConcat{operandConcatSame(nodep)}", "DONE");  // {a,a}->{2{a}}, {a,2{a}}->{3{a}, etc
#line 6310 "V3Const__gen.cpp"
#line 2395 "../V3Const.cpp"
    // Next rule because AUTOINST puts the width of bits in
    // to pins, even when the widths are exactly the same across the hierarchy.
//    TREEOPV("AstSel{operandSelExtend(nodep)}",	"DONE");
#line 6315 "V3Const__gen.cpp"
#line 2398 "../V3Const.cpp"
//    TREEOPV("AstSel{operandSelFull(nodep)}",	"replaceWChild(nodep, nodep->fromp())");
#line 6318 "V3Const__gen.cpp"
#line 2399 "../V3Const.cpp"
//    TREEOPV("AstSel{$fromp.castSel}",		"replaceSelSel(nodep)");
#line 6321 "V3Const__gen.cpp"
#line 2400 "../V3Const.cpp"
//    TREEOPV("AstSel{$fromp.castAdd, operandSelBiLower(nodep)}",	"DONE");
#line 6324 "V3Const__gen.cpp"
#line 2401 "../V3Const.cpp"
//    TREEOPV("AstSel{$fromp.castAnd, operandSelBiLower(nodep)}",	"DONE");
#line 6327 "V3Const__gen.cpp"
#line 2402 "../V3Const.cpp"
//    TREEOPV("AstSel{$fromp.castOr,  operandSelBiLower(nodep)}",	"DONE");
#line 6330 "V3Const__gen.cpp"
#line 2403 "../V3Const.cpp"
//    TREEOPV("AstSel{$fromp.castSub, operandSelBiLower(nodep)}",	"DONE");
#line 6333 "V3Const__gen.cpp"
#line 2404 "../V3Const.cpp"
//    TREEOPV("AstSel{$fromp.castXnor,operandSelBiLower(nodep)}",	"DONE");
#line 6336 "V3Const__gen.cpp"
#line 2405 "../V3Const.cpp"
//    TREEOPV("AstSel{$fromp.castXor, operandSelBiLower(nodep)}",	"DONE");
#line 6339 "V3Const__gen.cpp"
#line 2406 "../V3Const.cpp"
//    TREEOPV("AstSel{$fromp.castShiftR, operandSelShiftLower(nodep)}",	"DONE");
#line 6342 "V3Const__gen.cpp"
#line 2407 "../V3Const.cpp"
//    TREEOPC("AstSel{$fromp.castConst, $lsbp.castConst, $widthp.castConst, }",	"replaceConst(nodep)");
#line 6345 "V3Const__gen.cpp"
#line 2408 "../V3Const.cpp"
//    TREEOPV("AstSel{$fromp.castConcat, $lsbp.castConst, $widthp.castConst, }",	"replaceSelConcat(nodep)");
#line 6348 "V3Const__gen.cpp"
#line 2409 "../V3Const.cpp"
//    TREEOPV("AstSel{$fromp.castReplicate, $lsbp.castConst, $widthp.castConst, operandSelReplicate(nodep) }",	"DONE");
#line 6351 "V3Const__gen.cpp"
#line 2410 "../V3Const.cpp"
    // V3Tristate requires selects below BufIf1.
    // Also do additional operators that are bit-independent, but only definite
    // win if bit select is a constant (otherwise we may need to compute bit index several times)
//    TREEOPV("AstSel{$fromp.castBufIf1}",		"replaceSelIntoBiop(nodep)");
#line 6357 "V3Const__gen.cpp"
#line 2414 "../V3Const.cpp"
//    TREEOPV("AstSel{$fromp.castNot}",			"replaceSelIntoUniop(nodep)");
#line 6360 "V3Const__gen.cpp"
#line 2415 "../V3Const.cpp"
//    TREEOPV("AstSel{$fromp.castAnd,$lhsp.castConst}",	"replaceSelIntoUniop(nodep)");
#line 6363 "V3Const__gen.cpp"
#line 2416 "../V3Const.cpp"
//    TREEOPV("AstSel{$fromp.castOr,$lhsp.castConst}",	"replaceSelIntoUniop(nodep)");
#line 6366 "V3Const__gen.cpp"
#line 2417 "../V3Const.cpp"
//    TREEOPV("AstSel{$fromp.castXor,$lhsp.castConst}",	"replaceSelIntoUniop(nodep)");
#line 6369 "V3Const__gen.cpp"
#line 2418 "../V3Const.cpp"
//    TREEOPV("AstSel{$fromp.castXnor,$lhsp.castConst}",	"replaceSelIntoUniop(nodep)");
#line 6372 "V3Const__gen.cpp"
#line 2419 "../V3Const.cpp"
    // Conversions
//    TREEOPV("AstRedXnor{$lhsp}",		"AstNot{AstRedXor{$lhsp}}");  // Just eliminate XNOR's
#line 6376 "V3Const__gen.cpp"
#line 2421 "../V3Const.cpp"
    // This visit function here must allow for short-circuiting.
//    TREEOPS("AstLogIf {$lhsp.isZero}",		"replaceNum(nodep, 1)");
#line 6380 "V3Const__gen.cpp"
#line 2423 "../V3Const.cpp"
//    TREEOPV("AstLogIf {$lhsp, $rhsp}",		"AstLogOr{AstLogNot{$lhsp},$rhsp}");
#line 6383 "V3Const__gen.cpp"
#line 2424 "../V3Const.cpp"
//    TREEOPV("AstLogIff{$lhsp, $rhsp}",		"AstLogNot{AstXor{$lhsp,$rhsp}}");
#line 6386 "V3Const__gen.cpp"
#line 2425 "../V3Const.cpp"
    // Strings
//    TREEOPC("AstCvtPackString{$lhsp.castConst}",	"replaceConstString(nodep, nodep->lhsp()->castConst()->num().toString())");
#line 6390 "V3Const__gen.cpp"
#line 2427 "../V3Const.cpp"


    // Possible futures:
    // (a?(b?y:x):y) -> (a&&!b)?x:y
    // (a?(b?x:y):y) -> (a&&b)?x:y
    // (a?x:(b?x:y)) -> (a||b)?x:y
    // (a?x:(b?y:x)) -> (a||!b)?x:y

    // Note we can't convert EqCase/NeqCase to Eq/Neq here because that would break 3'b1x1==3'b101

    //-----
    virtual void visit(AstNode* nodep) {
	// Default: Just iterate
	if (m_required) {
	    if (nodep->castNodeDType() || nodep->castRange()) {
		// Ignore dtypes for parameter type pins
	    } else {
		nodep->v3error("Expecting expression to be constant, but can't convert a "
			       <<nodep->prettyTypeName()<<" to constant.");
	    }
	} else {
	    // Calculate the width of this operation
	    if (m_params && !nodep->width()) {
		nodep = V3Width::widthParamsEdit(nodep);
	    }
	    nodep->iterateChildren(*this);
	}
    }

public:
    // Processing Mode Enum
    enum ProcMode {
	PROC_PARAMS,
	PROC_GENERATE,
	PROC_LIVE,
	PROC_V_WARN,
	PROC_V_NOWARN,
	PROC_V_EXPENSIVE,
	PROC_CPP
    };

    // CONSTUCTORS
    explicit ConstVisitor(ProcMode pmode) {
	m_params = false;
	m_required = false;
	m_doExpensive = false;
	m_doNConst = false;
	m_doShort = true;	// Presently always done
	m_doV = false;
	m_doGenerate = false;	// Inside generate conditionals
        m_hasJumpGo = false;
	m_warn = false;
	m_wremove = true;  // Overridden in visitors
	m_modp = NULL;
	m_selp = NULL;
	m_scopep = NULL;
	m_attrp = NULL;
	//
	switch (pmode) {
	case PROC_PARAMS:	m_doV = true;  m_doNConst = true; m_params = true; m_required = true; break;
	case PROC_GENERATE:	m_doV = true;  m_doNConst = true; m_params = true; m_required = true; m_doGenerate = true; break;
	case PROC_LIVE:		break;
	case PROC_V_WARN:	m_doV = true;  m_doNConst = true; m_warn = true; break;
	case PROC_V_NOWARN:	m_doV = true;  m_doNConst = true; break;
	case PROC_V_EXPENSIVE:	m_doV = true;  m_doNConst = true; m_doExpensive = true; break;
	case PROC_CPP:		m_doV = false; m_doNConst = true; break;
	default:		v3fatalSrc("Bad case"); break;
	}
    }
    virtual ~ConstVisitor() {}
    AstNode* mainAcceptEdit(AstNode* nodep) {
	// Operate starting at a random place
	return nodep->iterateSubtreeReturnEdits(*this);
    }
};

//######################################################################
// Const class functions

//! Force this cell node's parameter list to become a constant
//! @return  Pointer to the edited node.
AstNode* V3Const::constifyParamsEdit(AstNode* nodep) {
    //if (debug()>0) nodep->dumpTree(cout,"  forceConPRE : ");
    // Resize even if the node already has a width, because buried in the tree
    // we may have a node we just created with signing, etc, that isn't sized yet.

    // Make sure we've sized everything first
    nodep = V3Width::widthParamsEdit(nodep);
    ConstVisitor visitor(ConstVisitor::PROC_PARAMS);
    if (AstVar* varp=nodep->castVar()) {
	// If a var wants to be constified, it's really a param, and
	// we want the value to be constant.  We aren't passed just the
	// init value because we need widthing above to handle the var's type.
	if (varp->valuep()) visitor.mainAcceptEdit(varp->valuep());
    } else {
	nodep = visitor.mainAcceptEdit(nodep);
    }
    // Because we do edits, nodep links may get trashed and core dump this.
    //if (debug()>0) nodep->dumpTree(cout,"  forceConDONE: ");
    return nodep;
}

//! Force this cell node's parameter list to become a constant inside generate.
//! If we are inside a generated "if", "case" or "for", we don't want to
//! trigger warnings when we deal with the width. It is possible that these
//! are spurious, existing within sub-expressions that will not actually be
//! generated. Since such occurrences, must be constant, in order to be
//! someting a generate block can depend on, we can wait until later to do the
//! width check.
//! @return  Pointer to the edited node.
AstNode* V3Const::constifyGenerateParamsEdit(AstNode* nodep) {
    //if (debug()>0) nodep->dumpTree(cout,"  forceConPRE : ");
    // Resize even if the node already has a width, because buried in the tree
    // we may have a node we just created with signing, etc, that isn't sized
    // yet.

    // Make sure we've sized everything first
    nodep = V3Width::widthGenerateParamsEdit(nodep);
    ConstVisitor visitor(ConstVisitor::PROC_GENERATE);
    if (AstVar* varp=nodep->castVar()) {
	// If a var wants to be constified, it's really a param, and
	// we want the value to be constant.  We aren't passed just the
	// init value because we need widthing above to handle the var's type.
	if (varp->valuep()) visitor.mainAcceptEdit(varp->valuep());
    } else {
	nodep = visitor.mainAcceptEdit(nodep);
    }
    // Because we do edits, nodep links may get trashed and core dump this.
    //if (debug()>0) nodep->dumpTree(cout,"  forceConDONE: ");
    return nodep;
}

void V3Const::constifyAllLint(AstNetlist* nodep) {
    // Only call from Verilator.cpp, as it uses user#'s
    UINFO(2,__FUNCTION__<<": "<<endl);
    ConstVisitor visitor (ConstVisitor::PROC_V_WARN);
    (void)visitor.mainAcceptEdit(nodep);
    V3Global::dumpCheckGlobalTree("const", 0, v3Global.opt.dumpTreeLevel(__FILE__) >= 3);
}

void V3Const::constifyCpp(AstNetlist* nodep) {
    UINFO(2,__FUNCTION__<<": "<<endl);
    ConstVisitor visitor (ConstVisitor::PROC_CPP);
    (void)visitor.mainAcceptEdit(nodep);
    V3Global::dumpCheckGlobalTree("const_cpp", 0, v3Global.opt.dumpTreeLevel(__FILE__) >= 3);
}

AstNode* V3Const::constifyEdit(AstNode* nodep) {
    ConstVisitor visitor (ConstVisitor::PROC_V_NOWARN);
    nodep = visitor.mainAcceptEdit(nodep);
    return nodep;
}

void V3Const::constifyAllLive(AstNetlist* nodep) {
    // Only call from Verilator.cpp, as it uses user#'s
    // This only pushes constants up, doesn't make any other edits
    // IE doesn't prune dead statements, as we need to do some usability checks after this
    UINFO(2,__FUNCTION__<<": "<<endl);
    ConstVisitor visitor (ConstVisitor::PROC_LIVE);
    (void)visitor.mainAcceptEdit(nodep);
    V3Global::dumpCheckGlobalTree("const", 0, v3Global.opt.dumpTreeLevel(__FILE__) >= 3);
}

void V3Const::constifyAll(AstNetlist* nodep) {
    // Only call from Verilator.cpp, as it uses user#'s
    UINFO(2,__FUNCTION__<<": "<<endl);
    ConstVisitor visitor (ConstVisitor::PROC_V_EXPENSIVE);
    (void)visitor.mainAcceptEdit(nodep);
    V3Global::dumpCheckGlobalTree("const", 0, v3Global.opt.dumpTreeLevel(__FILE__) >= 3);
}

AstNode* V3Const::constifyExpensiveEdit(AstNode* nodep) {
    ConstVisitor visitor (ConstVisitor::PROC_V_EXPENSIVE);
    nodep = visitor.mainAcceptEdit(nodep);
    return nodep;
}
